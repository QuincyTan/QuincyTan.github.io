<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法设计与分析 学习笔记]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[[TOC] 第1章 算法概述算法定义：解决问题的有穷序列指令 算法的性质：输入、输出、确定性、有限性 程序和算法的区别：程序可不满足有限性，比如操作系统 求上下界函数： \lim_{n\rightarrow\infty} \frac{f(n)}{g(n)} = \begin{cases}0, & \text{f(n)=O(g(n))}\\\infty, & \text{f(n)= $\Omega$(g(n))}\\c,& \text{f(n)=$\Theta$(g(n))} \end{cases} 第2章 递归与分治一般递归方程时间复杂度分析 T(n)1} \end{cases}其中，a是子问题的个数，b是递减的步长，|表示递减方式，D(n)是合成子问题的开销 当|为减法： T(n)1}\\ O(n),&\text{a=1} \end{cases}当|为除法： $p=log_ba$ ①D(n)为常数 T(n)1}\\ O(log_bn),&\text{a=1} \end{cases}②D(n)为线性函数cn T(n)]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>算法设计与分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物联网概论 学习笔记]]></title>
    <url>%2F%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%AE%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[物联网（IoT）：Internet of Things 物联网是具有自我标示、感知和智能的物理实体基于通信技术相互连接形成的网络，这些物理设备可以在无需人工干预的条件下实现协同和互动，为人们提供智慧和集约的服务，传感网是物联网的基础，是物联网的组成部分 物联网三层体系结构：感知层、网络层和应用层 感知层是物联网的皮肤和五官——识别物体，采集信息； 网络层是物联网的神经中枢和大脑——信息传递和处理； 应用层是物联网的“社会分工”——与行业需求结合，实现广泛智能化 RFID系统的基本组成： ①硬件组成：RFID标签、识读器、天线和主机 ②软件组成：RFID系统软件、中间件和应用软件 RFID系统结构通过空中接口将电子标签与读写器连接 RFID系统的原理： ①耦合(Coupling)：根据需求和成本可利用电磁波和磁感应 ②磁耦合 ③电磁波耦合(反向散射原理) RFID频段分布 低频：125.124KHz 恶劣环境下使用 高频：13.56MHz 门禁卡、公交卡等 超高频：433.92Mhz / 868-960Mhz 微波：2.45GHz 一般传感器的定义：测量装置、输入与输出有对应关系、有一定的精确度 一般传感器的组成： ①敏感元件：直接感受被测量、并输出与被测量成确定关系的某一物理量的元件 ②转换元件：敏感元件的输出就是它的输入，将感受到的非电量直接转换为电量的元件 ③测量电路：将转换元件输出的电量变换为便于显示、记录、控制、处理的有用电信号 传感器的静态特性： ①线性度：指其输出量与输入量之间的实际关系曲线(即静态特征曲线)偏离直线的程度，又称为非线性误差 ②灵敏度：指传感器在稳态下的输出变化量△y与引起变化的输入变化△x之比 ③迟滞：传感器在正(输入量增大)和反(输入量减小)行程期间，其输出-输入特性曲线不重合的现象 ④重复性：在输入按同一方向连续多次变动时得到特性曲线不一致的程度 ⑤分辨率：在测量方向内所能测量输入量的最小变化量△x ⑥漂移：在外界的干扰下，输出量发生与输入量无关的变化 应变片式传感器——电桥 ①直流电桥：$K_{u} = U/4$ ②半差动电桥(双臂电桥)：$K_{u} = U/2$ ③全桥电路：$K_{u} = U$ 电容式传感器：$c_0 = \frac{\epsilon_0\epsilon_rS}{d_0}$ ①变极距型 ②变面积型 ③变介质型 变磁阻式(自感)传感器： 电感：在电路中电流发生变化时能产生电动势的性质成为电感，分为自感和互感 自感：当线圈中有电流通过时，线圈的周围就会产生磁场。当线圈中电流发生变化时，其周围的磁场也产生相应的变化，此变化可使线圈自身产生感应电动势，这就是自感 工作原理：气隙厚度的改变，使得磁路中磁阻值变化，从而导致电路电感值变化 压电式传感器 Z为光轴，X为电轴，Y为机械轴 压电效应称为纵向压电效应，沿Y方向产生的为横向压电效应，沿Z轴不产生 侧压力时线性度不好，需要在力传递系统中加入预加力，称预载 光电式传感器 光的频率越高，其光子能量就越大。当具有一定能量的光子作用到某些物体上转化为该物体中一些电子的能量而产生电效应，这种效应成为光电效应 分类：外光电效应（光线照到某些物体上造成表面电子逸出的现象） 光电导效应、光生伏特效应(内光电效应) （物体受光照后，内部原子释放出电子不能逸出表面，使物体电阻率发生变化或产生光电动势的现象） 无线传感器 定义：是大量的静止或移动的传感器以自组织和多跳的方式构成的无线网络，目的是协作地采集、处理、传输网络覆盖地域内感知对象的检测信息，并报告用户 网络节点组成：传感模块—计算模块—通信模块——存储模块 无线传感网：WSN(Wireless sensor network) 待更…]]></content>
      <categories>
        <category>物联网概论</category>
      </categories>
      <tags>
        <tag>物联网概论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率论与数理统计 学习笔记]]></title>
    <url>%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[[TOC] 第一章 随机事件及其概率第一节 随机事件及其频率、概率的统计定义随机事件(偶然事件)：在试验的结果中，可能发生、也可能不发生的事件 随机事件的频率具有一定的稳定性 随机事件的概率为频率的近似值 P(A)\approxf(A) = $\frac{m}{n}$ 必然事件 P(U)=1 不可能事件 P(V)=0 第二节 样本空间样本点：随机试验的每一个可能出现的且是最简单的不可再分的结果 样本空间：所有的样本点构成的集合（分可列个和不可列个） 任一随机事件A都是样本空间Ω的一个子集 第三节 事件的关系及运算包含/包含于：$A \subset B$ 和(并)：$A∪B$ 积(交)：$A∩B 或 AB$ 互斥(互不相容)：两个互不相容的和 $A+B$ 对立(逆) 完备事件组：n个事件至少有一个事件一定发生 交换律、结合律、分配律、德摩根律 第四节 概率的古典定义乘法定理：完成一件事需r步，第i步有$ m_ i $种方法，完成这件事总方法数 $ m_ 1m_ 2…m_ r $ 加法定理：完成一件事有r类方法，第i类有$ m_ i $种方法，完成这件事总方法数 $ m_ 1+m_ 2+…+m_ r $ 排列：$ A _ n ^m = \frac{n!}{(n-m)!} $ 组合：$ C _ n ^m = \frac{A _ n ^m}{P_ m} = \frac{n!}{(n-m)!m!}$ 概率的古典定义：试验样本总共有$ n_Ω$ 个等可能的基本事件，其中随机事件A包含$ n_A$个基本事件，($ n_A$&lt;=$ n_Ω$) 则 $P(A) = \frac{n_A}{n_Ω}$ 不放回依次抽样与一次抽样的一致性 、 抽签次序无关性 第五节 概率加法定理若随机事件A与B互斥，即$AB = \emptyset，则P(A+B)= P(A)+P(B) \Rightarrow P(A)+P(\overline{A})=1$ 若A、B是任意的两个随机事件，则二者和事件的概率为 $P(A∪B)=P(A)+P(B)-P(AB)$ &ensp;&ensp; $\Rightarrow P(A∪B∪C)=P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC) $ 第六节 条件概率与乘法定理$P(B|A)=\frac{P(AB)}{P(A)}$ 若$P(A_1A_2…A_{n-1})&gt;0,则 P(A_1A_2…A_{n})=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1A_2…A_n-1)$ 第七节 全概率公式与贝叶斯公式&ensp;&ensp;先验，由因溯果 P(A) = \sum_{i=1}^nP(B_i)P(A|B_i) &ensp;&ensp;后验，由果溯因 P(B_i|A) = \frac{P(AB_i)}{P(A)} = \frac{P(B_i)P(A|B_i)}{\sum_{i=1}^nP(B_i)P(A|B_i)},i=1,2,...,n第八节 随机事件的独立性若两事件A与B满足P(AB) = P(A)P(B)，则称事件A与B相互独立 &ensp;&ensp;性质1：不可能事件及必然事件与任意的随机事件相互独立 &ensp;&ensp;性质2：A与B相互独立，则A与$\overline{B},\overline{A}与B,\overline{A}与\overline{A}$也相互独立&ensp;&ensp;（相互对称性） 第九节 贝努力概型事件A恰好发生k次的概率：$P_n(k) = C_n^kp^kq^{n-k},k=0,1,2,…,n$ $\sum_{k=0}^nP_n(k) = \sum_{k=0}^nC_n^kp^kq^{n-k} = (p+q)^n = 1$ 事件A发生次数介于$m_1$与$m_2$之间：$P_n(m_1&lt;=k&lt;=m_2) = \sum_{k=m1}^{m2}P_n(k)$ 事件A至少发生r次：$P(k&gt;=r) = \sum_{k=r}^nP_n(k) = 1 - \sum_{k=0}^{r-1}P_n(k)$ 第十节 概率论的公理化体系非负性：P(A)&gt;=0; 规范性：P(Ω)=1; 可列可加性(可数可加性)：$A_1,A_2,…$ 两两互不相容，则$P(\sum_{i=1}^\infty A_i) = \sum_{i=1}^\infty P(A_i)$ 第二章 随机变量及其分布第一节 随机变量的概念设Ω为随机变量的样本空间，如果对每一个样本点$\omega \in Ω$，均有唯一确定的实数X($\omega$)与之对应，即存在一个定义于Ω的单值实函数X=X($\omega$)，则称X=X($\omega$)为样本空间Ω上的随机变量 第二节 离散型随机变量的概率分布性质： ①$p_k&gt;=0 (k=1,2,..) $ ②$\sum_{k=1}^{\infty}p_k = 1$ 第三节 几种常用的离散型随机变量的分布“0-1”分布：$P(X=1) = p，P(X=0) = q（0&lt;p&lt;1，p+q=1）$ 超几何分布：$P(X=m) = \frac{C_M^mC_{N-M}^{n-m}}{C_N^n} （n&lt;=N,M&lt;=N）$ 二项分布：$P(X=k) = C_n^kp^kq^{n-k} （k=0,1,2,…,n）$ 记作X ~ B(n,p) &ensp;&ensp;二项式分布的最可能取值( P(X=k)取得最大值的k )： &ensp;&ensp;①若(n+1)p不是整数，则其整数部分[(n+1)p]即为所求； &ensp;&ensp;②若(n+1)p=m是整数，则m和m-1即为所求 泊松分布：$P(X=k) = P_{\lambda}(k) = \frac{\lambda^k}{k!}e^{-\lambda} （k=0,1,2,…）$ &ensp;&ensp;泊松定理： 几何分布： 第三章 多维随机变量及其分布 第四章 随机变量的数字特征 第五章 大数定律与中心极限定理 第六章 数理统计的基本概念与抽样分析 第七章 参数估计 第八章 假设验证 待更…]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>概率论与数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络 学习笔记]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[[TOC] 第1章 概述1.1 计算机网络在信息时代中的作用&ensp;&ensp;网络分类：电信网络、有线电视网络和计算机网络 &ensp;&ensp;互联网基本特点： &ensp;&ensp;①连通性：互联网用户不管距离多远，都能通信，就像这些用户终端都彼此连通 &ensp;&ensp;②共享：指资源共享，包含信息、软件、硬件等共享，就像资源在用户身边 1.2 互联网概述&ensp;&ensp;计算机网络组成：由若干结点和连接这些结点的链路组成；结点可以是计算机、集线器、交换机或路由器等 &ensp;&ensp;互连网：网络之间通过路由互连起来，形成更大的网络，是网络的网络 &ensp;&ensp;主机(host)：与网络相连的计算机 &ensp;&ensp;互联网基础结构发展的三个阶段：ARPANET → 三级结构（主干网、地区网、校园网(企业网)）→ 多层次ISP结构 &ensp;&ensp;互联网制定的正式标准阶段：互联网草案 → 建议文档(RFC) → 互联网标准 1.3 互联网的组成从工作方式上分为： (1) 边缘部分：由互联网上的主机组成，是用户直接使用的部分，用来进行通信和资源共享 &ensp;&ensp; 端系统：主机 &ensp;&ensp; 计算机之间的通信：主机A上的进程与主机B上的进程进行通信 &ensp;&ensp; 端系统间通信方式： &ensp;&ensp; ① 客户-服务器方式 &ensp;&ensp; 客户和服务器：指通信中涉及的两个应用进程 &ensp;&ensp; 主要特点：客户是服务请求方（主动发起请求服务，需要知道服务器地址），服务器是服务提供方（可同时处理多个服务请求，需要强大的硬件和高级的操作系统支持） &ensp;&ensp;② 对等连接方式 &ensp;&ensp;两台主机不区分服务器和客户，只要都运行p2p软件，就可以进行平等对等连接通信，双方都可访问对方硬盘中的共享文档，可支持大量对等用户同时工作 (2) 核心部分：由大量网络和连接这些网络的路由器组成，是为边缘部分提供服务的，提供连通性和交换 &ensp;&ensp;路由器：实现分组交换的关键构件，任务是转发收到的分组，是网络核心部分最重要的功能 &ensp;&ensp;三种交换方式： &ensp;&ensp;① 电路交换 &ensp;&ensp;建立连接(占用通信资源)-&gt;通话(一直占用通信资源)-&gt;释放连接(归还通信资源) &ensp;&ensp;② 报文交换 &ensp;&ensp;整个报文先传送到相邻结点，全部存储下来后查找转发表，转发给下一个结点 &ensp;&ensp;③ 分组交换 &ensp;&ensp;报文：要发送的整块数据 &ensp;&ensp;分组(包)：报文分成的若干数据块，再加上必要控制信息，分组的头又称包头，含源地址、目的地址等信息 &ensp;&ensp;存储转发技术：路由器收到分组后，先暂时存储，检查其首部，查找转发表，按照首部中目的地址，选择合适的接口转发出去 &ensp;&ensp;优点： &ensp;&ensp;高效：在分组传输过程动态分配传输带宽，对通信链路逐段占用 &ensp;&ensp;灵活：为每个分组独立选择最合适的转发路由 &ensp;&ensp;迅速：以分组为单位传输，不用建立和释放连接 &ensp;&ensp;可靠：保证可靠性的网络协议；分布式多路由器的分组交换网，有很好的生存性 1.4 计算机在我国的发展1.5 计算机网络的类别&ensp;&ensp;计算机网络定义：主要由一些通用的可编程的硬件(一定包含CPU)互连而成的，而这些硬件并非专门来实现某一特定目的(传送数据或视频信号)。这些硬件能够传送多种类型数据，并能支持广泛的和日益增长的应用 &ensp;&ensp;分类： &ensp;&ensp;广域网WAN、城域网MAN、局域网LAN、个人区域网PAN &ensp;&ensp;公用网、专用网 &ensp;&ensp;接入网 1.6 计算机网络的性能&ensp;&ensp;速率：数据的传送速率；往往指额定速率或标称速率，而不是实际速率 &ensp;&ensp;带宽：表示网络某通道传送数据的能力，即单位时间内网络中某信道能通过的最高数据率 &ensp;&ensp;吞吐量：单位时间内通过某个网络(信道、接口)的实际数据量 &ensp;&ensp;时延：数据从网络的一端到另一端所需的时间 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;发送时延 = $\frac{数据帧长度(bit)}{发送速率(bit/s)}$ &ensp;&ensp;网卡$\Rightarrow $网线 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;传播时延 = $\frac{信道长度(m)}{传播速率(m/s)}$ &ensp;&ensp;时延带宽积：以比特为单位的链路长度&ensp;&ensp; 时延带宽积 = 传播时延 * 带宽 &ensp;&ensp;往返时间RTT：双向交互一次所需的时间 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;有效数据率 = $\frac{数据长度}{发送时间+RTT}$ &ensp;&ensp;利用率：指某信道有百分之几的时间是被利用的 &ensp;&ensp;网络利用率：全网络的信道利用率的加权平均数 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;D(网络当前时延) = $\frac{D_0(网络空闲时延 )}{1-U(利用率)}$&ensp;&ensp;&ensp;&ensp;信道或网络利用率过高会产生非常大的时延 1.7 计算机网络体系结构&ensp;&ensp;网络协议(协议)：为进行网络中的数据交换而建立的规则、标准或约定 &ensp;&ensp;网络协议的三要素： &ensp;&ensp;&ensp;&ensp; ①语法：数据与控制信息的结构或格式 ​ &ensp;&ensp;&ensp;&ensp;②语义：需要发出何种控制信息，完成何种动作以及做出何种响应 &ensp;&ensp;&ensp;&ensp; ③同步：事件实现顺序的详细说明 &ensp;&ensp;计算机网络体系结构：计算机网络各层及其协议的集合 &ensp;&ensp;数据在各层之间的传递过程： &ensp;&ensp; 第2章 物理层2.1 物理层的基本概念&ensp;&ensp;物理层功能：怎样在连接各种计算机的传输媒体上传输数据比特流，屏蔽不同传输媒体和通信手段的差异 &ensp;&ensp;规程：用于物理层的协议 &ensp;&ensp;特性：机械特性(接线器规格等)、电气特性(各条线电压范围)、功能特性(某一电平电压意义)、过程特性(不同功能各种可能事件的出现顺序) 2.2 数据通信的基础知识&ensp;&ensp;消息：通信的目的是传送消息，如语音、文字、图像、视频等 &ensp;&ensp;数据：是运送消息的实体 &ensp;&ensp;信号：数据的电气或电磁表现 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;模拟信号(连续信号)：代表消息的参数取值是连续的 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;数字信号(离散信号)：代表消息的参数的取值是离散的；代表不同离散的基本波形就是码元（并不是越多越好） &ensp;&ensp;信道分类：单向通信(单工通信)、双向交替通信(半双工通信)、双向同时通信(全双工通信) &ensp;&ensp;基带信号：来自信源的信号（计算机中输出的各种文字或图像数据信号都属于） &ensp;&ensp;调制分类： &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;基带调制(编码)：数字信号 -&gt; 数值信号，常用方式有不归零制、归零制、曼切斯特编码和差分曼切斯特编码 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;带通调制：使用载波将数字信号 -&gt; 模拟信号(带通信号)；常用方式有调幅、调频和调相 &ensp;&ensp;奈氏准则：在任何信道中，码元传输的速率有上限，传输速率超过此上限，就会出现严重码间串扰问题，使接收端判决(识别)不可能 &ensp;&ensp;信噪比：信号的平均功率和噪声平均功率之比 $= 10log_{10}(S/N) &ensp;(dB)$ &ensp;&ensp;香农公式：信道极限传输速率 $C = W log_2(1+S/N) &ensp;(bits/s)$ &ensp;表明W信道带宽或信噪比越高，极限传输速率越高 2.3 物理层下面的传输介质&ensp;&ensp;导引型传输媒体：双绞线、同轴电缆、光缆 &ensp;&ensp;非导引型传输媒体：短波通信（靠电离层反射）、无线电微波通信（地面微波接力通信和卫星通信） 2.4 信道复用技术&ensp;&ensp;频分多用FDM：所有用户在同样的时间占用不同的频率带宽 &ensp;&ensp;时分复用TDM：所有用户在不同的时间占用同样的频带宽度 (同步) &ensp;&ensp;统计时分复用STDM：集中STDM帧按需动态分配时隙 (异步) &ensp;&ensp;波分复用WDM：光的频分复用 &ensp;&ensp;码分复用CDM(码分多址CDMA)：各个用户使用进过特殊挑选的不同码型，因此彼此不会互相干扰 时分多址（TDMA）：甲与乙先讲一句，再换丙与丁讲一句，再换戊与己讲一句，依此类推，大家轮流（分时）讲话彼此就不会互相干扰。频分多址（FDMA）：甲与乙在客厅讲话，丙与丁在书房讲话，戊与己在卧室讲话，大家在不同的房间（分频）讲话彼此就不会互相干扰。码分多址（CDMA）：甲与乙用中文讲话，丙与丁用英文讲话，戊与己用日文讲话，这样虽然大家在同一个房子里讲话，各自仍然可以分辨出各自不同的语言，当甲与乙用中文讲话时，丙与丁的英文以及戊与己的日文只是声音干扰而己，不会造成甲与乙解读中文的困扰；同理，当丙与丁用英文讲话时，甲与乙的中文以及戊与己的日文只是声音干扰而己，不会造成丙与丁解读英文的困扰，在这个例子里「用不同的语言讲话」就好像「用不同的密码加密」一样。 码片：每一个比特时间划分为m个短的间隔 工作方式：每个站被指派一个唯一的m bit码片，若发送1，则发送自己的m bit码片；若发送0，则发送该码片的二进制反码 码片实现扩频：由于一个比特可转换成m个比特的码片，因此实际发送数据率提高了m倍 重要特点：每个站的码片必须各不相同，并相互正交 码片正交关系：不同码片正交，就是向量S和T的规格化内积为0（规格化内积即对应为点乘） 正交关系的重要特征：任何码片与自己的规格化内积为1，与自己反码的规格化内积为-1 2.5 数字传输技术&ensp;&ensp;早期主要缺点：速率标准不统一、不是同步传输 &ensp;&ensp;解决方案：推出同步光纤网SONET，制定国际标准同步数字系列SDH 2.6 宽带接入技术&ensp;&ensp;ADSL技术：非对称数字用户线，将原有的模拟电话线进行改造，使其能够承载宽带业务 &ensp;&ensp;第二代ADSL：得到更高的数据率，采用无缝速率自适应技术，可在运营中不中断通信和不产生误码的情况下，自适应的调整数据率 &ensp;&ensp;光纤同轴混合网(HFC)：是目前覆盖面较广的有线电视网，采用模拟技术，频分复用，主干部分使用光纤，入户部分使用同轴电缆 &ensp;&ensp;FTTx技术：是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式 第3章 数据链路层3.1 使用点对点信道的数据链路层链路(物理链路)：从一个结点到相邻结点的一段物理线路，中间没有任何其他的交换节点 数据链路(逻辑链路)：把实现了这些通信协议的硬件和软件加到链路上，就构成了数据链路(物理线路+协议) 帧：点对点信道数据链路层的协议数据单元 三个基本问题： &ensp;&ensp;①封装成帧 &ensp;&ensp;&ensp;&ensp; 添加首部和尾部的作用：进行帧定界(确定帧的界限)；包含许多必要的控制信息 &ensp;&ensp;②透明传输 &ensp;&ensp;&ensp;&ensp;解决透明传输问题的方法：字节填充 &ensp;&ensp;③差错检测 &ensp;&ensp;&ensp;&ensp;循环冗余校验(CRC) 原理：在发送端，先把数据划分为组，假定每组k个比特，若传输一组数据M=101001(k=6)，在M后添加供差错检测用的n位冗余码后一起发送，共发送(k+n)位，接收方用收到的数据除P，若余数为0则表示没有差错 冗余码计算方法：在M后面添加n个0，得到（k+n）位的数除以选定好的除数p，得出商Q，余数R，将余数R作为冗余码，添加到M后 局限性：只能实现无比特差错，不能实现无传输差错，只能判断收到的数据是否正确，其余均无法判断，并不是可靠传输 3.2 点对点协议PPP&ensp;&ensp;PPP特点：不支持多点线路，只支持点对点的链路通信，只支持全双工链路 &ensp;&ensp;PPP不需要的功能：纠错、流量控制、序号、多点线路、半双工或单工链路（只工作在点对点链路） &ensp;&ensp;PPP帧的格式： &ensp;&ensp; 第4章 网络层 第5章 运输层 第6章 应用层 待更…]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛-41]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-41.html</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/contest/373#question A 翻硬币问题 题意：A和B玩游戏，A先手，要将n个正面硬币翻转为反面且每次只能翻转m个，B有一次可以在A翻转后将一枚硬币翻转的机会，给出n,m问A是否能将所有硬币翻转 思路： 简单签到题，容易想到： ​ 当n&lt;m时，A翻不了 ​ 当n==m时，A可以一下就翻完 ​ 当n&gt;m时，无论A是否刚好翻完，B都可以打乱 代码： 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); if(n==m) puts("Yes"); else puts("No"); &#125; return 0;&#125; B 666RGP 题意：给出n个数(n&lt;=300,-666&lt;=ai&lt;=666)，分数开始初值为0，对于第i个数有两种操作，一是分数+a[i],二是分数*(-1)，问经过n个数后有多少种方法分数变为-666，且中间分数不能出现666，答案对1e8+7取模 思路：简单计数dp 设dp[i] [j]表示，经过第i个数后分数为j的答案，那么有dp[i] [j] = dp[i-1] [j - a[i]] + dp[i-1] [-j] 注意过滤掉j==666的情况 因为j最大会有2*300*666 这么大，如果开dp[300] [2*300*666] 肯定空间不够 考虑转移方程只和i 和 i-1有关，可以用滚动数组形式优化 代码： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxv = 700*300;const int P = 1e8+7;int dp[2][maxv*2];int a[305]; int main() &#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); dp[0][maxv]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=-666*n;j&lt;=666*n;j++)&#123; if(j==666) continue; dp[i&amp;1][j+maxv]=(dp[(i-1)&amp;1][-j+maxv]+dp[(i-1)&amp;1][j-a[i]+maxv])%P; &#125; &#125; printf("%d\n",dp[n&amp;1][-666+maxv]); return 0;&#125; C 抓捕盗窃犯 题意：在n点中，第i个点有ai个人，再给出下一时刻第i个点的所有人转移到vi点，问在m个地方建立哨卡（可以一直监控当地经过的人），最多可以监视到多少人 思路： n个点，每个点有一条有向出边 容易想到这些点将组成一些块 且每个块内都有一个环 这样，一个块的所有地点的人都会经过环 那么用并查集整合n个地点人口，再取前m大就行 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;int f[maxn];ll a[maxn],b[maxn]; int get(int x)&#123; return f[x]==x?x:f[x]=get(f[x]);&#125; int main() &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; f[i]=i; scanf("%lld",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; int to; scanf("%d",&amp;to); int x=get(i),y=get(to); if(x!=y)&#123; f[x]=y; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; int f=get(i); b[f]+=a[i]; &#125; sort(b+1,b+1+n); ll ans=0; for(int i=n;i&gt;n-m;i--)&#123; ans+=b[i]; &#125; printf("%lld\n",ans); return 0;&#125; D 最小相似度 题意：给出n个m长的二进制01串，问构造一个m长的01串使得这个串和这n个串对应位相同的数量最大的最小值 思路：将n个串都作为起点进行bfs，搜索完所有2^m内的数，dp[i]表示从某个起点到i需要翻转的位数，既有多少位与原先某个串不相同，m-max(dp[i]) 即为最小相同的位数 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn =3e5+5;int n,m;int dp[1&lt;&lt;20]; void bfs()&#123; queue&lt;int&gt;q; char s[25]; memset(dp,-1,sizeof(int)*((1&lt;&lt;m)+5)); for(int i=0;i&lt;n;i++)&#123; scanf("%s",s); int tmp=0; for(int j=0;j&lt;m;j++)&#123; tmp+=(1&lt;&lt;j)*(s[j]-'0'); &#125; dp[tmp]=0; q.push(tmp); &#125; while(!q.empty())&#123; int u=q.front(); q.pop(); for(int j=0;j&lt;m;j++)&#123; if(dp[u^(1&lt;&lt;j)]!=-1) continue; dp[u^(1&lt;&lt;j)]=dp[u]+1; q.push(u^(1&lt;&lt;j)); &#125; &#125;&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;m); bfs(); int ans=-1; for(int i=0;i&lt;(1&lt;&lt;m);i++) ans=max(ans,dp[i]); printf("%d\n",m-ans);&#125; E 球的体积并 题意：给出两个球的球心坐标和半径，求两球相交体积 思路：球冠体积公式(h为球冠高，r为球半径,d为球心距) V=PI*h(3a^2+h^2)/6=PI*h^2(3r-h)/3 h=r-(ra^2-rb^2+d^2)/2d注意外离、外切、内含的几种情况需特判 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const double PI = acos(-1);typedef struct point &#123; double x,y,z; point() &#123; &#125; point(double a, double b,double c) &#123; x = a; y = b; z = c; &#125; point operator -(const point &amp;b)const &#123; //返回减去后的新点 return point(x - b.x, y - b.y,z-b.z); &#125; point operator +(const point &amp;b)const &#123; //返回加上后的新点 return point(x + b.x, y + b.y,z+b.z); &#125; point operator *(const double &amp;k)const &#123; //返回相乘后的新点 return point(x * k, y * k,z*k); &#125; point operator /(const double &amp;k)const &#123; //返回相除后的新点 return point(x / k, y / k,z/k); &#125; double operator *(const point &amp;b)const &#123; //点乘 return x*b.x + y*b.y+z*b.z; &#125;&#125; point;double dist(point p1, point p2) &#123; //返回平面上两点距离 return sqrt((p1 - p2)*(p1 - p2));&#125;typedef struct sphere &#123;//球 double r; point centre; double v()&#123; return 4.0/3*PI*r*r*r; &#125;&#125; sphere;void Solve(sphere a, sphere b) &#123; double d = dist(a.centre, b.centre);//球心距 //double t = (d*d + a.r*a.r - b.r*b.r) / (2.0 * d);// //double h = sqrt((a.r*a.r) - (t*t)) * 2;//h1=h2，球冠的高 //double angle_a = 2 * acos((a.r*a.r + d*d - b.r*b.r) / (2.0 * a.r*d)); //余弦公式计算r1对应圆心角，弧度 //double angle_b = 2 * acos((b.r*b.r + d*d - a.r*a.r) / (2.0 * b.r*d)); //余弦公式计算r2对应圆心角，弧度 if(d-a.r-b.r&gt;=0)&#123; printf("%.10f\n",a.v()+b.v()); return; &#125; if(d+a.r&lt;b.r||d+b.r&lt;a.r)&#123; printf("%.10f\n",max(a.v(),b.v())); return; &#125; double l1 = (a.r*a.r - b.r*b.r + d*d) / (2*d); double l2 = (b.r*b.r - a.r*a.r + d*d) / (2*d); double h1 = a.r - l1, h2 = b.r - l2;//分别为两个球缺的高度 double v1 = PI*h1*h1*(a.r - h1 / 3);//相交部分r1圆所对应的球缺部分体积 double v2 = PI*h2*h2*(b.r - h2 / 3);//相交部分r2圆所对应的球缺部分体积 double v = v1 + v2;//相交部分体积 printf("%.10f\n",a.v()+b.v()-v); //double s1 = PI*a.r*x1; //r1对应球冠表面积 //double s2 = PI*a.r*x2; //r2对应球冠表面积 //double s = 4 * PI*(a.r*a.r + b.r*b.r) - s1 - s2;//剩余部分表面积&#125; int main() &#123; sphere a,b; scanf("%lf%lf%lf%lf",&amp;a.centre.x,&amp;a.centre.y,&amp;a.centre.z,&amp;a.r); scanf("%lf%lf%lf%lf",&amp;b.centre.x,&amp;b.centre.y,&amp;b.centre.z,&amp;b.r); Solve(a,b); return 0;&#125; F 简单数学题 数学弃… 岑巨出的题，难度适中，B题dp因为没注意要从dp[0] [maxv]开始初始化debug了很久 C题想到了并查集竟然不想写 E题内含的条件写错了，一直以为公式错了QAQ 还是大意了啊]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>bfs</tag>
        <tag>dp</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客OI周赛7-普及组]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2OI%E5%91%A8%E8%B5%9B7-%E6%99%AE%E5%8F%8A%E7%BB%84.html</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/contest/372#question A 救救猫咪 暴力 B 救救兔子 题意：给出n长数组，m个询问，每次询问给出一个x，要求数组中与x差距最小的数(如果差距相等，输出较小的那个) 思路： 二分，原数组排序后用upper_lowbound() 找出第一个比x大元素的位置，在分别比较当前位置和当前位置-1的数与x的差距，注意比第一个数小和最后一个数大的时候需特判 代码： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;int a[maxn]; int main()&#123; int n,q,x; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); sort(a,a+n); scanf("%d",&amp;q); while(q--)&#123; scanf("%d",&amp;x); if(x&gt;=a[n-1]) printf("%d\n",a[n-1]); else if(x&lt;=a[0]) printf("%d\n",a[0]); else&#123; int pos=upper_bound(a,a+n,x)-a; if(abs(a[pos-1]-x) &lt;= abs(a[pos]-x)) printf("%d\n",a[pos-1]); else printf("%d\n",a[pos]); &#125; &#125;&#125; C 救救企鹅 题意: 给出字符串s,a,b(长度&lt;=1e6),要求输出将s中所有a替换为b后的字符串 思路: kmp或hash求出s中与a匹配的位置,再替换一下即可 比赛的时候没有注意到a,b串的长度可以不相等 只过了50%qwq 赛后发现用Java或Python都可以直接秒这题tql 代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int maxn = 1e6+5;char s[maxn],a[maxn],b[maxn];int lens,lena,lenb;ull base=131;ull p[maxn],hs[maxn];ull geth(int l,int r)&#123; return (ull)hs[r]-hs[l-1]*p[r-l+1];&#125; vector&lt;int&gt;pos;int main()&#123; p[0]=1; for(int i=1;i&lt;maxn;i++) p[i]=p[i-1]*base; scanf("%s%s%s",s+1,a+1,b+1); lens=strlen(s+1); lena=lenb=strlen(a+1); ull tt=0; for(int i=1;i&lt;=lena;i++) tt=tt*base+(ull)a[i]; for(int i=1;i&lt;=lens;i++) hs[i]=hs[i-1]*base+(ull)s[i]; for(int i=1;i&lt;=lens-lena+1;i++)&#123; ull ss=geth(i,i+lena-1); if(ss==tt)&#123; pos.push_back(i); i+=lena-1; &#125; &#125; int k=1; for(int i=0;i&lt;pos.size();i++)&#123; while(k!=pos[i])&#123; putchar(s[k]); k++; &#125; printf("%s",b+1); k+=lena; &#125; while(k&lt;=lens)&#123; putchar(s[k]); k++; &#125; puts("");&#125; D 数糖纸 题意: 给出长度为n的数组(maxn=1e6),要求不含相同元素的最长连续区间长度 思路: 双指针(l,r)移动表示[l,r]内没有重复的元素,用个set记录当前区间已经出现了的数,如果枚举到一个没有出现的数,则加入set,++r,否则一直删除左端已经出现过的元素直到重复元素被删除 上面可以稍微优化一下,因为 Ai 最大1e9,我们先将原数组离散化,再用一个vis[] 记录Ai 是否出现过 代码1: 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;int a[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int ans=-1,l=1,r=1; set&lt;int&gt;s; while(r&lt;=n)&#123; if(s.find(a[r])==s.end())&#123; s.insert(a[r]); ans=max(ans,r-l+1); r++; &#125; else&#123; s.erase(a[l]); l++; &#125; &#125; printf("%d\n",ans);&#125; 代码2: 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;int a[maxn],b[maxn],pre[maxn],vis[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); b[i]=a[i]; &#125; sort(b+1,b+1+n); int m=unique(b+1,b+1+n)-b-1; for(int i=1;i&lt;=n;i++)&#123; a[i]=lower_bound(b+1,b+1+n,a[i])-b-1; &#125; int ans=-1,l=1; for(int i=1;i&lt;=n;i++)&#123; if(!vis[a[i]])&#123; vis[a[i]]=1; &#125; else&#123; while(a[l]!=a[i])&#123; vis[a[l]]=0; l++; &#125; l++; vis[a[i]]=1; &#125; ans=max(ans,i-l+1); &#125; printf("%d\n",ans);&#125; 一场比较简单的比赛,一点小粗心kmp就挂了 第一次在高铁上写博客,刺激~]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>字符串hash</tag>
        <tag>暴力</tag>
        <tag>kmp</tag>
        <tag>STL</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EOJ Monthly 2019.2]]></title>
    <url>%2FEOJ-Monthly-2019-2.html</url>
    <content type="text"><![CDATA[原题链接：https://acm.ecnu.edu.cn/contest/140/ A,B,C,E To be continue… D 进制转换 题意：求[l,r]中所有数的k进制末尾恰好有m个零的数有多少个 思路： x在k进制下末尾恰好有m个零说明x%(k^m)恒等于0，而x%(k^(m+1))不恒等于0，而x%(k^m)==0的情况包含了x%(k^(m+1))==0的情况，所以由容斥定理有[1,x]中满足题意的数有 x/(k^m) - x/(k^(m+1)) 个 代码： 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;ll calc(ll k,ll m,ll x)&#123; for(int i=1;i&lt;=m;i++)&#123; x/=k; &#125; return x;&#125;int main()&#123; ll l,r,k,m; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%lld%lld%lld%lld",&amp;l,&amp;r,&amp;k,&amp;m); printf("%lld\n",calc(k,m,r)-calc(k,m+1,r)-calc(k,m,l-1)+calc(k,m+1,l-1)); &#125;&#125; F 方差 题意： 在n个数中选m个数，使得这m个数的方差*(m^2)最小 思路： 首先想到要使方差越小，则要这m个数与平均数的差距越小，所以我们可以先排序再尺取m长; 不难发现将方差公式乘以m^2后可以化简得到 m(a_1^2+a_2^2+⋯+a_m^2) − (a_1+a_2+⋯+a_m)^2（MathJax真好用，小声哔哔 然后维护一个前缀和与一个前缀平方和即可 代码： 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;int a[maxn];ll sum1[maxn],sum2[maxn];int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; sort(a+1,a+1+n); for(int i=1;i&lt;=n;i++)&#123; sum1[i]=sum1[i-1]+a[i]; sum2[i]=sum2[i-1]+a[i]*a[i]; &#125; ll ans=-1; for(int i=m;i&lt;=n;i++)&#123; ll tmp=m*(sum2[i]-sum2[i-m])-(sum1[i]-sum1[i-m])*(sum1[i]-sum1[i-m]); if(ans==-1||ans&gt;tmp) ans=tmp; &#125; printf("%lld\n",ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客OI周赛7-提高组]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2OI%E5%91%A8%E8%B5%9B7-%E6%8F%90%E9%AB%98%E7%BB%84.html</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/contest/371#question A 小睿睿的等式 题意：有n根火柴棒，能摆成形如“A+B=n”的等式且使用的火柴棒数也恰好等于n/k的等式有多少种(B+A=n与A+B=n看作一种,“=”与“+”分别需要使用2根火柴棒,maxn=5e7) 思路：直接暴力拆分每组A+B写的挫会超时，比赛时没注意给出的空间很大(512MB)，先将所有5e7以内数所需火柴数打表即可 代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =5e7+5;int num[maxn];int main() &#123; num[0]=6; num[1]=2; num[2]=5; num[3]=5; num[4]=4; num[5]=5; num[6]=6; num[7]=3; num[8]=7; num[9]=6; int n; int k; scanf("%d%d",&amp;n,&amp;k); for(int i=10;i&lt;=n;i++)&#123; num[i]=num[i/10]+num[i%10]; &#125; int kk=n/k; int ans=0,x,y,z=num[n]; for(int a=0; a&lt;=n/2; a++) &#123; int b=n-a; x=num[a]; y=num[b]; if(x+y+z+4==kk) ans++; &#125; printf("%d\n",ans); return 0;&#125; B 小睿睿的询问 题意：给出随机生成一个n长数组的函数和生成区间查询L，R的函数，要求所有L，R区间生成数组中val[i]最大且较小下标异或值（maxn=1e5，maxm=5e7) 思路：最开始写的线段树（O(mlogn)），因为是随机数据没想到过了时间是全场最久的(4632/5000 ms),后来知道可以用ST表写，但自己写的挫，加了个二分查对应下标也用了2900+ms(O(nlognlogn))，再后来可以在ST表处直接用个pair，val[i]和i对应,每次查询O(1)，总体复杂度O(nlogn+m) 代码： 线段树版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =1e5+5;int n,m;int val[maxn],Max[maxn&lt;&lt;2],idx[maxn&lt;&lt;2]; void push_up(int l,int r,int o)&#123; Max[o]=max(Max[o&lt;&lt;1],Max[o&lt;&lt;1|1]); if(Max[o&lt;&lt;1] &gt;= Max[o&lt;&lt;1|1]) idx[o]=idx[o&lt;&lt;1]; else idx[o]=idx[o&lt;&lt;1|1];&#125; void build(int l,int r,int o)&#123; if(l==r)&#123; Max[o]=val[l]; idx[o]=l; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(l,r,o);&#125; int query(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return idx[o]; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid&amp;&amp;R&gt;mid)&#123; int i=query(L,R,lson); int j=query(L,R,rson); if(val[i]&gt;=val[j]) return i; else return j; &#125; else if(L&lt;=mid)&#123; return query(L,R,lson); &#125; else if(R&gt;mid)&#123; return query(L,R,rson); &#125; return 0;&#125; void generate_array(int n,int seed) &#123; unsigned x = seed; for (int i=1; i&lt;=n; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; val[i]=x%100; &#125;&#125; int lastans=0,ans=0;void generate_ask(int n,int m,int seedx,int seedy) &#123; unsigned x=seedx,y=seedy; for (int i=1; i&lt;=m; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; y ^= y &lt;&lt; 13; y ^= y &gt;&gt; 17; y ^= y &lt;&lt; 5; int L=(x^lastans)%n+1,R=(y^lastans)%n+1; if (L&gt;R) swap(L,R); lastans=query(L,R,1,n,1); ans^=lastans; &#125; printf("%d\n",ans);&#125; int main() &#123; int seed,seedx,seedy; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;seed,&amp;seedx,&amp;seedy); //double ss=clock(); generate_array(n,seed); build(1,n,1); generate_ask(n,m,seedx,seedy); //printf("%.0fms\n",clock()-ss); return 0;&#125; 二分+ST版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =1e5+5;int n,m;int val[maxn];vector&lt;int&gt;idx[105];int f[maxn][20];void ST_pre()&#123; for(int i=1;i&lt;=n;i++)&#123; f[i][0]=val[i]; &#125; int t=log(n)/log(2)+1; for(int j=1;j&lt;t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]); &#125; &#125;&#125;int ST_query(int l,int r)&#123; int k=log(r-l+1)/log(2); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125; void generate_array(int n,int seed) &#123; unsigned x = seed; for (int i=1; i&lt;=n; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; val[i]=x%100; idx[val[i]].push_back(i); &#125;&#125; int lastans=0,ans=0;void generate_ask(int n,int m,int seedx,int seedy) &#123; unsigned x=seedx,y=seedy; for (int i=1; i&lt;=m; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; y ^= y &lt;&lt; 13; y ^= y &gt;&gt; 17; y ^= y &lt;&lt; 5; int L=(x^lastans)%n+1,R=(y^lastans)%n+1; if (L&gt;R) swap(L,R); int pos,Max=ST_query(L,R); int s=lower_bound(idx[Max].begin(),idx[Max].end(),L)-idx[Max].begin(); for(int k=s;k&lt;=idx[Max].size();k++)&#123; if(idx[Max][k]&gt;=L&amp;&amp;idx[Max][k]&lt;=R)&#123; pos=idx[Max][k]; break; &#125; &#125; lastans=pos; ans^=lastans; &#125; printf("%d\n",ans);&#125; int main() &#123; int seed,seedx,seedy; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;seed,&amp;seedx,&amp;seedy); //double ss=clock(); generate_array(n,seed); ST_pre(); generate_ask(n,m,seedx,seedy); //printf("%.0fms\n",clock()-ss); return 0;&#125; 优化ST版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =1e5+5;int n,m;int val[maxn];pair&lt;int,int&gt; f[maxn][20]; void ST_pre()&#123; for(int i=1;i&lt;=n;i++)&#123; f[i][0].first=i; f[i][0].second=val[i]; &#125; int t=log(n)/log(2)+1; for(int j=1;j&lt;t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; //f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]); f[i][j] = f[i][j-1].second &gt;= f[i+(1&lt;&lt;j-1)][j-1].second ? f[i][j-1]:f[i+(1&lt;&lt;j-1)][j-1]; &#125; &#125;&#125;int ST_query(int l,int r)&#123; int k=log(r-l+1)/log(2); return f[l][k].second &gt;= f[r-(1&lt;&lt;k)+1][k].second ? f[l][k].first : f[r-(1&lt;&lt;k)+1][k].first;&#125; void generate_array(int n,int seed) &#123; unsigned x = seed; for (int i=1; i&lt;=n; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; val[i]=x%100; &#125;&#125; int lastans=0,ans=0;void generate_ask(int n,int m,int seedx,int seedy) &#123; unsigned x=seedx,y=seedy; for (int i=1; i&lt;=m; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; y ^= y &lt;&lt; 13; y ^= y &gt;&gt; 17; y ^= y &lt;&lt; 5; int L=(x^lastans)%n+1,R=(y^lastans)%n+1; if (L&gt;R) swap(L,R); int pos=ST_query(L,R); lastans=pos; ans^=lastans; &#125; printf("%d\n",ans);&#125; int main() &#123; int seed,seedx,seedy; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;seed,&amp;seedx,&amp;seedy); //double ss=clock(); generate_array(n,seed); ST_pre(); generate_ask(n,m,seedx,seedy); //printf("%.0fms\n",clock()-ss); return 0;&#125; C 小睿睿的方案 To be continue… 这场Rating赛打得还是还算比较开心吧，学了一下ST表空间复杂度O(nlogn),区间查询O(1)很不错的算法，程序运算时间的计算和数组所占大概空间的计算，虽然理论课学了但一直没去实践QWQ另外牛客题目还不错~不说了EOJ的题还没补呢！]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>ST</tag>
        <tag>线段树</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛 40A--小D的剧场]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-40A--%E5%B0%8FD%E7%9A%84%E5%89%A7%E5%9C%BA.html</url>
    <content type="text"><![CDATA[题意： 给出自然数1-49的49个数要求拼接成长度为n的序列，且要求任意相邻的三个不能为给出q个条件中任意一个条件的全排列，求所有合法序列数对 1e9+7 取模。 原题链接：https://ac.nowcoder.com/acm/contest/369/A Input: 123456789101110 10 //n q18 3 343 28 2242 28 348 48 429 9 3147 9 221 22 4915 48 292 8 274 24 34 Output: 1382785822 思路： 设dp[i] [j] [k]为放到第i位时，a[i-1]=j, a[i]==k的状态，提前将不合法字段标记，转移方程： dp_{i,k,l} = \sum_{i=1}^{49} (!ban_{j,k,l})*dp_{i-1,j,k}表示j,k,l可行时，可在 a[i-2]==j,a[i-1]==k的状态转移到 a[i-1]==k,a[i]==l的状态。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int P = 1e9+7;int dp[505][50][50];bool ban[50][50][50];int main()&#123; int n,q; scanf("%d%d",&amp;n,&amp;q); while(q--)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ban[a][b][c]=ban[a][c][b]=true; ban[b][a][c]=ban[b][c][a]=true; ban[c][a][b]=ban[c][b][a]=true; &#125; for(int i=1;i&lt;=49;i++)&#123; for(int j=1;j&lt;=49;j++)&#123; dp[2][i][j]=1; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=49;j++)&#123; for(int k=1;k&lt;=49;k++)&#123; for(int l=1;l&lt;=49;l++)&#123; if(!ban[j][k][l])&#123; dp[i][k][l]=(dp[i][k][l]+dp[i-1][j][k])%P; &#125; &#125; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=49;i++)&#123; for(int j=1;j&lt;=49;j++)&#123; ans=(ans+dp[n][i][j])%P; &#125; &#125; printf("%d\n",ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛 40C--小A与欧拉路]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-40C--%E5%B0%8FA%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%B7%AF.html</url>
    <content type="text"><![CDATA[题意： 小A给你了一棵树，对于这棵树上的每一条边，你都可以将它复制任意（可以为0）次（即在这条边连接的两个点之间再加一条边权相同的边），求所有可能新形成的图中欧拉路的最短长度 欧拉路：从图中任意一个点开始到图中任意一个点结束的路径，并且图中每条边只通过恰好一次。 原题链接：https://ac.nowcoder.com/acm/contest/369/C Input： 12344 //n 树的点数1 2 1 //u v w1 3 11 4 2 Output： 15 思路： 先考虑回路的情况。由于是一棵树，任两点间路径只有一条，从一条边走到深度更大的点，一定还会从同一条边返回以回到起点或者遍历其他子树，所以每条边需要复制一次，此时答案是边权和的两倍。 不是回路的情况可以减掉从终点回到起点的路径，要让这条路径尽量长，所以长度一定是直径的长度。 答案就是边权和的两倍减去直径长度。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2e5+5;struct EDGE&#123; int next,w,to;&#125;edge[maxn*2];int head[maxn];int cnt; void add(int u,int v,int w)&#123; edge[++cnt].next=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125; int pos,ans;int d[maxn];void dfs(int x,int pre)&#123; for(int i=head[x];i;i=edge[i].next)&#123; int to=edge[i].to; if(to==pre) continue; d[to]=d[x]+edge[i].w; dfs(to,x); &#125; if(d[x]&gt;ans)&#123; ans=d[x]; pos=x; &#125;&#125; int main()&#123; int n; scanf("%d",&amp;n); ll sum=0; for(int i=0;i&lt;n-1;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); sum+=2*w; &#125; dfs(1,-1); memset(d,0,sizeof(d)); dfs(pos,-1); printf("%lld\n",sum-ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>欧拉路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSU 1803--2016]]></title>
    <url>%2FCSU%201803--2016.html</url>
    <content type="text"><![CDATA[题意： 求[l,r]之间有多少种a*b=2016的组合。 思路： 首先2016的1倍情况下有1*2016 , 2*1008 , 3*637… 等情况，2倍情况就是把a或b扩大2倍就行，那么我们可以把a看做[1,2016]的数，a’ 看做[2017,4032]的数，这样每次跨2016个数就知道有多少倍数了。最后两层for循环找出i*j==2016的时候把对应的倍数种类乘起来加到答案就行了。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; int main()&#123; ll n,m; ll a[3000],b[3000]; //a[i]储存n有多少个i*2016&lt;=n，b[i]....m while(~scanf("%lld%lld",&amp;n,&amp;m)) &#123; ll k=n/2016; //有k个2016跨度 ll mm=n%2016; //余下的等下都要+1 for(int i=1;i&lt;=mm;i++) a[i]=k+1; for(int i=mm+1;i&lt;=2016;i++) a[i]=k; k=m/2016; mm=m%2016; for(int i=1;i&lt;=mm;i++) b[i]=k+1; for(int i=mm+1;i&lt;=2016;i++) b[i]=k; ll ans=0; for(int i=1;i&lt;=2016;i++) &#123; for(int j=1;j&lt;=2016;j++) &#123; if((i*j)%2016==0) &#123; ans+=(a[i]*b[j]); &#125; &#125; &#125; printf("%lld\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 4011--Happy-Sequence]]></title>
    <url>%2FZOJ%204011--Happy-Sequence.html</url>
    <content type="text"><![CDATA[题意： 给一个n和m，求所有组成m长且值在1-n内且满足 a[i]%a[i-1]==0 的序列方案数。 思路： dp[i] [j] 表示长度为 i 的序列的最后一位为 j ,转移方程：dp[i] [j]=0 , dp[i] [j]+=dp[i-1] [ j的因子 ] 。因子可以通过埃氏筛打表得到，dp[m] [i]累加和即为答案，预处理2000*2000以内所有答案即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std; #define N 2005#define mod 1000000007int dp[N][N];vector&lt;int&gt;y[N]; //储存因子int main()&#123; for(int i=1; i&lt;=N; i++) &#123; for(int j=i; j&lt;=N; j+=i) &#123; y[j].push_back(i); &#125; &#125; for(int i=1; i&lt;=N; i++) dp[1][i]=1; for(int i=2; i&lt;=N; i++) &#123; for(int j=1; j&lt;=N; j++) &#123; for(int k=0; k&lt;y[j].size(); k++) &#123; dp[i][j]=(dp[i][j]+dp[i-1][y[j][k]])%mod; &#125; &#125; &#125; int t; scanf("%d",&amp;t); while(t--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); int ans=0; for(int i=1; i&lt;=n; i++) ans=(ans+dp[m][i])%mod; printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 2594--Driving-Straight]]></title>
    <url>%2FZOJ%202594--Driving-Straight.html</url>
    <content type="text"><![CDATA[题意： 给出一个(2*m-1)*(2*n-1)的图，要求输出从左下角走到右上角最短距离走法的路径，只能在 ‘-’ 或 ‘|’ 上移动，答案保证有解，有多解输出任一，n,m&lt;=400。 思路： 因为题目要求输出路径，而bfs中如果每个状态都记录到当前状态的路径，可能会TLE或者MLE。 所以考虑先从终点开始bfs出每个点到终点的最短距离，然后再从起点出发bfs一直找 当前点的最短距离-1==下一步的最短距离 的位置就可以回到终点，注意方向的变换。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;using namespace std;char mp[1005][1005];int dis[1005][1005];int m,n;int dx[10]=&#123;-1,0,1,0&#125;; //反向由北到西顺时针 依次为0123int dy[10]=&#123;0,1,0,-1&#125;;int dd[10][10] = &#123;&#123;0, 1, 2, 3&#125;, // F&#123;3, 0, 1, 2&#125;, // L&#123;1, 2, 3, 0&#125; // R&#125;;char dir[10]=&#123;'F','L','R'&#125;; struct node&#123; int x,y; node()&#123;&#125; node(int x,int y):x(x),y(y)&#123;&#125;&#125;; void bfs()&#123; queue&lt;node&gt;q; memset(dis,-1,sizeof(dis)); dis[1][2*n-1]=0; q.push(node(1,2*n-1)); node now; int x,y,px,py; while(!q.empty()) &#123; now=q.front(); q.pop(); px=now.x,py=now.y; //printf("%d %d\n",px,py); for(int i=0;i&lt;4;i++) &#123; x=px+dx[i]; y=py+dy[i]; if(mp[x][y]=='-' || mp[x][y]=='|') &#123; x+=dx[i]; y+=dy[i]; if(dis[x][y]==-1) &#123; dis[x][y]=dis[px][py]+1; q.push(node(x,y)); &#125; &#125; &#125; &#125;&#125; void print()&#123; int statu,x,y,px,py; if(mp[2*m-1][2]=='-' &amp;&amp; dis[2*m-1][1]-1==dis[2*m-1][3]) &#123; puts("E"); px=2*m-1,py=3; statu=1; &#125; else if(mp[2*m-2][1]=='|' &amp;&amp; dis[2*m-1][1]-1==dis[2*m-3][1]) &#123; puts("N"); px=2*m-3,py=1; statu=0; &#125; while(1) &#123; if(dis[px][py]==0) &#123; puts(""); break; &#125; for(int i=0;i&lt;3;i++) &#123; x=px+dx[dd[i][statu]]; y=py+dy[dd[i][statu]]; if(mp[x][y]=='-' || mp[x][y]=='|') &#123; x+=dx[dd[i][statu]]; y+=dy[dd[i][statu]]; if(dis[x][y]==dis[px][py]-1) &#123; printf("%c",dir[i]); statu=dd[i][statu]; px=x,py=y; break; &#125; &#125; &#125; &#125;&#125; int main()&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;m,&amp;n); memset(mp,' ',sizeof(mp)); getchar(); for(int i=1; i&lt;=2*m-1; i++) &#123; gets(mp[i]+1); &#125; bfs(); /*for(int i=1;i&lt;=2*m-1;i+=2) &#123; for(int j=1;j&lt;=2*n-1;j+=2) &#123; printf("%3d",dis[i][j]); &#125;puts(""); &#125;*/ print(); if(T) puts(""); &#125;&#125; /*24 4+-+-+-+|+-+-+-+ |+-+-+-+|+-+-+-+NRFFLLFFRRFF4 4+-+ +-+| | |+ +-+-+| | |+-+-+-+| |+-+-+-+EFFLFF*/]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 110D--Lucky Probability]]></title>
    <url>%2FCodeforces%20110D--Lucky%20Probability.html</url>
    <content type="text"><![CDATA[题意： 出个两个（P,V）范围在1e9的正整数区间，分别从其中随机选出一个数，选出的两个数作为一个新区间的左右端点。要求新区间内的幸运数刚好为k个的概率（幸运数指一个数的数位只有4或7）。 思路： 首先可以dfs找出所有在数据范围内的幸运数，记为L数组，因为数目不多，便可成k段遍历 L数组，每次分别计算【 L[i-1]+1，L[i]】与【Pl，Pr】的线段交集，和【 L[i+k-1]，L[i+k]-1】与【Vl，Vr】的线段交集，将两个结果相乘即是符合[i,i+k-1]区间幸运数的可能情况，同样的还要对P,V两个区间交换后在计算一遍，概率=所有可能情况/(Pr-Pl+1)/(Vr-Vl+1);然后还要注意k==1的情况会重复计算，需特判。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll L[1050];int num=0;void dfs(int len,int p,int v)&#123; if(p==len) &#123; L[++num]=v; return; &#125; dfs(len,p+1,v*10+4); dfs(len,p+1,v*10+7);&#125; ll contain(ll x1,ll y1,ll x2,ll y2)&#123; ll l=max(x1,x2); ll r=min(y1,y2); return r-l+1&gt;0?r-l+1:0;&#125; int main()&#123; for(int len=1;len&lt;=9;len++) dfs(len,0,0); L[0]=0; L[++num]=1000000000; //for(int i=1;i&lt;=num;i++) printf("%d %lld\n",i,L[i]); ll Pl,Pr,Vl,Vr; int k; scanf("%lld%lld%lld%lld%d",&amp;Pl,&amp;Pr,&amp;Vl,&amp;Vr,&amp;k); ll sum=0; for(int i=1;i&lt;=1022-k+1;i++) &#123; int j=i+k-1; sum+=contain(L[i-1]+1,L[i],Pl,Pr)*contain(L[j],L[j+1]-1,Vl,Vr); if(L[i]&gt;Pr) break; &#125; for(int i=1;i&lt;=1022-k+1;i++) &#123; int j=i+k-1; sum+=contain(L[i-1]+1,L[i],Vl,Vr)*contain(L[j],L[j+1]-1,Pl,Pr); if(L[i]&gt;Vr) break; &#125; if(k==1) &#123; for(int i=1;i&lt;=1022;i++) &#123; if(contain(L[i],L[i],Pl,Pr)&amp;&amp;contain(L[i],L[i],Vl,Vr)) sum--; &#125; &#125; printf("%.10f\n",sum*1.0/(Vr-Vl+1)/(Pr-Pl+1));&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2774--Long Long Message]]></title>
    <url>%2FPOJ%202774--Long%20Long%20Message.html</url>
    <content type="text"><![CDATA[题意：给出两个最长长为1e5的字符串，求他们的最长公共子串长度。 思路： 分别将两个字符串预处理出hash值，二分【1-min（lens，lent）】的长度，check函数中每次将长度为mid的hash值记录并检查是否符合条件，是则下边界右移，否则上边界左移。复杂度O(nlogn) 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int N =100000+5; char s[N],t[N];int lens,lent;ull base=233;ull p[N],hs[N],ht[N];ull geths(int l,int r)&#123; return hs[r]-p[r-l+1]*hs[l-1];&#125;ull getht(int l,int r)&#123; return ht[r]-p[r-l+1]*ht[l-1];&#125; int check(int len)&#123; vector&lt;ull&gt;mp; for(int i=1; i&lt;=lens-len+1; i++) &#123; ull tmp=geths(i,i+len-1); mp.push_back(tmp); &#125; sort(mp.begin(),mp.end()); for(int i=1; i&lt;=lent-len+1; i++) &#123; ull tmp=getht(i,i+len-1); if(binary_search(mp.begin(),mp.end(),tmp)) return 1; &#125; return 0;&#125; int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); p[0]=1; for(int i=1; i&lt;N; i++) p[i]=p[i-1]*base; while(~scanf("%s%s",s+1,t+1)) &#123; lens=strlen(s+1); lent=strlen(t+1); for(int i=1; i&lt;=lens; i++) &#123; hs[i]=hs[i-1]*base+s[i]-'a'; &#125; for(int i=1; i&lt;=lent; i++) &#123; ht[i]=ht[i-1]*base+t[i]-'a'; &#125; int l=1,r=min(lens,lent),mid; while(l&lt;=r) &#123; mid=(l+r)/2; if(check(mid)) l=mid+1; else r=mid-1; &#125; printf("%d\n",r); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>字符串hash</tag>
      </tags>
  </entry>
</search>
