<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[物联网概论 学习笔记]]></title>
    <url>%2F%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%AE%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[物联网（IoT）：Internet of Things 物联网是具有自我标示、感知和智能的物理实体基于通信技术相互连接形成的网络，这些物理设备可以在无需人工干预的条件下实现协同和互动，为人们提供智慧和集约的服务，传感网是物联网的基础，是物联网的组成部分 物联网三层体系结构：感知层、网络层和应用层 感知层是物联网的皮肤和五官——识别物体，采集信息； 网络层是物联网的神经中枢和大脑——信息传递和处理； 应用层是物联网的“社会分工”——与行业需求结合，实现广泛智能化]]></content>
      <categories>
        <category>物联网概论</category>
      </categories>
      <tags>
        <tag>物联网概论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率论与数理统计 学习笔记]]></title>
    <url>%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[[TOC] 第一章 随机事件及其概率第二章 随机变量及其分布第三章 多维随机变量及其分布第四章 随机变量的数字特征第五章 大数定律与中心极限定理第六章 数理统计的基本概念与抽样分析第七章 参数估计第八章 假设验证 待更…]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>概率论与数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络(第7版)-谢希仁 学习笔记]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC7%E7%89%88-%E8%B0%A2%E5%B8%8C%E4%BB%81-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[[TOC] 第1章 概述1.1 计算机网络在信息时代中的作用网络分类：电信网络、有线电视网络和计算机网络 互联网基本特点： ①连通性：互联网用户不管距离多远，都能通信，就像这些用户终端都彼此连通 ②共享：指资源共享，包含信息、软件、硬件等共享，就像资源在用户身边 1.2 互联网概述计算机网络组成：由若干结点和连接这些结点的链路组成；结点可以是计算机、集线器、交换机或路由器等 互连网：网络之间通过路由互连起来，形成更大的网络，是网络的网络 主机(host)：与网络相连的计算机 1.3 互联网的组成从工作方式上分为： (1) 边缘部分：由互联网上的主机组成，是用户直接使用的部分，用来进行通信和资源共享 端系统：主机 计算机之间的通信：主机A上的进程与主机B上的进程进行通信 端系统间通信方式： ①客户-服务器方式 客户和服务器：指通信中涉及的两个应用进程 主要特点：客户是服务请求方（主动发起请求服务，需要知道服务器地址），服务器是服务提供方（可同时处理多个服务请求，需要强大的硬件和高级的操作系统支持） ②对等连接方式 两台主机不区分服务器和客户，只要都运行p2p软件，就可以进行平等对等连接通信，双方都可访问对方硬盘中的共享文档。可支持大量对等用户同时工作 (2) 核心部分：由大量网络和连接这些网络的路由器组成，是为边缘部分提供服务的，提供连通性和交换 第2章 物理层 第3章 数据链路层 第4章 网络层 第5章 运输层 第6章 应用层 待更…]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛-41]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-41.html</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/contest/373#question A 翻硬币问题 题意：A和B玩游戏，A先手，要将n个正面硬币翻转为反面且每次只能翻转m个，B有一次可以在A翻转后将一枚硬币翻转的机会，给出n,m问A是否能将所有硬币翻转 思路： 简单签到题，容易想到： ​ 当n&lt;m时，A翻不了 ​ 当n==m时，A可以一下就翻完 ​ 当n&gt;m时，无论A是否刚好翻完，B都可以打乱 代码： 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); if(n==m) puts("Yes"); else puts("No"); &#125; return 0;&#125; B 666RGP 题意：给出n个数(n&lt;=300,-666&lt;=ai&lt;=666)，分数开始初值为0，对于第i个数有两种操作，一是分数+a[i],二是分数*(-1)，问经过n个数后有多少种方法分数变为-666，且中间分数不能出现666，答案对1e8+7取模 思路：简单计数dp 设dp[i] [j]表示，经过第i个数后分数为j的答案，那么有dp[i] [j] = dp[i-1] [j - a[i]] + dp[i-1] [-j] 注意过滤掉j==666的情况 因为j最大会有2*300*666 这么大，如果开dp[300] [2*300*666] 肯定空间不够 考虑转移方程只和i 和 i-1有关，可以用滚动数组形式优化 代码： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxv = 700*300;const int P = 1e8+7;int dp[2][maxv*2];int a[305]; int main() &#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); dp[0][maxv]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=-666*n;j&lt;=666*n;j++)&#123; if(j==666) continue; dp[i&amp;1][j+maxv]=(dp[(i-1)&amp;1][-j+maxv]+dp[(i-1)&amp;1][j-a[i]+maxv])%P; &#125; &#125; printf("%d\n",dp[n&amp;1][-666+maxv]); return 0;&#125; C 抓捕盗窃犯 题意：在n点中，第i个点有ai个人，再给出下一时刻第i个点的所有人转移到vi点，问在m个地方建立哨卡（可以一直监控当地经过的人），最多可以监视到多少人 思路： n个点，每个点有一条有向出边 容易想到这些点将组成一些块 且每个块内都有一个环 这样，一个块的所有地点的人都会经过环 那么用并查集整合n个地点人口，再取前m大就行 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;int f[maxn];ll a[maxn],b[maxn]; int get(int x)&#123; return f[x]==x?x:f[x]=get(f[x]);&#125; int main() &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; f[i]=i; scanf("%lld",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; int to; scanf("%d",&amp;to); int x=get(i),y=get(to); if(x!=y)&#123; f[x]=y; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; int f=get(i); b[f]+=a[i]; &#125; sort(b+1,b+1+n); ll ans=0; for(int i=n;i&gt;n-m;i--)&#123; ans+=b[i]; &#125; printf("%lld\n",ans); return 0;&#125; D 最小相似度 题意：给出n个m长的二进制01串，问构造一个m长的01串使得这个串和这n个串对应位相同的数量最大的最小值 思路：将n个串都作为起点进行bfs，搜索完所有2^m内的数，dp[i]表示从某个起点到i需要翻转的位数，既有多少位与原先某个串不相同，m-max(dp[i]) 即为最小相同的位数 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn =3e5+5;int n,m;int dp[1&lt;&lt;20]; void bfs()&#123; queue&lt;int&gt;q; char s[25]; memset(dp,-1,sizeof(int)*((1&lt;&lt;m)+5)); for(int i=0;i&lt;n;i++)&#123; scanf("%s",s); int tmp=0; for(int j=0;j&lt;m;j++)&#123; tmp+=(1&lt;&lt;j)*(s[j]-'0'); &#125; dp[tmp]=0; q.push(tmp); &#125; while(!q.empty())&#123; int u=q.front(); q.pop(); for(int j=0;j&lt;m;j++)&#123; if(dp[u^(1&lt;&lt;j)]!=-1) continue; dp[u^(1&lt;&lt;j)]=dp[u]+1; q.push(u^(1&lt;&lt;j)); &#125; &#125;&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;m); bfs(); int ans=-1; for(int i=0;i&lt;(1&lt;&lt;m);i++) ans=max(ans,dp[i]); printf("%d\n",m-ans);&#125; E 球的体积并 题意：给出两个球的球心坐标和半径，求两球相交体积 思路：球冠体积公式(h为球冠高，r为球半径,d为球心距) V=PI*h(3a^2+h^2)/6=PI*h^2(3r-h)/3 h=r-(ra^2-rb^2+d^2)/2d注意外离、外切、内含的几种情况需特判 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const double PI = acos(-1);typedef struct point &#123; double x,y,z; point() &#123; &#125; point(double a, double b,double c) &#123; x = a; y = b; z = c; &#125; point operator -(const point &amp;b)const &#123; //返回减去后的新点 return point(x - b.x, y - b.y,z-b.z); &#125; point operator +(const point &amp;b)const &#123; //返回加上后的新点 return point(x + b.x, y + b.y,z+b.z); &#125; point operator *(const double &amp;k)const &#123; //返回相乘后的新点 return point(x * k, y * k,z*k); &#125; point operator /(const double &amp;k)const &#123; //返回相除后的新点 return point(x / k, y / k,z/k); &#125; double operator *(const point &amp;b)const &#123; //点乘 return x*b.x + y*b.y+z*b.z; &#125;&#125; point;double dist(point p1, point p2) &#123; //返回平面上两点距离 return sqrt((p1 - p2)*(p1 - p2));&#125;typedef struct sphere &#123;//球 double r; point centre; double v()&#123; return 4.0/3*PI*r*r*r; &#125;&#125; sphere;void Solve(sphere a, sphere b) &#123; double d = dist(a.centre, b.centre);//球心距 //double t = (d*d + a.r*a.r - b.r*b.r) / (2.0 * d);// //double h = sqrt((a.r*a.r) - (t*t)) * 2;//h1=h2，球冠的高 //double angle_a = 2 * acos((a.r*a.r + d*d - b.r*b.r) / (2.0 * a.r*d)); //余弦公式计算r1对应圆心角，弧度 //double angle_b = 2 * acos((b.r*b.r + d*d - a.r*a.r) / (2.0 * b.r*d)); //余弦公式计算r2对应圆心角，弧度 if(d-a.r-b.r&gt;=0)&#123; printf("%.10f\n",a.v()+b.v()); return; &#125; if(d+a.r&lt;b.r||d+b.r&lt;a.r)&#123; printf("%.10f\n",max(a.v(),b.v())); return; &#125; double l1 = (a.r*a.r - b.r*b.r + d*d) / (2*d); double l2 = (b.r*b.r - a.r*a.r + d*d) / (2*d); double h1 = a.r - l1, h2 = b.r - l2;//分别为两个球缺的高度 double v1 = PI*h1*h1*(a.r - h1 / 3);//相交部分r1圆所对应的球缺部分体积 double v2 = PI*h2*h2*(b.r - h2 / 3);//相交部分r2圆所对应的球缺部分体积 double v = v1 + v2;//相交部分体积 printf("%.10f\n",a.v()+b.v()-v); //double s1 = PI*a.r*x1; //r1对应球冠表面积 //double s2 = PI*a.r*x2; //r2对应球冠表面积 //double s = 4 * PI*(a.r*a.r + b.r*b.r) - s1 - s2;//剩余部分表面积&#125; int main() &#123; sphere a,b; scanf("%lf%lf%lf%lf",&amp;a.centre.x,&amp;a.centre.y,&amp;a.centre.z,&amp;a.r); scanf("%lf%lf%lf%lf",&amp;b.centre.x,&amp;b.centre.y,&amp;b.centre.z,&amp;b.r); Solve(a,b); return 0;&#125; F 简单数学题 数学弃… 岑巨出的题，难度适中，B题dp因为没注意要从dp[0] [maxv]开始初始化debug了很久 C题想到了并查集竟然不想写 E题内含的条件写错了，一直以为公式错了QAQ 还是大意了啊]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>bfs</tag>
        <tag>dp</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客OI周赛7-普及组]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2OI%E5%91%A8%E8%B5%9B7-%E6%99%AE%E5%8F%8A%E7%BB%84.html</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/contest/372#question A 救救猫咪 暴力 B 救救兔子 题意：给出n长数组，m个询问，每次询问给出一个x，要求数组中与x差距最小的数(如果差距相等，输出较小的那个) 思路： 二分，原数组排序后用upper_lowbound() 找出第一个比x大元素的位置，在分别比较当前位置和当前位置-1的数与x的差距，注意比第一个数小和最后一个数大的时候需特判 代码： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;int a[maxn]; int main()&#123; int n,q,x; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); sort(a,a+n); scanf("%d",&amp;q); while(q--)&#123; scanf("%d",&amp;x); if(x&gt;=a[n-1]) printf("%d\n",a[n-1]); else if(x&lt;=a[0]) printf("%d\n",a[0]); else&#123; int pos=upper_bound(a,a+n,x)-a; if(abs(a[pos-1]-x) &lt;= abs(a[pos]-x)) printf("%d\n",a[pos-1]); else printf("%d\n",a[pos]); &#125; &#125;&#125; C 救救企鹅 题意: 给出字符串s,a,b(长度&lt;=1e6),要求输出将s中所有a替换为b后的字符串 思路: kmp或hash求出s中与a匹配的位置,再替换一下即可 比赛的时候没有注意到a,b串的长度可以不相等 只过了50%qwq 赛后发现用Java或Python都可以直接秒这题tql 代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int maxn = 1e6+5;char s[maxn],a[maxn],b[maxn];int lens,lena,lenb;ull base=131;ull p[maxn],hs[maxn];ull geth(int l,int r)&#123; return (ull)hs[r]-hs[l-1]*p[r-l+1];&#125; vector&lt;int&gt;pos;int main()&#123; p[0]=1; for(int i=1;i&lt;maxn;i++) p[i]=p[i-1]*base; scanf("%s%s%s",s+1,a+1,b+1); lens=strlen(s+1); lena=lenb=strlen(a+1); ull tt=0; for(int i=1;i&lt;=lena;i++) tt=tt*base+(ull)a[i]; for(int i=1;i&lt;=lens;i++) hs[i]=hs[i-1]*base+(ull)s[i]; for(int i=1;i&lt;=lens-lena+1;i++)&#123; ull ss=geth(i,i+lena-1); if(ss==tt)&#123; pos.push_back(i); i+=lena-1; &#125; &#125; int k=1; for(int i=0;i&lt;pos.size();i++)&#123; while(k!=pos[i])&#123; putchar(s[k]); k++; &#125; printf("%s",b+1); k+=lena; &#125; while(k&lt;=lens)&#123; putchar(s[k]); k++; &#125; puts("");&#125; D 数糖纸 题意: 给出长度为n的数组(maxn=1e6),要求不含相同元素的最长连续区间长度 思路: 双指针(l,r)移动表示[l,r]内没有重复的元素,用个set记录当前区间已经出现了的数,如果枚举到一个没有出现的数,则加入set,++r,否则一直删除左端已经出现过的元素直到重复元素被删除 上面可以稍微优化一下,因为 Ai 最大1e9,我们先将原数组离散化,再用一个vis[] 记录Ai 是否出现过 代码1: 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;int a[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int ans=-1,l=1,r=1; set&lt;int&gt;s; while(r&lt;=n)&#123; if(s.find(a[r])==s.end())&#123; s.insert(a[r]); ans=max(ans,r-l+1); r++; &#125; else&#123; s.erase(a[l]); l++; &#125; &#125; printf("%d\n",ans);&#125; 代码2: 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;int a[maxn],b[maxn],pre[maxn],vis[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); b[i]=a[i]; &#125; sort(b+1,b+1+n); int m=unique(b+1,b+1+n)-b-1; for(int i=1;i&lt;=n;i++)&#123; a[i]=lower_bound(b+1,b+1+n,a[i])-b-1; &#125; int ans=-1,l=1; for(int i=1;i&lt;=n;i++)&#123; if(!vis[a[i]])&#123; vis[a[i]]=1; &#125; else&#123; while(a[l]!=a[i])&#123; vis[a[l]]=0; l++; &#125; l++; vis[a[i]]=1; &#125; ans=max(ans,i-l+1); &#125; printf("%d\n",ans);&#125; 一场比较简单的比赛,一点小粗心kmp就挂了 第一次在高铁上写博客,刺激~]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>字符串hash</tag>
        <tag>暴力</tag>
        <tag>kmp</tag>
        <tag>STL</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EOJ Monthly 2019.2]]></title>
    <url>%2FEOJ-Monthly-2019-2.html</url>
    <content type="text"><![CDATA[原题链接：https://acm.ecnu.edu.cn/contest/140/ A,B,C,E To be continue… D 进制转换 题意：求[l,r]中所有数的k进制末尾恰好有m个零的数有多少个 思路： x在k进制下末尾恰好有m个零说明x%(k^m)恒等于0，而x%(k^(m+1))不恒等于0，而x%(k^m)==0的情况包含了x%(k^(m+1))==0的情况，所以由容斥定理有[1,x]中满足题意的数有 x/(k^m) - x/(k^(m+1)) 个 代码： 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;ll calc(ll k,ll m,ll x)&#123; for(int i=1;i&lt;=m;i++)&#123; x/=k; &#125; return x;&#125;int main()&#123; ll l,r,k,m; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%lld%lld%lld%lld",&amp;l,&amp;r,&amp;k,&amp;m); printf("%lld\n",calc(k,m,r)-calc(k,m+1,r)-calc(k,m,l-1)+calc(k,m+1,l-1)); &#125;&#125; F 方差 题意： 在n个数中选m个数，使得这m个数的方差*(m^2)最小 思路： 首先想到要使方差越小，则要这m个数与平均数的差距越小，所以我们可以先排序再尺取m长; 不难发现将方差公式乘以m^2后可以化简得到 m(a_1^2+a_2^2+⋯+a_m^2) − (a_1+a_2+⋯+a_m)^2（MathJax真好用，小声哔哔 然后维护一个前缀和与一个前缀平方和即可 代码： 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;int a[maxn];ll sum1[maxn],sum2[maxn];int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; sort(a+1,a+1+n); for(int i=1;i&lt;=n;i++)&#123; sum1[i]=sum1[i-1]+a[i]; sum2[i]=sum2[i-1]+a[i]*a[i]; &#125; ll ans=-1; for(int i=m;i&lt;=n;i++)&#123; ll tmp=m*(sum2[i]-sum2[i-m])-(sum1[i]-sum1[i-m])*(sum1[i]-sum1[i-m]); if(ans==-1||ans&gt;tmp) ans=tmp; &#125; printf("%lld\n",ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客OI周赛7-提高组]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2OI%E5%91%A8%E8%B5%9B7-%E6%8F%90%E9%AB%98%E7%BB%84.html</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/contest/371#question A 小睿睿的等式 题意：有n根火柴棒，能摆成形如“A+B=n”的等式且使用的火柴棒数也恰好等于n/k的等式有多少种(B+A=n与A+B=n看作一种,“=”与“+”分别需要使用2根火柴棒,maxn=5e7) 思路：直接暴力拆分每组A+B写的挫会超时，比赛时没注意给出的空间很大(512MB)，先将所有5e7以内数所需火柴数打表即可 代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =5e7+5;int num[maxn];int main() &#123; num[0]=6; num[1]=2; num[2]=5; num[3]=5; num[4]=4; num[5]=5; num[6]=6; num[7]=3; num[8]=7; num[9]=6; int n; int k; scanf("%d%d",&amp;n,&amp;k); for(int i=10;i&lt;=n;i++)&#123; num[i]=num[i/10]+num[i%10]; &#125; int kk=n/k; int ans=0,x,y,z=num[n]; for(int a=0; a&lt;=n/2; a++) &#123; int b=n-a; x=num[a]; y=num[b]; if(x+y+z+4==kk) ans++; &#125; printf("%d\n",ans); return 0;&#125; B 小睿睿的询问 题意：给出随机生成一个n长数组的函数和生成区间查询L，R的函数，要求所有L，R区间生成数组中val[i]最大且较小下标异或值（maxn=1e5，maxm=5e7) 思路：最开始写的线段树（O(mlogn)），因为是随机数据没想到过了时间是全场最久的(4632/5000 ms),后来知道可以用ST表写，但自己写的挫，加了个二分查对应下标也用了2900+ms(O(nlognlogn))，再后来可以在ST表处直接用个pair，val[i]和i对应,每次查询O(1)，总体复杂度O(nlogn+m) 代码： 线段树版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =1e5+5;int n,m;int val[maxn],Max[maxn&lt;&lt;2],idx[maxn&lt;&lt;2]; void push_up(int l,int r,int o)&#123; Max[o]=max(Max[o&lt;&lt;1],Max[o&lt;&lt;1|1]); if(Max[o&lt;&lt;1] &gt;= Max[o&lt;&lt;1|1]) idx[o]=idx[o&lt;&lt;1]; else idx[o]=idx[o&lt;&lt;1|1];&#125; void build(int l,int r,int o)&#123; if(l==r)&#123; Max[o]=val[l]; idx[o]=l; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(l,r,o);&#125; int query(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return idx[o]; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid&amp;&amp;R&gt;mid)&#123; int i=query(L,R,lson); int j=query(L,R,rson); if(val[i]&gt;=val[j]) return i; else return j; &#125; else if(L&lt;=mid)&#123; return query(L,R,lson); &#125; else if(R&gt;mid)&#123; return query(L,R,rson); &#125; return 0;&#125; void generate_array(int n,int seed) &#123; unsigned x = seed; for (int i=1; i&lt;=n; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; val[i]=x%100; &#125;&#125; int lastans=0,ans=0;void generate_ask(int n,int m,int seedx,int seedy) &#123; unsigned x=seedx,y=seedy; for (int i=1; i&lt;=m; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; y ^= y &lt;&lt; 13; y ^= y &gt;&gt; 17; y ^= y &lt;&lt; 5; int L=(x^lastans)%n+1,R=(y^lastans)%n+1; if (L&gt;R) swap(L,R); lastans=query(L,R,1,n,1); ans^=lastans; &#125; printf("%d\n",ans);&#125; int main() &#123; int seed,seedx,seedy; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;seed,&amp;seedx,&amp;seedy); //double ss=clock(); generate_array(n,seed); build(1,n,1); generate_ask(n,m,seedx,seedy); //printf("%.0fms\n",clock()-ss); return 0;&#125; 二分+ST版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =1e5+5;int n,m;int val[maxn];vector&lt;int&gt;idx[105];int f[maxn][20];void ST_pre()&#123; for(int i=1;i&lt;=n;i++)&#123; f[i][0]=val[i]; &#125; int t=log(n)/log(2)+1; for(int j=1;j&lt;t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]); &#125; &#125;&#125;int ST_query(int l,int r)&#123; int k=log(r-l+1)/log(2); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125; void generate_array(int n,int seed) &#123; unsigned x = seed; for (int i=1; i&lt;=n; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; val[i]=x%100; idx[val[i]].push_back(i); &#125;&#125; int lastans=0,ans=0;void generate_ask(int n,int m,int seedx,int seedy) &#123; unsigned x=seedx,y=seedy; for (int i=1; i&lt;=m; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; y ^= y &lt;&lt; 13; y ^= y &gt;&gt; 17; y ^= y &lt;&lt; 5; int L=(x^lastans)%n+1,R=(y^lastans)%n+1; if (L&gt;R) swap(L,R); int pos,Max=ST_query(L,R); int s=lower_bound(idx[Max].begin(),idx[Max].end(),L)-idx[Max].begin(); for(int k=s;k&lt;=idx[Max].size();k++)&#123; if(idx[Max][k]&gt;=L&amp;&amp;idx[Max][k]&lt;=R)&#123; pos=idx[Max][k]; break; &#125; &#125; lastans=pos; ans^=lastans; &#125; printf("%d\n",ans);&#125; int main() &#123; int seed,seedx,seedy; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;seed,&amp;seedx,&amp;seedy); //double ss=clock(); generate_array(n,seed); ST_pre(); generate_ask(n,m,seedx,seedy); //printf("%.0fms\n",clock()-ss); return 0;&#125; 优化ST版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =1e5+5;int n,m;int val[maxn];pair&lt;int,int&gt; f[maxn][20]; void ST_pre()&#123; for(int i=1;i&lt;=n;i++)&#123; f[i][0].first=i; f[i][0].second=val[i]; &#125; int t=log(n)/log(2)+1; for(int j=1;j&lt;t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; //f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]); f[i][j] = f[i][j-1].second &gt;= f[i+(1&lt;&lt;j-1)][j-1].second ? f[i][j-1]:f[i+(1&lt;&lt;j-1)][j-1]; &#125; &#125;&#125;int ST_query(int l,int r)&#123; int k=log(r-l+1)/log(2); return f[l][k].second &gt;= f[r-(1&lt;&lt;k)+1][k].second ? f[l][k].first : f[r-(1&lt;&lt;k)+1][k].first;&#125; void generate_array(int n,int seed) &#123; unsigned x = seed; for (int i=1; i&lt;=n; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; val[i]=x%100; &#125;&#125; int lastans=0,ans=0;void generate_ask(int n,int m,int seedx,int seedy) &#123; unsigned x=seedx,y=seedy; for (int i=1; i&lt;=m; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; y ^= y &lt;&lt; 13; y ^= y &gt;&gt; 17; y ^= y &lt;&lt; 5; int L=(x^lastans)%n+1,R=(y^lastans)%n+1; if (L&gt;R) swap(L,R); int pos=ST_query(L,R); lastans=pos; ans^=lastans; &#125; printf("%d\n",ans);&#125; int main() &#123; int seed,seedx,seedy; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;seed,&amp;seedx,&amp;seedy); //double ss=clock(); generate_array(n,seed); ST_pre(); generate_ask(n,m,seedx,seedy); //printf("%.0fms\n",clock()-ss); return 0;&#125; C 小睿睿的方案 To be continue… 这场Rating赛打得还是还算比较开心吧，学了一下ST表空间复杂度O(nlogn),区间查询O(1)很不错的算法，程序运算时间的计算和数组所占大概空间的计算，虽然理论课学了但一直没去实践QWQ另外牛客题目还不错~不说了EOJ的题还没补呢！]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>ST</tag>
        <tag>线段树</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛 40A--小D的剧场]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-40A--%E5%B0%8FD%E7%9A%84%E5%89%A7%E5%9C%BA.html</url>
    <content type="text"><![CDATA[题意： 给出自然数1-49的49个数要求拼接成长度为n的序列，且要求任意相邻的三个不能为给出q个条件中任意一个条件的全排列，求所有合法序列数对 1e9+7 取模。 原题链接：https://ac.nowcoder.com/acm/contest/369/A Input: 123456789101110 10 //n q18 3 343 28 2242 28 348 48 429 9 3147 9 221 22 4915 48 292 8 274 24 34 Output: 1382785822 思路： 设dp[i] [j] [k]为放到第i位时，a[i-1]=j, a[i]==k的状态，提前将不合法字段标记，转移方程： dp_{i,k,l} = \sum_{i=1}^{49} (!ban_{j,k,l})*dp_{i-1,j,k}表示j,k,l可行时，可在 a[i-2]==j,a[i-1]==k的状态转移到 a[i-1]==k,a[i]==l的状态。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int P = 1e9+7;int dp[505][50][50];bool ban[50][50][50];int main()&#123; int n,q; scanf("%d%d",&amp;n,&amp;q); while(q--)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ban[a][b][c]=ban[a][c][b]=true; ban[b][a][c]=ban[b][c][a]=true; ban[c][a][b]=ban[c][b][a]=true; &#125; for(int i=1;i&lt;=49;i++)&#123; for(int j=1;j&lt;=49;j++)&#123; dp[2][i][j]=1; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=49;j++)&#123; for(int k=1;k&lt;=49;k++)&#123; for(int l=1;l&lt;=49;l++)&#123; if(!ban[j][k][l])&#123; dp[i][k][l]=(dp[i][k][l]+dp[i-1][j][k])%P; &#125; &#125; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=49;i++)&#123; for(int j=1;j&lt;=49;j++)&#123; ans=(ans+dp[n][i][j])%P; &#125; &#125; printf("%d\n",ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛 40C--小A与欧拉路]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-40C--%E5%B0%8FA%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%B7%AF.html</url>
    <content type="text"><![CDATA[题意： 小A给你了一棵树，对于这棵树上的每一条边，你都可以将它复制任意（可以为0）次（即在这条边连接的两个点之间再加一条边权相同的边），求所有可能新形成的图中欧拉路的最短长度 欧拉路：从图中任意一个点开始到图中任意一个点结束的路径，并且图中每条边只通过恰好一次。 原题链接：https://ac.nowcoder.com/acm/contest/369/C Input： 12344 //n 树的点数1 2 1 //u v w1 3 11 4 2 Output： 15 思路： 先考虑回路的情况。由于是一棵树，任两点间路径只有一条，从一条边走到深度更大的点，一定还会从同一条边返回以回到起点或者遍历其他子树，所以每条边需要复制一次，此时答案是边权和的两倍。 不是回路的情况可以减掉从终点回到起点的路径，要让这条路径尽量长，所以长度一定是直径的长度。 答案就是边权和的两倍减去直径长度。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2e5+5;struct EDGE&#123; int next,w,to;&#125;edge[maxn*2];int head[maxn];int cnt; void add(int u,int v,int w)&#123; edge[++cnt].next=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125; int pos,ans;int d[maxn];void dfs(int x,int pre)&#123; for(int i=head[x];i;i=edge[i].next)&#123; int to=edge[i].to; if(to==pre) continue; d[to]=d[x]+edge[i].w; dfs(to,x); &#125; if(d[x]&gt;ans)&#123; ans=d[x]; pos=x; &#125;&#125; int main()&#123; int n; scanf("%d",&amp;n); ll sum=0; for(int i=0;i&lt;n-1;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); sum+=2*w; &#125; dfs(1,-1); memset(d,0,sizeof(d)); dfs(pos,-1); printf("%lld\n",sum-ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>欧拉路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSU 1803--2016]]></title>
    <url>%2FCSU%201803--2016.html</url>
    <content type="text"><![CDATA[题意： 求[l,r]之间有多少种a*b=2016的组合。 思路： 首先2016的1倍情况下有1*2016 , 2*1008 , 3*637… 等情况，2倍情况就是把a或b扩大2倍就行，那么我们可以把a看做[1,2016]的数，a’ 看做[2017,4032]的数，这样每次跨2016个数就知道有多少倍数了。最后两层for循环找出i*j==2016的时候把对应的倍数种类乘起来加到答案就行了。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; int main()&#123; ll n,m; ll a[3000],b[3000]; //a[i]储存n有多少个i*2016&lt;=n，b[i]....m while(~scanf("%lld%lld",&amp;n,&amp;m)) &#123; ll k=n/2016; //有k个2016跨度 ll mm=n%2016; //余下的等下都要+1 for(int i=1;i&lt;=mm;i++) a[i]=k+1; for(int i=mm+1;i&lt;=2016;i++) a[i]=k; k=m/2016; mm=m%2016; for(int i=1;i&lt;=mm;i++) b[i]=k+1; for(int i=mm+1;i&lt;=2016;i++) b[i]=k; ll ans=0; for(int i=1;i&lt;=2016;i++) &#123; for(int j=1;j&lt;=2016;j++) &#123; if((i*j)%2016==0) &#123; ans+=(a[i]*b[j]); &#125; &#125; &#125; printf("%lld\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 4011--Happy-Sequence]]></title>
    <url>%2FZOJ%204011--Happy-Sequence.html</url>
    <content type="text"><![CDATA[题意： 给一个n和m，求所有组成m长且值在1-n内且满足 a[i]%a[i-1]==0 的序列方案数。 思路： dp[i] [j] 表示长度为 i 的序列的最后一位为 j ,转移方程：dp[i] [j]=0 , dp[i] [j]+=dp[i-1] [ j的因子 ] 。因子可以通过埃氏筛打表得到，dp[m] [i]累加和即为答案，预处理2000*2000以内所有答案即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std; #define N 2005#define mod 1000000007int dp[N][N];vector&lt;int&gt;y[N]; //储存因子int main()&#123; for(int i=1; i&lt;=N; i++) &#123; for(int j=i; j&lt;=N; j+=i) &#123; y[j].push_back(i); &#125; &#125; for(int i=1; i&lt;=N; i++) dp[1][i]=1; for(int i=2; i&lt;=N; i++) &#123; for(int j=1; j&lt;=N; j++) &#123; for(int k=0; k&lt;y[j].size(); k++) &#123; dp[i][j]=(dp[i][j]+dp[i-1][y[j][k]])%mod; &#125; &#125; &#125; int t; scanf("%d",&amp;t); while(t--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); int ans=0; for(int i=1; i&lt;=n; i++) ans=(ans+dp[m][i])%mod; printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 2594--Driving-Straight]]></title>
    <url>%2FZOJ%202594--Driving-Straight.html</url>
    <content type="text"><![CDATA[题意： 给出一个（2m-1）（2*n-1）的图，要求输出从左下角走到右上角最短距离走法的路径，只能在 ‘-’ 或 ‘|’ 上移动，答案保证有解，有多解输出任一，n,m&lt;=400。 思路： 因为题目要求输出路径，而bfs中如果每个状态都记录到当前状态的路径，可能会TLE或者MLE。 所以考虑先从终点开始bfs出每个点到终点的最短距离，然后再从起点出发bfs一直找 当前点的最短距离-1==下一步的最短距离 的位置就可以回到终点，注意方向的变换。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;using namespace std;char mp[1005][1005];int dis[1005][1005];int m,n;int dx[10]=&#123;-1,0,1,0&#125;; //反向由北到西顺时针 依次为0123int dy[10]=&#123;0,1,0,-1&#125;;int dd[10][10] = &#123;&#123;0, 1, 2, 3&#125;, // F&#123;3, 0, 1, 2&#125;, // L&#123;1, 2, 3, 0&#125; // R&#125;;char dir[10]=&#123;'F','L','R'&#125;; struct node&#123; int x,y; node()&#123;&#125; node(int x,int y):x(x),y(y)&#123;&#125;&#125;; void bfs()&#123; queue&lt;node&gt;q; memset(dis,-1,sizeof(dis)); dis[1][2*n-1]=0; q.push(node(1,2*n-1)); node now; int x,y,px,py; while(!q.empty()) &#123; now=q.front(); q.pop(); px=now.x,py=now.y; //printf("%d %d\n",px,py); for(int i=0;i&lt;4;i++) &#123; x=px+dx[i]; y=py+dy[i]; if(mp[x][y]=='-' || mp[x][y]=='|') &#123; x+=dx[i]; y+=dy[i]; if(dis[x][y]==-1) &#123; dis[x][y]=dis[px][py]+1; q.push(node(x,y)); &#125; &#125; &#125; &#125;&#125; void print()&#123; int statu,x,y,px,py; if(mp[2*m-1][2]=='-' &amp;&amp; dis[2*m-1][1]-1==dis[2*m-1][3]) &#123; puts("E"); px=2*m-1,py=3; statu=1; &#125; else if(mp[2*m-2][1]=='|' &amp;&amp; dis[2*m-1][1]-1==dis[2*m-3][1]) &#123; puts("N"); px=2*m-3,py=1; statu=0; &#125; while(1) &#123; if(dis[px][py]==0) &#123; puts(""); break; &#125; for(int i=0;i&lt;3;i++) &#123; x=px+dx[dd[i][statu]]; y=py+dy[dd[i][statu]]; if(mp[x][y]=='-' || mp[x][y]=='|') &#123; x+=dx[dd[i][statu]]; y+=dy[dd[i][statu]]; if(dis[x][y]==dis[px][py]-1) &#123; printf("%c",dir[i]); statu=dd[i][statu]; px=x,py=y; break; &#125; &#125; &#125; &#125;&#125; int main()&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;m,&amp;n); memset(mp,' ',sizeof(mp)); getchar(); for(int i=1; i&lt;=2*m-1; i++) &#123; gets(mp[i]+1); &#125; bfs(); /*for(int i=1;i&lt;=2*m-1;i+=2) &#123; for(int j=1;j&lt;=2*n-1;j+=2) &#123; printf("%3d",dis[i][j]); &#125;puts(""); &#125;*/ print(); if(T) puts(""); &#125;&#125; /*24 4+-+-+-+|+-+-+-+ |+-+-+-+|+-+-+-+NRFFLLFFRRFF4 4+-+ +-+| | |+ +-+-+| | |+-+-+-+| |+-+-+-+EFFLFF*/]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 110D--Lucky Probability]]></title>
    <url>%2FCodeforces%20110D--Lucky%20Probability.html</url>
    <content type="text"><![CDATA[题意： 出个两个（P,V）范围在1e9的正整数区间，分别从其中随机选出一个数，选出的两个数作为一个新区间的左右端点。要求新区间内的幸运数刚好为k个的概率（幸运数指一个数的数位只有4或7）。 思路： 首先可以dfs找出所有在数据范围内的幸运数，记为L数组，因为数目不多，便可成k段遍历 L数组，每次分别计算【 L[i-1]+1，L[i]】与【Pl，Pr】的线段交集，和【 L[i+k-1]，L[i+k]-1】与【Vl，Vr】的线段交集，将两个结果相乘即是符合[i,i+k-1]区间幸运数的可能情况，同样的还要对P,V两个区间交换后在计算一遍，概率=所有可能情况/(Pr-Pl+1)/(Vr-Vl+1);然后还要注意k==1的情况会重复计算，需特判。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll L[1050];int num=0;void dfs(int len,int p,int v)&#123; if(p==len) &#123; L[++num]=v; return; &#125; dfs(len,p+1,v*10+4); dfs(len,p+1,v*10+7);&#125; ll contain(ll x1,ll y1,ll x2,ll y2)&#123; ll l=max(x1,x2); ll r=min(y1,y2); return r-l+1&gt;0?r-l+1:0;&#125; int main()&#123; for(int len=1;len&lt;=9;len++) dfs(len,0,0); L[0]=0; L[++num]=1000000000; //for(int i=1;i&lt;=num;i++) printf("%d %lld\n",i,L[i]); ll Pl,Pr,Vl,Vr; int k; scanf("%lld%lld%lld%lld%d",&amp;Pl,&amp;Pr,&amp;Vl,&amp;Vr,&amp;k); ll sum=0; for(int i=1;i&lt;=1022-k+1;i++) &#123; int j=i+k-1; sum+=contain(L[i-1]+1,L[i],Pl,Pr)*contain(L[j],L[j+1]-1,Vl,Vr); if(L[i]&gt;Pr) break; &#125; for(int i=1;i&lt;=1022-k+1;i++) &#123; int j=i+k-1; sum+=contain(L[i-1]+1,L[i],Vl,Vr)*contain(L[j],L[j+1]-1,Pl,Pr); if(L[i]&gt;Vr) break; &#125; if(k==1) &#123; for(int i=1;i&lt;=1022;i++) &#123; if(contain(L[i],L[i],Pl,Pr)&amp;&amp;contain(L[i],L[i],Vl,Vr)) sum--; &#125; &#125; printf("%.10f\n",sum*1.0/(Vr-Vl+1)/(Pr-Pl+1));&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2774--Long Long Message]]></title>
    <url>%2FPOJ%202774--Long%20Long%20Message.html</url>
    <content type="text"><![CDATA[题意：给出两个最长长为1e5的字符串，求他们的最长公共子串长度。 思路： 分别将两个字符串预处理出hash值，二分【1-min（lens，lent）】的长度，check函数中每次将长度为mid的hash值记录并检查是否符合条件，是则下边界右移，否则上边界左移。复杂度O(nlogn) 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int N =100000+5; char s[N],t[N];int lens,lent;ull base=233;ull p[N],hs[N],ht[N];ull geths(int l,int r)&#123; return hs[r]-p[r-l+1]*hs[l-1];&#125;ull getht(int l,int r)&#123; return ht[r]-p[r-l+1]*ht[l-1];&#125; int check(int len)&#123; vector&lt;ull&gt;mp; for(int i=1; i&lt;=lens-len+1; i++) &#123; ull tmp=geths(i,i+len-1); mp.push_back(tmp); &#125; sort(mp.begin(),mp.end()); for(int i=1; i&lt;=lent-len+1; i++) &#123; ull tmp=getht(i,i+len-1); if(binary_search(mp.begin(),mp.end(),tmp)) return 1; &#125; return 0;&#125; int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); p[0]=1; for(int i=1; i&lt;N; i++) p[i]=p[i-1]*base; while(~scanf("%s%s",s+1,t+1)) &#123; lens=strlen(s+1); lent=strlen(t+1); for(int i=1; i&lt;=lens; i++) &#123; hs[i]=hs[i-1]*base+s[i]-'a'; &#125; for(int i=1; i&lt;=lent; i++) &#123; ht[i]=ht[i-1]*base+t[i]-'a'; &#125; int l=1,r=min(lens,lent),mid; while(l&lt;=r) &#123; mid=(l+r)/2; if(check(mid)) l=mid+1; else r=mid-1; &#125; printf("%d\n",r); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>字符串hash</tag>
      </tags>
  </entry>
</search>
