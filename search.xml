<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019杭电多校 补题日志]]></title>
    <url>%2F2019%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1-%E8%A1%A5%E9%A2%98%E6%97%A5%E5%BF%97.html</url>
    <content type="text"><![CDATA[留点曾经被搞自闭的印象… 第一场1009-String 题意：在n长字符串中选出k长子序列，使子序列中每个字母的出现次数分别在一个区间内，且要求字典序最小 思路：统计后缀和，记录[i..n]还有多少个某字符，记录每个字符出现的所有位置，然后每次对于要放的第i个位置，贪心的从小的字母开始选，如果选定该字符且后面的字符个数符合条件就取该字符放在第i个位置，否则下一个；如果有某一位选不了，就说明不够构造出答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5+5;int cnt[maxn][30];vector&lt;int&gt;pos[30];int p[30],used[30];char s[maxn],ans[maxn];int l[30],r[30];int main()&#123; int k; while(~scanf("%s%d",s,&amp;k))&#123; memset(p,0,sizeof(p)); memset(cnt,0,sizeof(cnt)); memset(used,0,sizeof(used)); for(int i=0;i&lt;26;i++)&#123; pos[i].clear(); &#125; for(int i=0;i&lt;26;i++)&#123; scanf("%d%d",&amp;l[i],&amp;r[i]); &#125; int lens=strlen(s); for(int i=lens-1;i&gt;=0;i--)&#123; for(int j=0;j&lt;26;j++)&#123; cnt[i][j]=cnt[i+1][j]+(s[i]-'a'==j); &#125; &#125; for(int i=0;i&lt;lens;i++)&#123; pos[s[i]-'a'].push_back(i); &#125; for(int i=0;i&lt;26;i++)&#123; p[i]=0; &#125; bool ok=true; int last=-1; for(int i=0;i&lt;k;i++)&#123; ok=false; for(int j=0;j&lt;26;j++)&#123; if(used[j]==r[j]) continue; //限制最多拿该字符取的个数 while(p[j]!=pos[j].size()&amp;&amp;pos[j][p[j]]&lt;=last) p[j]++; //当前位置在上一次选定位置之前 if(p[j]==pos[j].size()) continue; used[j]++; int now = pos[j][p[j]]; int flag=1,need=0; for(int k=0;k&lt;26;k++)&#123; if(cnt[now+1][k]&lt;l[k]-used[k]) flag=0; //后面总字符个数不够 need += max(0,l[k]-used[k]); &#125; if(need &gt; k-i-1) flag=0; //至少需要的字符个数位置不够 if(!flag)&#123; //该字符不可取 used[j]--; &#125; else&#123; ans[i]='a'+j; ok=true; last=now; break; &#125; &#125; if(!ok) break; &#125; ans[k]='\0'; if(!ok) puts("-1"); else printf("%s\n",ans); &#125;&#125; 第二场1009-I Love Palindrome String 题意：求所有长度的回文子串，其前一半也是回文子串的个数 思路：PAM模板题，记录每个状态的最后一个字符的下标，然后就可以根据位置和长度hash去判断每个状态的回文串是否合法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn = 3e5+5;const int N = 26 ;struct Palindromic_Tree &#123; int next[maxn][N] ;//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成 int fail[maxn] ;//fail指针，失配后跳转到fail指针指向的节点 int cnt[maxn] ; //在最后统计后它可以表示形如以i为结尾的回文串中最长的那个串个数 int num[maxn] ; //表示以i结尾的回文串的种类数 int len[maxn] ;//len[i]表示节点i表示的回文串的长度 int S[maxn] ;//存放添加的字符 int last ;//指向上一个字符所在的节点，方便下一次add int n ;//字符数组指针 int p ;//节点指针 int pos[maxn]; int newnode ( int l ) &#123; for ( int i = 0 ; i &lt; N ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123;//初始化 p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1 ; &#125; int get_fail ( int x ) &#123;//和KMP一样，失配后找一个尽量最长的 while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; void add ( int c ,int id) &#123; c -= 'a' ; S[++ n] = c ; int cur = get_fail ( last ) ;//通过上一个回文串找这个回文串的匹配位置 if ( !next[cur][c] ) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode ( len[cur] + 2 ) ;//新建节点 fail[now] = next[get_fail ( fail[cur] )][c] ;//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; pos[now] = id; &#125; last = next[cur][c] ; cnt[last] ++ ; &#125; void Count () &#123; for ( int i = p - 1 ; i &gt;= 0 ; -- i ) cnt[fail[i]] += cnt[i] ; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！ &#125;&#125; ptree;char s[maxn];ull base=233;ull p[maxn],hs[maxn];ull geths(int l,int r)&#123; return hs[r]-p[r-l+1]*hs[l-1];&#125;int ans[maxn];int main() &#123; p[0]=1; for(int i=1;i&lt;maxn;i++) p[i]=p[i-1]*base; while(~scanf("%s",s+1))&#123; int n=strlen(s+1); ptree.init(); for(int i=1;i&lt;=n;i++)&#123; ans[i]=0; ptree.add(s[i],i); &#125; ptree.Count(); for(int i=1;i&lt;=n;i++)&#123; hs[i]=hs[i-1]*base+s[i]; &#125; for(int i=2;i&lt;ptree.p;i++)&#123; int len=ptree.len[i],cnt=ptree.cnt[i]; int r=ptree.pos[i]; int l=r-len+1; //printf("%d %d %d %d\n",l,r,len,cnt); int m=(l+r)/2; if(geths(l,m)==geths(m+(len%2==0),r))&#123; ans[len]+=cnt; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; printf("%d%c",ans[i],i==n?'\n':' '); &#125; &#125;&#125; 1012-Longest Subarray 题意：求最长的一段连续序列的长度，序列中使得每个数出现次数&gt;=k 思路：枚举右端点，对于当前数字c，它的当前位置为pos[i]，那么它有两个合法区间：一个是[pos[i]+1,pos[i+1]-1],这段区间对后面的数来说是不选该数，那么该区间左端点的选择合法；另一个是[1,离当前位置前k-1个该数的位置]，左端点落入这段区间就意味该数出现次数&gt;=k。 然后就可以线段树维护每个数的合法区间，对于每个右端点，离它最远满足每个数的合法区间为最优解，对于每个合法区间，线段树区间+1，右端点移动的时候就可以动态更新合法区间。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define lson l,m,o&lt;&lt;1#define rson m+1,r,o&lt;&lt;1|1using namespace std;typedef long long ll;const int maxn = 1e5+5;int n,c,k;int a[maxn],pre[maxn];vector&lt;int&gt;pos[maxn];int Max[maxn&lt;&lt;2],add[maxn&lt;&lt;2];void push_up(int o)&#123; Max[o]=max(Max[o&lt;&lt;1],Max[o&lt;&lt;1|1]);&#125;void push_down(int o)&#123; if(add[o])&#123; add[o&lt;&lt;1]+=add[o]; add[o&lt;&lt;1|1]+=add[o]; Max[o&lt;&lt;1]+=add[o]; Max[o&lt;&lt;1|1]+=add[o]; add[o]=0; &#125;&#125;void build(int l,int r,int o)&#123; Max[o]=0; add[o]=0; if(l==r) return; int m = (l+r)&gt;&gt;1; build(lson); build(rson);&#125;void update(int L,int R,int v,int l,int r,int o)&#123; if(L&gt;R) return; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; Max[o]+=v; add[o]+=v; return; &#125; push_down(o); int m = (l+r)&gt;&gt;1; if(L&lt;=m) update(L,R,v,lson); if(R&gt;m) update(L,R,v,rson); push_up(o);&#125;int query(int l,int r,int o)&#123; if(l==r) return l; push_down(o); int m = (l+r)&gt;&gt;1; if(Max[o&lt;&lt;1]==c) return query(lson); if(Max[o&lt;&lt;1|1]==c) return query(rson); return 0;&#125;int main() &#123; while(~scanf("%d%d%d",&amp;n,&amp;c,&amp;k))&#123; for(int i=1;i&lt;=c;i++)&#123; pos[i].clear(); pos[i].push_back(0); &#125; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); pos[a[i]].push_back(i); &#125; build(1,n,1); for(int i=1;i&lt;=c;i++)&#123; pre[i]=0; pos[i].push_back(n+1); update(1,pos[i][1]-1,1,1,n,1); &#125; int ans=0; for(int i=1;i&lt;=n;i++)&#123; int x = a[i]; //先减去上一次的合法区间 update(pos[x][pre[x]]+1,pos[x][pre[x]+1]-1,-1,1,n,1); if(pre[x]&gt;=k) update(1,pos[x][pre[x]-k+1],-1,1,n,1); pre[x]++; //更新这次的合法区间 update(pos[x][pre[x]]+1,pos[x][pre[x]+1]-1,1,1,n,1); if(pre[x]&gt;=k) update(1,pos[x][pre[x]-k+1],1,1,n,1); int j = query(1,n,1); if(j) ans=max(ans,(i-j+1)); &#125; printf("%d\n",ans); &#125;&#125; 第三场1004-Distribution of books 咕咕咕~ 第四场1003-Divide the Stones 题意：给n个数分别是1,2,…,n，要求分为k组，每组个数相等且和相等 思路：找规律 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;vector&lt;int&gt;ans[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; ll n,k; scanf("%lld%lld",&amp;n,&amp;k); ll sum=(1+n)*n/2; if(sum%k!=0)&#123; puts("no"); continue; &#125; for(int i=1;i&lt;=k;i++) ans[i].clear(); if((n/k)%2==0)&#123; int now=1,op=1; for(int j=1;j&lt;=n/k;j++)&#123; if(op)&#123; for(int i=1;i&lt;=k;i++) ans[i].push_back(now++); &#125; else&#123; for(int i=k;i&gt;=1;i--) ans[i].push_back(now++); &#125; op^=1; &#125; &#125; else&#123; ll need = (1+3*k)*3*k/2/k; int now=1,op=1; for(int i=1;i&lt;=k;i++) ans[i].push_back(now++); for(int i=k;i&gt;=1;i-=2) ans[i].push_back(now++); for(int i=k-1;i&gt;=1;i-=2) ans[i].push_back(now++); for(int i=1;i&lt;=k;i++) ans[i].push_back(need - ans[i][0] - ans[i][1]); now+=k; for(int j=4;j&lt;=n/k;j++)&#123; if(op)&#123; for(int i=1;i&lt;=k;i++) ans[i].push_back(now++); &#125; else&#123; for(int i=k;i&gt;=1;i--) ans[i].push_back(now++); &#125; op^=1; &#125; &#125; puts("yes"); for(int i=1;i&lt;=k;i++)&#123; for(int j=1;j&lt;=n/k;j++)&#123; printf("%d%c",ans[i][j-1],(j==n/k)?'\n':' '); &#125; &#125; &#125;&#125; 1008-K-th Closest Distance 题意：强制在线查询区间离p第k近(绝对值第k小) 思路：对于每个查询区间，先主席树二分区间第k小找到区间&lt;=p最大的那个数，然后双指针左右移动，哪边相差绝对值小就往哪边走，走k次即为答案，复杂度O(kmlogn) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define ls o&lt;&lt;1#define rs o&lt;&lt;1|1#define lson l,mid,ls#define rson mid+1,r,rs#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn=1e5+5;const int maxm=maxn*20;int T[maxn],L[maxm],R[maxm],sum[maxm];int sz[maxn],h[maxn];int n,q,tot;void build(int&amp; rt,int l,int r)&#123; rt=++tot; sum[rt]=0; if(l == r) return ; int mid=(l+r)&gt;&gt;1; build(L[rt],l,mid); build(R[rt],mid+1,r);&#125;void update(int&amp; rt,int l,int r,int pre,int x)&#123; rt=++tot; L[rt]=L[pre]; R[rt]=R[pre]; sum[rt]=sum[pre]+1; if(l == r) return ; int mid=(l+r)&gt;&gt;1; if(x &lt;= mid) update(L[rt],l,mid,L[pre],x); else update(R[rt],mid+1,r,R[pre],x);&#125;int query(int s,int e,int l,int r,int k)&#123; if(l == r) return l; int mid=(l+r)&gt;&gt;1; int res=sum[L[e]]-sum[L[s]]; if(k &lt;= res) return query(L[s],L[e],l,mid,k); else return query(R[s],R[e],mid+1,r,k-res);&#125;int main()&#123; int ca;scanf("%d",&amp;ca); while(ca--)&#123; scanf("%d%d",&amp;n,&amp;q); tot=0; for(int i=1; i&lt;=n; i++)&#123; scanf("%d",&amp;sz[i]); h[i]=sz[i]; &#125; sort(h+1,h+1+n); int num=unique(h+1,h+1+n)-(h+1); build(T[0],1,num); for(int i=1; i&lt;=n; i++) update(T[i],1,num,T[i-1],lower_bound(h+1,h+1+num,sz[i])-(h)); int ql,qr,p,k,l,r,pre,suf,ans=0; while(q--)&#123; scanf("%d%d%d%d",&amp;ql,&amp;qr,&amp;p,&amp;k); ql^=ans,qr^=ans,p^=ans,k^=ans; if(p&lt;=h[query(T[ql-1],T[qr],1,num,1)])&#123; l=0,r=1; &#125; else if(p&gt;=h[query(T[ql-1],T[qr],1,num,qr-ql+1)])&#123; l=qr-ql+1; r=qr-ql+2; &#125; else&#123; l=1,r=qr-ql+1; while(l&lt;r)&#123; int mid = (l+r+1)&gt;&gt;1; if(h[query(T[ql-1],T[qr],1,num,mid)]&lt;=p) l=mid; else r=mid-1; &#125; r=l+1; &#125; if(l!=0) pre=h[query(T[ql-1],T[qr],1,num,l)]; if(r!=qr-ql+2) suf=h[query(T[ql-1],T[qr],1,num,r)]; while(k--)&#123; if(l==0)&#123; r+=k; ans=abs(p-h[query(T[ql-1],T[qr],1,num,r)]); break; &#125; else if(r==qr-ql+2)&#123; l-=k; ans=abs(p-h[query(T[ql-1],T[qr],1,num,l)]); break; &#125; else&#123; int x=abs(p-pre),y=abs(p-suf); if(x&lt;=y)&#123; ans=x; l--; if(l!=0) pre=h[query(T[ql-1],T[qr],1,num,l)]; &#125; else&#123; ans=y; r++; if(r!=qr-ql+2) suf=h[query(T[ql-1],T[qr],1,num,r)]; &#125; &#125; &#125; printf("%d\n",ans); &#125; &#125;&#125; 第五场1002-three arrays 题意：给出两个n长整数序列，求两两配对异或后组成的新的序列字典序最小 思路：要求字典序最小，长度肯定也是n，那么每次贪心构造出最小异或值，建两个trie树，从高位到低位每次尽量都往相同的二进制位方向移动，这样使得异或出来的值尽可能小 get：动态开点初始化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 3e6+5;int tot[2];int t[2][maxn][2],val[2][maxn];void Insert(int op,int x)&#123; int now = 0; for(int i=30;i&gt;=0;i--)&#123; int to = (x&gt;&gt;i)&amp;1; if(!t[op][now][to])&#123; t[op][now][to] = ++tot[op]; val[op][tot[op]] = 0; t[op][tot[op]][0] = t[op][tot[op]][1] = 0; &#125; now = t[op][now][to]; val[op][now]++; &#125;&#125;int query()&#123; int ans=0; int p0=0,p1=0; for(int i=30;i&gt;=0;i--)&#123; if(val[0][t[0][p0][0]] &amp;&amp; val[1][t[1][p1][0]])&#123; p0=t[0][p0][0]; p1=t[1][p1][0]; val[0][p0]--; val[1][p1]--; &#125; else if(val[0][t[0][p0][1]] &amp;&amp; val[1][t[1][p1][1]])&#123; p0=t[0][p0][1]; p1=t[1][p1][1]; val[0][p0]--; val[1][p1]--; &#125; else if(val[0][t[0][p0][0]] &amp;&amp; val[1][t[1][p1][1]])&#123; p0=t[0][p0][0]; p1=t[1][p1][1]; val[0][p0]--; val[1][p1]--; ans+=(1&lt;&lt;i); &#125; else if(val[0][t[0][p0][1]] &amp;&amp; val[1][t[1][p1][0]])&#123; p0=t[0][p0][1]; p1=t[1][p1][0]; val[0][p0]--; val[1][p1]--; ans+=(1&lt;&lt;i); &#125; &#125; return ans;&#125;int ans[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n;scanf("%d",&amp;n); tot[0]=tot[1]=0; t[0][0][0] = t[0][0][1] = 0; t[1][0][0] = t[1][0][1] = 0; int x; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;x); Insert(0,x); &#125; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;x); Insert(1,x); &#125; for(int i=0;i&lt;n;i++)&#123; ans[i]=query(); &#125; sort(ans,ans+n); for(int i=0;i&lt;n;i++)&#123; printf("%d%c",ans[i],i==n-1?'\n':' '); &#125; &#125;&#125; 第六场1002-Nonsense Time 题意：给出一个全排列，初始全部不可用，n步操作，每次恢复排列中一个数，问每一步后的序列LIS长度 思路：因为数据随机，期望LIS长度为sqrt(n)，考虑反向操作，先直接找出一个LIS，然后倒着删除某个数，如果当前数不在LIS中，那么答案不变；否则需要更新LIS。期望重找LIS的次数也就sqrt(n)次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e4+5;int a[maxn],b[maxn],ans[maxn];vector&lt;int&gt;p;bool vis[maxn];int dp[maxn],pos[maxn],seq[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; memset(vis,0,sizeof(vis)); int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;b[i]); int len=0; for(int i=1;i&lt;=n;i++)&#123; if(len==0||a[i]&gt;dp[len])&#123; dp[++len]=a[i]; pos[i]=len; &#125; else&#123; *(lower_bound(dp+1,dp+1+len,a[i])) = a[i]; pos[i] = lower_bound(dp+1,dp+1+len,a[i]) - dp; &#125; &#125; int t=len; for(int i=n;i&gt;=1;i--)&#123; if(pos[i]==t)&#123; seq[t--]=a[i]; &#125; if(!t) break; &#125; p.clear(); for(int i=1;i&lt;=len;i++)&#123; p.push_back(seq[i]); &#125; ans[n] = p.size(); for(int i=n-1;i&gt;=1;i--)&#123; int x = a[b[i+1]]; vis[b[i+1]]=1; if(!binary_search(p.begin(),p.end(),x)) ans[i]=ans[i+1]; else&#123; len=0; for(int i=1;i&lt;=n;i++)&#123; if(vis[i]) continue; if(len==0||a[i]&gt;dp[len])&#123; dp[++len]=a[i]; pos[i]=len; &#125; else&#123; *(lower_bound(dp+1,dp+1+len,a[i])) = a[i]; pos[i] = lower_bound(dp+1,dp+1+len,a[i]) - dp; &#125; &#125; int t=len; for(int i=n;i&gt;=1;i--)&#123; if(vis[i]) continue; if(pos[i]==t) seq[t--]=a[i]; if(!t) break; &#125; p.clear(); for(int i=1;i&lt;=len;i++)&#123; p.push_back(seq[i]); &#125; ans[i] = p.size(); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; printf("%d%c",ans[i],i==n?'\n':' '); &#125; &#125;&#125; 1005-Snowy Smile 题意：给n个点，每个点带点权，问用一个边平行于坐标轴的矩形去框，所得最大点权和为多少 思路：因为点的范围较大，首先离散化，使得所有点落入范围为n*n的矩阵内，然后考虑枚举所有子矩阵，朴素枚举时间复杂度O(n^4)，考虑只枚举上下边界，然后把每一列的点权和看成一个数，再求当前上下边界的最大子段和即为一个矩阵内的最大点权和。点按y从小到大排序，就可以不断加点线段树动态维护区间子段和了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define ls o&lt;&lt;1#define rs o&lt;&lt;1|1#define lson l,mid,ls#define rson mid+1,r,rsusing namespace std;typedef long long ll;const int maxn = 2e3+5;struct Point&#123; int x,y; ll w; bool operator &lt; (const Point &amp;hs)const&#123; if(y!=hs.y) return y&lt;hs.y; return x&lt;hs.x; &#125;&#125;p[maxn];ll sum[maxn&lt;&lt;2],lsum[maxn&lt;&lt;2],rsum[maxn&lt;&lt;2],msum[maxn&lt;&lt;2];void push_up(int o)&#123; sum[o] = sum[ls] + sum[rs]; msum[o] = max(max(msum[ls],msum[rs]),rsum[ls]+lsum[rs]); lsum[o] = max(lsum[ls],sum[ls]+lsum[rs]); rsum[o] = max(rsum[rs],sum[rs]+rsum[ls]);&#125;void build(int l,int r,int o)&#123; sum[o]=lsum[o]=rsum[o]=msum[o]=0; if(l==r) return; int mid = (l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;void update(int p,int v,int l,int r,int o)&#123; if(l==r)&#123; sum[o]+=v; lsum[o]=rsum[o]=msum[o]=sum[o]; return; &#125; int mid = (l+r)&gt;&gt;1; if(p&lt;=mid) update(p,v,lson); else update(p,v,rson); push_up(o);&#125;vector&lt;int&gt;X,Y;vector&lt;int&gt;from[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; X.clear(); Y.clear(); int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d%d%lld",&amp;p[i].x,&amp;p[i].y,&amp;p[i].w); X.push_back(p[i].x); Y.push_back(p[i].y); &#125; sort(X.begin(),X.end()); X.erase(unique(X.begin(),X.end()),X.end()); sort(Y.begin(),Y.end()); Y.erase(unique(Y.begin(),Y.end()),Y.end()); int Mx=0,My=0; for(int i=0;i&lt;n;i++)&#123; p[i].x=lower_bound(X.begin(),X.end(),p[i].x)-X.begin()+1; p[i].y=lower_bound(Y.begin(),Y.end(),p[i].y)-Y.begin()+1; Mx=max(Mx,p[i].x); My=max(My,p[i].y); &#125; sort(p,p+n); for(int i=1;i&lt;=My;i++) from[i].clear(); for(int i=0;i&lt;n;i++) from[p[i].y].push_back(i); ll ans=0; for(int down=1;down&lt;=My;down++)&#123; build(1,Mx,1); for(int up=down;up&lt;=My;up++)&#123; for(int i=0;i&lt;from[up].size();i++)&#123; int j=from[up][i]; update(p[j].x,p[j].w,1,Mx,1); &#125; ans=max(ans,msum[1]); &#125; &#125; printf("%lld\n",ans); &#125;&#125; 第七场A- A + B = C 题意：a⋅10^x+b⋅10^y=c⋅10^z，给出a,b,c求x,y,z 思路：先将a,b,c尾巴补零补到相同长度，然后分四种情况枚举，对于每一种相加结果判断是否相等用hash直接判 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e6+5;typedef unsigned long long ull;const int mod = 998244353;ull base=10;ull p[maxn],hs[3][maxn]; ull geths(ull h[],int l,int r)&#123; return (ull)((h[r]-(p[r-l+1]*h[l-1]%mod)+mod)%mod);&#125;char a[maxn],b[maxn],c[maxn];int main()&#123; p[0]=1; for(int i=1;i&lt;maxn;i++)&#123; p[i]=(p[i-1]*base)%mod; &#125; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%s%s%s",a+1,b+1,c+1); int lena=strlen(a+1); int lenb=strlen(b+1); int lenc=strlen(c+1); int mlen = max(lena+lenb,lenc); mlen=min(mlen,1000000); hs[0][1]=hs[1][1]=hs[2][1]=0; for(int i=1;i&lt;=lena;i++) hs[0][i]=(hs[0][i-1]*base%mod+a[i]-'0')%mod; for(int i=lena+1;i&lt;=mlen;i++) hs[0][i]=(hs[0][i-1]*base%mod)%mod; for(int i=1;i&lt;=lenb;i++) hs[1][i]=(hs[1][i-1]*base%mod+b[i]-'0')%mod; for(int i=lenb+1;i&lt;=mlen;i++) hs[1][i]=(hs[1][i-1]*base%mod)%mod; for(int i=1;i&lt;=lenc;i++) hs[2][i]=(hs[2][i-1]*base%mod+c[i]-'0')%mod; for(int i=lenc+1;i&lt;=mlen;i++) hs[2][i]=(hs[2][i-1]*base%mod)%mod; ull ans = geths(hs[2],1,mlen); ull aa = geths(hs[0],1,mlen),bb,cc; bool ok=false; int x,y,z=mlen-lenc+1; for(int i=lenb;i&lt;=mlen;i++)&#123; bb = geths(hs[1],1,i); if((aa+bb)%mod==ans)&#123; ok=true; x=mlen-lena+1; y=i-lenb+1; break; &#125; &#125; if(!ok)&#123; bb = geths(hs[1],1,mlen); for(int i=lena;i&lt;=mlen;i++)&#123; aa = geths(hs[0],1,i); if((aa+bb)%mod==ans)&#123; ok=true; x=i-lena+1; y=mlen-lenb+1; break; &#125; &#125; &#125; if(!ok)&#123; aa = geths(hs[0],1,mlen-1); for(int i=lenb;i&lt;=mlen-1;i++)&#123; bb = geths(hs[1],1,i); if((aa+bb)%mod==ans)&#123; ok=true; x=mlen-lena; y=i-lenb+1; break; &#125; &#125; &#125; if(!ok)&#123; bb = geths(hs[1],1,mlen-1); for(int i=lena;i&lt;=mlen-1;i++)&#123; aa = geths(hs[0],1,i); if((aa+bb)%mod==ans)&#123; ok=true; x=i-lena+1; y=mlen-lenb; break; &#125; &#125; &#125; if(!ok) puts("-1"); else printf("%d %d %d\n",x,y,z); &#125;&#125; F-Final Exam 题意：有n个题，总分m分，每做出一道题需要这道题的分数+1的时间，问做出k题需要至少多少的时间准备 思路：因为事先不知道每道题的分数分布，那就要按最坏情况看待；田忌赛马的博弈 1234567891011#include&lt;bits/stdc++.h&gt;typedef long long ll;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; ll n,m,k; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); printf("%lld\n",(m/(n-k+1) +1)*(k-1)+(m+1)); &#125;&#125; J-Just Repeat 题意：两个人打牌，每个人有一些种类的牌，如果一个人出了一张对面也有的牌类，那对面这种牌类的牌就不能打出来，最后谁无法出牌谁就输了，问谁最后会赢 思路：统计两个人都有的牌类的张数，既然要对面输，就都会先把出现次数最多的牌类打出来，这样使得我手中的牌可以打出的更多或者对面手里牌打出的更少了，最后看不是相同剩余的牌谁能出的多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#include&lt;ext/pb_ds/assoc_container.hpp&gt;#include&lt;ext/pb_ds/hash_policy.hpp&gt;using namespace __gnu_pbds;gp_hash_table&lt;int,int&gt; hsa, hsb;const int maxn = 1e6 + 5;unsigned long long k1, k2;int mod;unsigned long long rng() &#123; unsigned long long k3 = k1, k4 = k2; k1 = k4; k3 ^= k3 &lt;&lt; 23; k2 = k3 ^ k4 ^ (k3 &gt;&gt; 17) ^ (k4 &gt;&gt; 26); return k2 + k4;&#125;struct node&#123; int a,b; node()&#123;&#125; node(int a,int b):a(a),b(b)&#123;&#125; bool operator &lt; (const node &amp;hs)const&#123; return a&lt;hs.a; &#125;&#125;;int n, m, p;int b[maxn], a[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; hsa.clear(); hsb.clear(); scanf("%d %d %d", &amp;n, &amp;m, &amp;p); if(p == 1) &#123; for(int i=1;i&lt;=n;i++) scanf("%d", &amp;a[i]); for(int i=1;i&lt;=m;i++) scanf("%d", &amp;b[i]); &#125; else &#123; scanf("%llu %llu %d", &amp;k1, &amp;k2, &amp;mod); for (int i = 1; i &lt;= n; ++i) a[i] = rng() % mod; scanf("%llu %llu %d", &amp;k1, &amp;k2, &amp;mod); for (int i = 1; i &lt;= m; ++i) b[i] = rng() % mod; &#125; int ansa = n, ansb = m; for(int i=1;i&lt;=n;i++)&#123; hsa[a[i]]++; &#125; for(int i=1;i&lt;=m;i++)&#123; hsb[b[i]]++; &#125; sort(a+1, a+1+n); int cnta=unique(a+1,a+n+1)-a-1; priority_queue&lt;node&gt; pq; for(int i=1;i&lt;=cnta;++i)&#123; if(hsa[a[i]] &amp;&amp; hsb[a[i]]) pq.push(node(hsa[a[i]]+hsb[a[i]],a[i])), ansa-=hsa[a[i]], ansb-=hsb[a[i]]; &#125; int t = 0; while(pq.size())&#123; node pp = pq.top(); pq.pop(); if(!t)&#123; ansa += hsa[pp.b] - 1; &#125;else &#123; ansb += hsb[pp.b] - 1; &#125; t ^= 1; &#125; if(t) ansb--; if(ansa &gt; ansb) puts("Cuber QQ"); else puts("Quber CC"); &#125;&#125; 第八场D-Acesrc and Hunting 题意：给一个n*m的矩阵，问能否构造出一条任意起点的路径，使得不经过重复点且任意两步之间欧几里得距离大于1且小于3 思路：划几个图就能找出一条一定能走出来的路线，但是要注意一些特判 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 105;int n,m;void pr(int x,int y)&#123; printf("%d %d\n",x,y);&#125;void solve()&#123; puts("YES"); for(int i=n;i&gt;=3;i--)&#123; if(i&amp;1) for(int j=m&amp;1?m:m-1;j&gt;=1;j-=2) pr(i,j); else for(int j=2;j&lt;=m;j+=2) pr(i,j); &#125; pr(1,1); for(int j=2;j&lt;=m;j+=2) pr(2,j); for(int j=m&amp;1?m:m-1;j&gt;=2;j-=2) pr(1,j); for(int j=1;j&lt;=m;j++) pr((j&amp;1)?2:1,j); for(int i=3;i&lt;=n;i++)&#123; if(i&amp;1) for(int j=m&amp;1?m-1:m;j&gt;=2;j-=2) pr(i,j); else for(int j=1;j&lt;=m;j+=2) pr(i,j); &#125;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); if(n==1&amp;&amp;m==1)&#123; puts("YES"); pr(1,1); continue; &#125; if(n==1||m==1||(n==2&amp;&amp;m==2))&#123; puts("NO"); continue; &#125; if(m==2)&#123; puts("YES"); if(n&amp;1)&#123; for(int i=1;i&lt;=n;i++) pr(i,(i&amp;1)?1:2); for(int i=n-2;i&gt;=1;i-=2) pr(i,2); for(int i=2;i&lt;=n;i+=2) pr(i,1); pr(n,2); &#125; else&#123; for(int i=1;i&lt;=n;i++) pr(i,(i&amp;1)?1:2); for(int i=n-2;i&gt;=1;i-=2) pr(i,1); for(int i=1;i&lt;=n;i+=2) pr(i,2); pr(n,1); &#125; continue; &#125; solve(); &#125;&#125; J-Calabash and Landlord 题意：给出两个坐标范围很大矩形，问无穷大平面有多少块区域是属于不同的联通块 思路：一是直接枚举所有情况，当然两矩形的情况不多，用相交之后共有的小矩形看有多少共边比较好写； 二是直接离散化这几个点，把区域缩成很小的一块然后爆搜 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158//思路一#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e6+5;struct rec&#123; int a,b,c,d;&#125;r[5];vector&lt;int&gt;v[2];void calc(rec A,rec B,int op)&#123; if(A.a==B.a) v[op].push_back(1); if(A.b==B.b) v[op].push_back(3); if(A.c==B.c) v[op].push_back(2); if(A.d==B.d) v[op].push_back(4);&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; for(int i=1;i&lt;=2;i++)&#123; scanf("%d%d%d%d",&amp;r[i].a,&amp;r[i].c,&amp;r[i].b,&amp;r[i].d); &#125; int x1=r[1].a,x2=r[1].b,y1=r[1].c,y2=r[1].d; int x3=r[2].a,x4=r[2].b,y3=r[2].c,y4=r[2].d; int a,b,c,d; a=max(min(x1,x2),min(x3,x4)); b=min(max(x1,x2),max(x3,x4)); c=max(min(y1,y2),min(y3,y4)); d=min(max(y1,y2),max(y3,y4)); r[0].a = a;r[0].b = b;r[0].c = c;r[0].d = d; int ans; if(a&gt;=b||c&gt;=d) ans=3; else&#123; v[0].clear(); v[1].clear(); calc(r[0],r[1],0); calc(r[0],r[2],1); int num[2][5]=&#123;0&#125;; int sum0=0,sum1=0; for(int i=0;i&lt;(int)v[0].size();i++)&#123; num[0][v[0][i]]++; sum0+=v[0][i]; &#125; for(int i=0;i&lt;(int)v[1].size();i++)&#123; num[1][v[1][i]]++; sum1+=v[1][i]; &#125; int t1=0,t0=0; for(int i=1;i&lt;=4;i++)&#123; if(num[0][i]) t0++; if(num[1][i]) t1++; &#125; //printf("~~~~~~~~~~ %d %d\n",t0,t1); if(t0==t1 &amp;&amp; t0==4) ans=2; else if(t0==4 || t1==4) &#123; if(t1==2) &#123; if(sum1&amp;1) ans = 3; else ans = 4; &#125; else if(t0 == 2) &#123; if(sum0&amp;1) ans = 3; else ans = 4; &#125; else ans = 3; &#125; else if(t0==3 &amp;&amp; t1==3) ans=4; else if(t0==3 || t1==3) &#123; if(t0 == 3) &#123; if(t1 == 1) ans =4; else if(sum1&amp;1) ans=4; else ans = 5; &#125; else &#123; if(t0 == 1) ans =4; else if(sum0&amp;1) ans=4; else ans = 5; &#125; &#125; else&#123; if(sum0&amp;1) ans=4; else ans=6; &#125; &#125; printf("%d\n",ans); &#125;&#125;//思路二#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define debug(x) cerr&lt;&lt;#x"="&lt;&lt;x&lt;&lt;'\n'; using namespace std;typedef long long ll;const int maxn = 15;bool vis[maxn][maxn];int mat[maxn][maxn];vector&lt;int&gt;X,Y;int go[4][2]=&#123;-1,0,1,0,0,-1,0,1&#125;;void dfs(int x,int y)&#123; vis[x][y]=1; for(int i=0;i&lt;4;i++)&#123; int nx=x+go[i][0]; int ny=y+go[i][1]; if(nx&gt;=1 &amp;&amp; nx&lt;=10 &amp;&amp;ny&gt;=1 &amp;&amp;ny&lt;=10 &amp;&amp; !vis[nx][ny] &amp;&amp;mat[nx][ny]==mat[x][y])&#123; dfs(nx,ny); &#125; &#125;&#125;struct node&#123; int x,y;&#125;p[5];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; X.clear(); Y.clear(); memset(mat,0,sizeof(mat)); memset(vis,0,sizeof(vis)); for(int i=0;i&lt;4;i++)&#123; scanf("%d%d",&amp;p[i].x,&amp;p[i].y); X.push_back(p[i].x); Y.push_back(p[i].y); &#125; sort(X.begin(),X.end()); X.erase(unique(X.begin(),X.end()),X.end()); sort(Y.begin(),Y.end()); Y.erase(unique(Y.begin(),Y.end()),Y.end()); for(int i=0;i&lt;4;i++)&#123; p[i].x = lower_bound(X.begin(),X.end(),p[i].x)-X.begin()+1; p[i].y = lower_bound(Y.begin(),Y.end(),p[i].y)-Y.begin()+1; //printf("%d %d %d\n",i,p[i].x,p[i].y); &#125; for(int i=0;i&lt;4;i+=2)&#123; int flag = i+1; for(int x=p[i].x;x&lt;p[i+1].x;x++)&#123; for(int y=p[i].y;y&lt;p[i+1].y;y++)&#123; mat[x][y] += flag; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=10;i++)&#123; for(int j=1;j&lt;=10;j++)&#123; if(vis[i][j] || !mat[i][j])continue; dfs(i,j); ans++; &#125; &#125; printf("%d\n",ans+1); &#125;&#125; 第九场B-Rikka with Cake 题意：求平面线段交点个数 思路：线段按y排序后枚举每条线段更新线段树or树状数组，单点更新and区间查询 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e6+5;struct seg&#123; int x1,x2,y; int v; seg()&#123;&#125; seg(int x1,int x2,int y,int v):x1(x1),x2(x2),y(y),v(v)&#123;&#125; bool operator &lt; (const seg&amp;hs)const&#123; if(y==hs.y) return v&gt;hs.v; return y&lt;hs.y; &#125;&#125;e[maxn];int d[maxn];int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int v,int n)&#123; while(x&lt;=n)&#123; d[x]+=v; x += lowbit(x); &#125;&#125;int sum(int x)&#123; int ret=0; while(x&gt;0)&#123; ret+=d[x]; x -= lowbit(x); &#125; return ret;&#125;vector&lt;int&gt;X,Y;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; X.clear(); Y.clear(); int n,m,k; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); int x1,y1,x2,y2; char op[5]; int cnt=0; for(int i=1;i&lt;=k;i++)&#123; scanf(&quot;%d%d%s&quot;,&amp;x1,&amp;y1,op); if(op[0]==&apos;L&apos;) x2=1,y2=y1; if(op[0]==&apos;R&apos;) x2=n,y2=y1; if(op[0]==&apos;U&apos;) x2=x1,y2=m; if(op[0]==&apos;D&apos;) x2=x1,y2=1; X.push_back(x1);X.push_back(x2); Y.push_back(y1);Y.push_back(y2); if(x1==x2)&#123; if(y1&gt;y2) swap(y1,y2); e[cnt++]=seg(x1,x1,y1,1); e[cnt++]=seg(x1,x1,y2,-1); &#125; if(y1==y2)&#123; if(x1&gt;x2) swap(x1,x2); e[cnt++]=seg(x1,x2,y1,0); &#125; &#125; sort(X.begin(),X.end()); X.erase(unique(X.begin(),X.end()),X.end()); sort(Y.begin(),Y.end()); Y.erase(unique(Y.begin(),Y.end()),Y.end()); for(int i=0;i&lt;cnt;i++)&#123; e[i].x1 = lower_bound(X.begin(),X.end(),e[i].x1) - X.begin()+1; e[i].x2 = lower_bound(X.begin(),X.end(),e[i].x2) - X.begin()+1; e[i].y = lower_bound(Y.begin(),Y.end(),e[i].y) - Y.begin()+1; &#125; sort(e,e+cnt); // for(int i=0;i&lt;cnt;i++)&#123; // printf(&quot;%d %d %d %d\n&quot;,e[i].x1,e[i].x2,e[i].y,e[i].v); // &#125; int nx = X.size(); for(int i=1;i&lt;=nx+5;i++) d[i]=0; ll ans=0; for(int i=0;i&lt;cnt;i++)&#123; //printf(&quot;%d %d %d\n&quot;,e[i].x1,e[i].x2,e[i].v); if(e[i].v == 0)&#123; ans += sum(e[i].x2)-sum(e[i].x1-1); &#125; else&#123; add(e[i].x1,e[i].v,nx); &#125; &#125; printf(&quot;%lld\n&quot;,ans+1); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>hash</tag>
        <tag>PAM</tag>
        <tag>主席树</tag>
        <tag>找规律</tag>
        <tag>trie</tag>
        <tag>LIS</tag>
        <tag>最大子段和</tag>
        <tag>博弈</tag>
        <tag>构造</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营 补题日志]]></title>
    <url>%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E8%A1%A5%E9%A2%98%E6%97%A5%E5%BF%97.html</url>
    <content type="text"><![CDATA[留点曾经被搞自闭的印象 第一场A-Equivalent Prefixes 题意：给定两个n长整数序列，每个序列不会出现重复元素，问最长的p使得[1,p]区间内的任意子区间都满足[l,r]中的最小值的位置相同 思路：二分答案，对于每个长度递归验证合法性，查询区间最值线段树或ST表维护，总时间复杂度O(nlognlogn) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5+5;int n;int a[maxn],b[maxn];int posa[maxn],posb[maxn];int Mina[maxn&lt;&lt;2],Minb[maxn&lt;&lt;2];void push_up(int o)&#123; Mina[o]=min(Mina[o&lt;&lt;1],Mina[o&lt;&lt;1|1]); Minb[o]=min(Minb[o&lt;&lt;1],Minb[o&lt;&lt;1|1]);&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; Mina[o]=a[l]; Minb[o]=b[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;int query(int k,int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; if(k==1) return Mina[o]; else return Minb[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=INF; if(L&lt;=mid) ret=min(ret,query(k,L,R,lson)); if(R&gt;mid) ret=min(ret,query(k,L,R,rson)); return ret;&#125; bool pd(int l,int r)&#123; if(l&gt;=r) return true; int mina = query(1,l,r,1,n,1); int minb = query(2,l,r,1,n,1); if(posa[mina]!=posb[minb]) return false; int mid = posa[mina]; return pd(l,mid-1)&amp;&amp;pd(mid+1,r);&#125; int main()&#123; while(~scanf("%d",&amp;n))&#123; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); posa[a[i]]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;b[i]); posb[b[i]]=i; &#125; build(1,n,1); int l=1,r=n; while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(pd(1,mid)) l=mid; else r=mid-1; &#125; printf("%d\n",l); &#125;&#125; E-ABBA 题意：有n个”AB”和m个”BA”是由2(n+m)长的字符串中取出的子序列得到，问原字符串有多少种构造可能 思路：dp[i][j]表示当前前缀有i个’A’和j个’B’的合法情况种数，根据合法性再进行转移，dp[n+m][n+m]即为答案 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 2e3+5;const int P = 1e9+7;int f[maxn][maxn];int main() &#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; for(int i=0;i&lt;=n+m;i++)&#123; for(int j=0;j&lt;=n+m;j++)&#123; f[i][j]=0; &#125; &#125; //f[i][j] 表示当前前缀有i个'A'和j个'B'的合法序列种类数 f[0][0]=1; for(int i=0; i&lt;=n+m; i++) &#123; for(int j=0; j&lt;=n+m; j++) &#123; if(i+1&lt;=n || i-n+1&lt;=j) &#123;//AB的A少了或者BA的A少了 f[i+1][j]=(f[i][j]+f[i+1][j])%P; &#125; if(j+1&lt;=m || j-m+1&lt;=i) &#123;//BA的B少了或者AB的B少了 f[i][j+1]=(f[i][j]+f[i][j+1])%P; &#125; &#125; &#125; printf("%d\n",f[n+m][n+m]); &#125;&#125; 第二场D-Kth Minimum Clique 题意：RT,求一张图的第K小团 思路：N最大100，每个团内要求每个点与其他点都有边相连，那么可以对起始每个点作为一个最小独立团进行bfs加点扩大，当新的点满足与当前团内所有点都有边的时候加入该团，bitset标记团内选点和边，K最大1e6，按团的权值出队列最多跑K次，第K次出队列的即为第K小的团，然后每个团记录团内最大结点的id，避免跑出重复的团 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 100+5;struct node&#123; int id; ll w; bitset&lt;maxn&gt;sta; node()&#123;&#125; node(int i,ll w,bitset&lt;maxn&gt;s):id(i),w(w),sta(s)&#123;&#125; bool operator &lt; (const node&amp;hs)const&#123; return w&gt;hs.w; &#125;&#125;;ll w[maxn];bitset&lt;maxn&gt;e[maxn]; int n,k;ll bfs()&#123; if(k==1) return 0; bitset&lt;maxn&gt;sta; priority_queue&lt;node&gt; pq; k--; for(int i=1;i&lt;=n;i++)&#123; sta[i]=1; pq.push(node(i,w[i],sta)); sta[i]=0; &#125; node now; while(!pq.empty())&#123; now = pq.top(); pq.pop(); k--; if(k==0) return now.w; for(int i=now.id+1;i&lt;=n;i++)&#123; if((e[i]&amp;now.sta)==now.sta)&#123; now.sta[i]=1; pq.push(node(i,now.w+w[i],now.sta)); now.sta[i]=0; &#125; &#125; &#125; return -1;&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;w[i]); &#125; char s[maxn][maxn]; for(int i=1;i&lt;=n;i++)&#123; scanf("%s",s[i]+1); for(int j=1;j&lt;=n;j++)&#123; e[i][j]=s[i][j]-'0'; &#125; &#125; printf("%lld\n",bfs());&#125; F-Partition problem 题意：2N个人需要分成两个N人的队，任意两个来自不同队的人配对有个value，求所有队员分别配对后的最大value和 思路：起始将2N个人都放在一队，2^2N枚举哪些人被分到了二队，如果第i个人被调到二队，算代价只需O(n)计算第i个人对整体value和的变化，注意剪枝 123456789101112131415161718192021222324252627282930313233343536373839404142434445#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 30;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n;int vis[30];ll ans,v[maxn][maxn]; void dfs(int i,int cnt,ll sum)&#123; if(cnt==n)&#123; ans=max(ans,sum); return; &#125; if(i-cnt&gt;n) return; //剪枝 前面有i-cnt&gt;n个人在一队肯定不行 //不动 dfs(i+1,cnt,sum); //移到另一队 ll tmp=0; for(int j=1;j&lt;=2*n;j++)&#123; if(!vis[j]) tmp+=v[i][j]; else tmp-=v[i][j]; &#125; vis[i]=1; dfs(i+1,cnt+1,sum+tmp); vis[i]=0;&#125; int main()&#123; n=read(); for(int i=1;i&lt;=2*n;i++)&#123; for(int j=1;j&lt;=2*n;j++)&#123; v[i][j]=read(); &#125; &#125; dfs(1,0,0); printf("%lld\n",ans);&#125; H-Second Large Rectangle 题意：给出一个n*m的只包含01的矩阵，求第二大的只含1的子矩阵大小 思路：对于求第一大，单调栈维护以当前行为底和包含每一列矩阵的左边界和右边界，就可以求出所有可能的最大矩形；对于求第二大，因为有可能是第一大缩小单位宽或者单位高，也可能是和第一大面积相等但位置不同，所以把全部可能情况排序去重查找即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e3+5;struct rec&#123; int h,w,x,y,s; bool operator &lt; (const rec&amp;hs)const&#123; return s&lt;hs.s; &#125; bool operator == (const rec&amp;hs)const&#123; return h==hs.h&amp;&amp;w==hs.w&amp;&amp;x==hs.x&amp;&amp;y==hs.y&amp;&amp;s==hs.s; &#125;&#125;a[maxn*maxn*3]; char mp[maxn][maxn];int h[maxn],L[maxn],R[maxn];int main() &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf("%s",mp[i]+1); &#125; int cnt=0; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; if(mp[i][j]=='1') h[j]++; else h[j]=0; &#125; for(int j=1; j&lt;=m; j++) &#123; L[j]=j; while(L[j]&gt;1&amp;&amp;h[j]&lt;=h[L[j]-1]) L[j]=L[L[j]-1]; &#125; for(int j=m; j&gt;=1; j--) &#123; R[j]=j; while(R[j]&lt;m&amp;&amp;h[j]&lt;=h[R[j]+1]) R[j]=R[R[j]+1]; &#125; for(int j=1;j&lt;=m;j++)&#123; int hh=h[j],ww=R[j]-L[j]+1,x=i,y=L[j],s=hh*ww; a[cnt++]=rec&#123;hh,ww,x,y,s&#125;; a[cnt++]=rec&#123;hh-1,ww,x,y,s-ww&#125;; a[cnt++]=rec&#123;hh,ww-1,x,y,s-hh&#125;; &#125; &#125; sort(a,a+cnt); for(int i=cnt-1;i&gt;=0;i--)&#123; if(!(a[i]==a[i-1]))&#123; printf("%d\n",a[i-1].s); break; &#125; &#125;&#125; 第三场F-Planting Trees 题意：求一个最大矩阵面积，使得其中最大值-最小值&lt;=M 思路：看那些猛男都是剪枝+二维ST表也可以过的，我就不行了，n^4优化不来 正解是枚举小矩阵的上下边界，再枚举右边界的时候用两个单调队列维护影响当前列的最值，就可以O(n)求出每列的最大左边界 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e3+5;int a[maxn][maxn];int mi[maxn],mx[maxn];//在up down上下边界中每一列的最值int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,M; scanf("%d%d",&amp;n,&amp;M); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; scanf("%d",&amp;a[i][j]); &#125; &#125; int ans=1; for(int up=1;up&lt;=n;up++)&#123; for(int j=1;j&lt;=n;j++) mi[j]=INF,mx[j]=-INF; for(int down=up;down&lt;=n;down++)&#123; for(int j=1;j&lt;=n;j++)&#123; mi[j]=min(mi[j],a[down][j]); mx[j]=max(mx[j],a[down][j]); &#125; deque&lt;int&gt;q1,q2;//单调递减和单调递增队列维护前面列影响第r列的最值 int l=0; for(int r=1;r&lt;=n;r++)&#123; while(!q1.empty()&amp;&amp;mx[r]&gt;mx[q1.back()]) q1.pop_back(); q1.push_back(r); while(!q2.empty()&amp;&amp;mi[r]&lt;mi[q2.back()]) q2.pop_back(); q2.push_back(r); while(!q1.empty()&amp;&amp;!q2.empty()&amp;&amp;mx[q1.front()]-mi[q2.front()]&gt;M)&#123; l++; if(q1.front()&lt;=l) q1.pop_front(); if(q2.front()&lt;=l) q2.pop_front(); &#125; ans=max(ans,(down-up+1)*(r-l)); if(ans&gt;(down-up+1)*(n-l)) break; //剪枝 &#125; &#125; &#125; printf("%d\n",ans); &#125;&#125; J-LRU management 题意：模拟LRU调度算法 思路：STL瞎搞，pbds大法好 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#pragma GCC optimize(2)#include&lt;ext/pb_ds/assoc_container.hpp&gt;#include&lt;ext/pb_ds/hash_policy.hpp&gt;//用hashusing namespace __gnu_pbds;#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; string s; int v; node() &#123;&#125;; node(string s,int v): s(s), v(v) &#123;&#125;&#125;;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); int q,m,t; cin&gt;&gt;t; while(t--) &#123; list&lt;node&gt; L; gp_hash_table&lt;string,list&lt;node&gt;::iterator&gt; mp; cin&gt;&gt;q&gt;&gt;m; while(q--) &#123; int op,v; string s; cin&gt;&gt;op&gt;&gt;s&gt;&gt;v; if(op==0) &#123; if(mp.find(s)!=mp.end()) &#123; auto it = mp[s]; v = it-&gt;v; L.erase(it); &#125; L.push_back(node(s,v)); mp[s]=prev(L.end()); cout&lt;&lt;v&lt;&lt;'\n'; if(L.size()&gt;m) &#123; mp.erase(L.begin()-&gt;s); L.erase(L.begin()); &#125; &#125; else &#123; if(mp.find(s)==mp.end()) &#123; cout&lt;&lt;"Invalid"&lt;&lt;'\n'; &#125; else &#123; auto pos=mp[s]; if((pos==L.begin()&amp;&amp;v==-1)||(pos==prev(L.end())&amp;&amp;v==1)) cout&lt;&lt;"Invalid"&lt;&lt;'\n'; else &#123; if(v==1) pos=next(pos); if(v==-1) pos=prev(pos); cout&lt;&lt;pos-&gt;v&lt;&lt;'\n'; &#125; &#125; &#125; &#125; &#125;&#125; 第四场C-sequence 题意：相当于求一段区间的最小值*区间和最大值 思路：对于每个a[i]，它作为最小值的区间可用单调栈O(n)处理出左边界L[i]和右边界R[i]，算答案就有两种情况： 一是a[i]&gt;=0，那么a[i]作为最小值的区间都是非负数，区间和最大即是整个区间和； 二是a[i]&lt;0，那么区间和就要尽可能小，用[i,R[i]]的最小前缀和减去[L[i],i]的最大前缀和可以使得包含a[i]的区间和最小，答案最优，线段树维护前缀和区间最值即可，3e6的数据范围ST表显然空间不够，题解怎么做到的？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define ls o&lt;&lt;1#define rs o&lt;&lt;1|1#define lson l,mid,ls#define rson mid+1,r,rs#define INF 0x3f3f3f3f3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 3e6+5;int n;ll a[maxn],b[maxn];int L[maxn],R[maxn];ll sum[maxn],Max[maxn&lt;&lt;2],Min[maxn&lt;&lt;2];void push_up(int o)&#123; Max[o]=max(Max[ls],Max[rs]); Min[o]=min(Min[ls],Min[rs]);&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; Max[o]=Min[o]=sum[l]; return; &#125; int mid = (l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;ll querymax(int L,int R,int l=1,int r=n,int o=1)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Max[o]; &#125; int mid = (l+r)&gt;&gt;1; ll ret = -INF; if(L&lt;=mid) ret=max(ret,querymax(L,R,lson)); if(R&gt;mid) ret=max(ret,querymax(L,R,rson)); return ret;&#125;ll querymin(int L,int R,int l=1,int r=n,int o=1)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Min[o]; &#125; int mid = (l+r)&gt;&gt;1; ll ret = INF; if(L&lt;=mid) ret=min(ret,querymin(L,R,lson)); if(R&gt;mid) ret=min(ret,querymin(L,R,rson)); return ret;&#125; int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;b[i]); sum[i]=sum[i-1]+b[i]; &#125; build(1,n,1); deque&lt;int&gt;q; a[0]=a[n+1]=-INF; for(int i=1;i&lt;=n+1;i++)&#123; while(!q.empty()&amp;&amp;a[i]&lt;a[q.back()])&#123; R[q.back()]=i-1; q.pop_back(); &#125; q.push_back(i); &#125; q.clear(); for(int i=n;i&gt;=0;i--)&#123; while(!q.empty()&amp;&amp;a[i]&lt;a[q.back()])&#123; L[q.back()]=i+1; q.pop_back(); &#125; q.push_back(i); &#125; ll ans=0; for(int i=1;i&lt;=n;i++)&#123; if(a[i]&gt;=0)&#123; ans=max(ans,a[i]*(sum[R[i]]-sum[L[i]-1])); &#125; else&#123; ans=max(ans,a[i]*(querymin(i,R[i])-querymax(L[i],i))); &#125; &#125; printf("%lld\n",ans);&#125; I-string 题意：给出一个字符串，求其最大子串集合大小，子串集合中满足无重复串和翻转相同串 思路：把原串反过来拼接到原串后面，中间用特殊符号隔开，统计这时所有的子串数-含有特殊字符的字符串数，理论上原串的子串数都会增加一倍，但因为有回文串和翻转相同串的存在会使得新增子串并没有那么多，此时加上原串不同本质回文子串数就使得原串中每个子串又有一个翻转串对应，/2即为答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6 + 5;const int N = 27;struct SAM&#123; int tot, last, ch[maxn &lt;&lt; 1][N], fa[maxn &lt;&lt; 1], len[maxn &lt;&lt; 1]; int Tr(char c)&#123;return c - 'a';&#125; int val(int c)&#123;return len[c] - len[fa[c]];&#125; void init() &#123; last = tot = 1; len[1] = 0; memset( ch[1], 0, sizeof ch[1]); &#125; void add(int x) &#123; int p = last, np = last = ++tot; len[np] = len[p] + 1, cnt[last] = 1; memset( ch[np], 0, sizeof ch[np]); while( p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = fa[p]; if( p == 0) fa[np] = 1; else &#123; int q = ch[p][x]; if( len[q] == len[p] + 1) fa[np] = q; else &#123; int nq = ++tot; memcpy( ch[nq], ch[q], sizeof ch[q]); len[nq] = len[p] + 1, fa[nq] = fa[q], fa[q] = fa[np] = nq; while( p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = fa[p]; &#125; &#125; &#125; void build(char s[]) &#123; int lens = strlen(s + 1); for(int i = 1; i &lt;= lens; i++) add(Tr(s[i])); add(26); for(int i = lens; i &gt;= 1; i--) add(Tr(s[i])); &#125; ll getsubnum() &#123; ll ans = 0; for(int i = tot; i; i--) &#123; ans += val(i); &#125; return ans; &#125;&#125; sam;struct PAM&#123; int next[maxn][N] ; int fail[maxn] ; int cnt[maxn] ; int num[maxn] ; int len[maxn] ; int S[maxn] ; int last ; int n ; int p ; int newnode ( int l ) &#123; for ( int i = 0 ; i &lt; N ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123; p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ; fail[0] = 1 ; &#125; int get_fail ( int x ) &#123; while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; void add ( int c ) &#123; c -= 'a' ; S[++ n] = c ; int cur = get_fail ( last ) ; if ( !next[cur][c] ) &#123; int now = newnode ( len[cur] + 2 ) ; fail[now] = next[get_fail ( fail[cur] )][c] ; next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; &#125; last = next[cur][c] ; cnt[last] ++ ; &#125;&#125; pam;char s[maxn];int main()&#123; scanf("%s", s + 1); int lens = strlen(s + 1); sam.init(); sam.build(s); ll ans1 = sam.getsubnum() - 1LL*(lens+1)*(lens+1); pam.init(); for(int i = 1; i &lt;= lens; i++) &#123; pam.add(s[i]); &#125; ll ans2 = pam.p-2; printf("%lld\n",(ans1+ans2)/2);&#125; 第五场G-subsequence 1 题意：给两个字符串，求字符串s中的字符子序列组合成的无前导零整数大于t组合成的整数的方案数 思路：首先长度大于t串的可以枚举非0前导，通过组合数学求出；长度相等的情况dp来搞 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 3e3+5;const int P = 998244353; ll C[maxn][maxn];void getC()&#123; for(int i=0;i&lt;maxn;i++)&#123; C[i][0]=C[i][i]=1; for(int j=1;j&lt;i;j++)&#123; C[i][j]=(C[i-1][j-1]+C[i-1][j])%P; &#125; &#125;&#125; char s[maxn],t[maxn];ll dp[maxn][maxn];void Add(ll &amp;x,ll y)&#123; x+=y; if(x&gt;=P) x-=P;&#125;int main()&#123; getC(); int T; scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%s%s&quot;,s+1,t+1); ll ans=0; //长度不相等答案 for(int i=1;i&lt;=n;i++)&#123; if(s[i]!=&apos;0&apos;)&#123; for(int j=m;j&lt;=n-i;j++)&#123; Add(ans,C[n-i][j]); &#125; &#125; &#125; //长度相等答案,dp[i][j]表示s串前i个选出j个和t串前j个相等的方案数 for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=m;j++)&#123; dp[i][j]=0; &#125; dp[i][0]=1; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; dp[i][j]=dp[i-1][j]; if(s[i]==t[j])&#123; Add(dp[i][j],dp[i-1][j-1]); &#125; if(s[i]&gt;t[j])&#123; if(n-i&gt;=0&amp;&amp;m-j&gt;=0&amp;&amp;n-i&gt;=m-j)&#123; Add(ans,dp[i-1][j-1]*C[n-i][m-j]%P); &#125; &#125; &#125; &#125; printf(&quot;%lld\n&quot;,ans); &#125;&#125; 第六场D-Move 题意：n个物品放在k个体积相同的箱子里，规则是对于每一个箱子都一直尽可能放当前最大的物品进去直到不能放就换下一个箱子放，求箱子最小体积 思路：二分答案，出来的答案还要瞎搞下，因为不是最优解，复杂度爆炸也过了，毕竟数据水 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;const int maxn = 1e3+5;typedef long long ll;ll a[maxn];ll n,k;bool vis[maxn];bool pd(ll x)&#123; if(a[n]&gt;x) return false; memset(vis,0,sizeof(bool)*(n+2)); int take=0; for(int j=1;j&lt;=k;j++)&#123; ll rest=x; for(int i=n;i&gt;=1;i--)&#123; if(vis[i]) continue; if(rest&gt;=a[i])&#123; rest -= a[i]; vis[i]=1; take++; &#125; if(rest&lt;a[1]) break; &#125; if(take==n)break; &#125; return take==n;&#125; int main()&#123; int T; scanf("%d",&amp;T); int ca=1; while(T--)&#123; scanf("%d%d",&amp;n,&amp;k); ll sum=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); sum+=a[i]; &#125; sort(a+1,a+1+n); ll l=0,r=10*sum; while(l&lt;r)&#123; ll mid = (l+r)&gt;&gt;1; if(pd(mid)) r=mid; else l=mid+1; &#125; printf("Case #%d: ",ca++); for(int i=l-20;i&lt;=l;i++) if(pd(i))&#123; printf("%d\n",i); break; &#125; &#125; &#125; G-Is Today Friday? 题意：给出1e5个由大写字母A-J组成的字符串，每个字符串代表一个规定年限内的周五日期，求A-J每个字母的数字含义，要求字典序最小 思路：因为日期有限制，所以1e5个中有很多会有重复的，排序去重后，直接枚举0-9的全排列（合法的其实很少），即枚举答案，同时保证了字典序最小。复习了一下基姆拉尔森公式和判断平闰年qwq 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5+5;int a[15];int m[15]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;int larson(int year,int month,int day)&#123; if(month == 1 || month == 2)&#123; year -= 1; month += 12; &#125; return (day+2*month+3*(month+1)/5+year+(year/4)-(year/100)+(year/400)+1)%7;&#125;bool pd(string s)&#123; int year = a[s[0]-'A']*1000+a[s[1]-'A']*100+a[s[2]-'A']*10+a[s[3]-'A']; int month = a[s[5]-'A']*10+a[s[6]-'A']; int day = a[s[8]-'A']*10+a[s[9]-'A']; if( (year%4==0&amp;&amp;year%100!=0) || year%400==0 ) m[2]=29; else m[2]=28; if(year&lt;1600 || month&lt;1 ||month&gt;12 || day&lt;1 ||day&gt;m[month] || larson(year,month,day)!=5) return false; return true;&#125;string s[maxn];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int T,ca=1;cin&gt;&gt;T; while(T--)&#123; int n;cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;s[i]; &#125; sort(s,s+n); n = unique(s,s+n)-s; for(int i=0;i&lt;10;i++) a[i]=i; bool ok=false; do&#123; bool flag=true; for(int i=0;i&lt;n;i++)&#123; if(!pd(s[i]))&#123; flag=false; break; &#125; &#125; if(flag)&#123; ok=true; break; &#125; &#125;while(next_permutation(a,a+10)); printf("Case #%d: ",ca++); if(!ok) puts("Impossible"); else&#123; for(int i=0;i&lt;10;i++) printf("%d",a[i]); puts(""); &#125; &#125; &#125; 第七场E-Find the median 题意：给n段区间，每次将区间[L,R]每个数加到当前序列中，区间范围1e9，求每次操作后的中位数 思路：如果区间范围较小那就是个权值线段树模板题，这里区间需要离散化，线段树上每个叶子结点代表一个区间，记录每个区间的长度和出现次数，就可以知道当前所有数的个数，然后线段树中二分查找第k小即可 get：区间离散化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define ls o&lt;&lt;1#define rs o&lt;&lt;1|1#define lson l,mid,ls#define rson mid+1,r,rsusing namespace std;typedef long long ll;const int maxn = 2*4e5+5;ll X[maxn],Y[maxn],l[maxn],r[maxn];ll A1,A2,B1,B2,C1,C2,M1,M2;ll cnt[maxn&lt;&lt;2],sum[maxn&lt;&lt;2],len[maxn&lt;&lt;2];//区间覆盖次数,区间所有数个数,区间长度vector&lt;int&gt;v;void push_up(int o)&#123; sum[o]=sum[ls]+sum[rs]; len[o]=len[ls]+len[rs];&#125;void push_down(int o)&#123; if(cnt[o])&#123; cnt[ls]+=cnt[o]; cnt[rs]+=cnt[o]; sum[ls]+=cnt[o]*len[ls]; sum[rs]+=cnt[o]*len[rs]; cnt[o]=0; &#125;&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; cnt[o]=sum[o]=0; len[o]=v[l]-v[l-1]; return; &#125; int mid = (l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;void update(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; cnt[o]++; sum[o]+=len[o]; return; &#125; push_down(o); int mid = (l+r)&gt;&gt;1; if(L&lt;=mid) update(L,R,lson); if(R&gt;mid) update(L,R,rson); push_up(o);&#125;int query(int l,int r,int o,ll k)&#123; if(l==r)&#123; return v[l-1]+(k-1)/(sum[o]/len[o]); &#125; push_down(o); int mid = (l+r)&gt;&gt;1; if(sum[ls]&gt;=k) return query(lson,k); else return query(rson,k-sum[ls]);&#125; int main()&#123; int n,m; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%lld%lld%lld%lld%lld%lld&quot;,&amp;X[1],&amp;X[2],&amp;A1,&amp;B1,&amp;C1,&amp;M1); scanf(&quot;%lld%lld%lld%lld%lld%lld&quot;,&amp;Y[1],&amp;Y[2],&amp;A2,&amp;B2,&amp;C2,&amp;M2); for(int i=3;i&lt;=n;i++)&#123; X[i] = (A1*X[i-1]%M1 + B1*X[i-2]%M1 + C1)%M1; Y[i] = (A2*Y[i-1]%M2 + B2*Y[i-2]%M2 + C2)%M2; &#125; for(int i=1;i&lt;=n;i++)&#123; l[i]=min(X[i],Y[i])+1; r[i]=max(X[i],Y[i])+1; r[i]++; v.push_back(l[i]);v.push_back(r[i]); &#125; sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end()); m=v.size(); for(int i=1;i&lt;=n;i++)&#123; l[i] = lower_bound(v.begin(),v.end(),l[i])-v.begin()+1; r[i] = lower_bound(v.begin(),v.end(),r[i])-v.begin()+1; r[i]--; &#125; build(1,m-1,1); ll all=0; for(int i=1;i&lt;=n;i++)&#123; update(l[i],r[i],1,m-1,1); all=sum[1]; printf(&quot;%d\n&quot;,query(1,m-1,1,(all+1)/2)); &#125;&#125; 第八场A-All-one Matrices 题意：求极大全一子矩阵个数 思路：固定上边界，单调队列处理当前下边界，这样知道每一列可拓展的最左边界和最右边界，然后看下边界是否可以拓展 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 3e3+5;int n, m;char mp[maxn][maxn];int h[maxn],L[maxn],R[maxn],sum[maxn][maxn];int st[maxn];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%s",mp[i]+1); &#125; for(int i=1;i&lt;=n;i++)&#123; sum[i][0]=0; for(int j=1;j&lt;=m;j++)&#123; sum[i][j] = sum[i][j-1]+(mp[i][j]=='1'); &#125; &#125; int ans=0; h[m+1]=-1; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; if(mp[i][j]=='1') h[j]++; else h[j]=0; &#125; for(int j=1; j&lt;=m; j++) &#123; L[j]=j; while(L[j]&gt;1&amp;&amp;h[j]&lt;=h[L[j]-1]) L[j]=L[L[j]-1]; &#125; for(int j=m; j&gt;=1; j--) &#123; R[j]=j; while(R[j]&lt;m&amp;&amp;h[j]&lt;=h[R[j]+1]) R[j]=R[R[j]+1]; &#125; int top=0; for(int j=1;j&lt;=m+1;j++)&#123; while(top&amp;&amp;h[j]&lt;h[st[top]])&#123; int now = st[top]; top--; if(!h[now]) continue; int l = L[now]; int r = R[now]; if(sum[i+1][r]-sum[i+1][l-1] != r-l+1)&#123; //printf("%d %d %d %d %d\n",i,j,now,l,r); ans++; while(top&amp;&amp;st[top]&gt;=l) top--; &#125; &#125; st[++top]=j; &#125; &#125; printf("%d\n",ans);&#125; E-Explorer 题意：一张图中所有边有个[l,r]，问从点1到点n可以有多少个值可以通过 思路：线段树维护可撤销并查集，每个结点表示区间被哪些两个点包含，每次将这些两个点的集合加到一起，并查集合并时因为要撤销所以不能路径压缩，只能按秩合并 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define lc o&lt;&lt;1#define rc o&lt;&lt;1|1#define lson l,mid,lc#define rson mid+1,r,rcusing namespace std;typedef long long ll;const int maxn = 1e5+5;int U[maxn],V[maxn],L[maxn],R[maxn];vector&lt;int&gt;ve;int fa[maxn],sz[maxn];int Find(int x)&#123; return x==fa[x]?x:Find(fa[x]);&#125; vector&lt;int&gt;tag[maxn&lt;&lt;3];void update(int L,int R,int v,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; tag[o].push_back(v); return; &#125; int mid = (l+r)&gt;&gt;1; if(L&lt;=mid) update(L,R,v,lson); if(R&gt;mid) update(L,R,v,rson);&#125; int n,m,ans;void query(int l,int r,int o)&#123; vector&lt;int&gt;tmp; for(auto i:tag[o])&#123; int u = U[i],v = V[i]; int fu = Find(u),fv = Find(v); if(fu==fv) continue; if(sz[fu]&gt;sz[fv]) swap(fu,fv); fa[fu]=fv; sz[fv]+=sz[fu]; tmp.push_back(fu); &#125; if(Find(1)==Find(n)) ans+=ve[r]-ve[l-1]; else if(l&lt;r)&#123; int mid = (l+r)&gt;&gt;1; query(lson); query(rson); &#125; for(auto v:tmp) fa[v]=v;&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d%d",&amp;U[i],&amp;V[i],&amp;L[i],&amp;R[i]); R[i]++; ve.push_back(L[i]); ve.push_back(R[i]); &#125; sort(ve.begin(),ve.end()); ve.erase(unique(ve.begin(),ve.end()),ve.end()); int nx = ve.size(); for(int i=1;i&lt;=m;i++)&#123; L[i]=lower_bound(ve.begin(),ve.end(),L[i])-ve.begin()+1; R[i]=lower_bound(ve.begin(),ve.end(),R[i])-ve.begin(); update(L[i],R[i],i,1,nx,1); &#125; for(int i=1;i&lt;=n;i++)&#123; fa[i]=i; sz[i]=1; &#125; query(1,nx,1); printf("%d\n",ans);&#125; 第九场H-Cutting Bamboos 题意：区间一些数减到某一定值，操作y次，要使每次减掉部分和相等，问第x次减到的定值 思路：实数域上二分答案，主席树区间查询比&lt;=x的和为多大 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 2e5+5;int T[maxn*20],L[maxn*20],R[maxn*20],cnt[maxn*20];ll sum[maxn*20];int tot;void build(int &amp;x,int l,int r)&#123; x=++tot; sum[x]=cnt[x]=0; if(l==r) return; int mid = (l+r)&gt;&gt;1; build(L[x],l,mid); build(R[x],mid+1,r);&#125;void update(int &amp;now,int pre,int l,int r,int h)&#123; now=++tot; L[now]=L[pre]; R[now]=R[pre]; cnt[now]=cnt[pre]+1; sum[now]=sum[pre]+h; if(l==r) return; int mid = (l+r)&gt;&gt;1; if(h&lt;=mid) update(L[now],L[pre],l,mid,h); else update(R[now],R[pre],mid+1,r,h);&#125;double nnum,ssum;void query(int ql,int qr,int l,int r,int h)&#123; if(l&gt;h) &#123; nnum += cnt[qr]-cnt[ql]; return; &#125; if(r&lt;=h)&#123; ssum += sum[qr]-sum[ql]; return; &#125; int mid = (l+r)&gt;&gt;1; query(L[ql],L[qr],l,mid,h); query(R[ql],R[qr],mid+1,r,h);&#125; int h[maxn];int all = 100000;int main()&#123; int n,q; scanf("%d%d",&amp;n,&amp;q); tot=0; build(T[0],1,all); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;h[i]); update(T[i],T[i-1],1,all,h[i]); &#125; while(q--)&#123; int ql,qr,x,y; scanf("%d%d%d%d",&amp;ql,&amp;qr,&amp;x,&amp;y); double rest = (sum[T[qr]]-sum[T[ql-1]])*1.0/y*(y-x); double l=0.0,r=100000.0,mid,eps=1e-8; while(l+eps&lt;r)&#123; mid = (l+r)/2; nnum=ssum=0; query(T[ql-1],T[qr],1,all,mid); ssum += nnum*mid; if(ssum&gt;rest) r=mid; else l=mid; &#125; printf("%.15f\n",l); &#125;&#125; J-Symmetrical Painting 题意：给n个矩形，要求去掉部分矩形覆盖面积，使得剩余矩形覆盖面积关于某对称轴水平对称，求最大剩余覆盖面积 思路：要使水平对称，那枚举每个矩形的对称轴，上中下，每次根据位置标记算贡献 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 3e5+5;struct node&#123; double y;int w; node()&#123;&#125; node(double a,int b):y(a),w(b)&#123;&#125; bool operator &lt; (const node&amp;hs)const&#123; return y&lt;hs.y; &#125;&#125;a[maxn*3]; int main()&#123; int n; scanf("%d",&amp;n); int cnt=0; for(int i=0;i&lt;n;i++)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); a[cnt++]=node(l,1); a[cnt++]=node((l+r)*1.0/2,-2); a[cnt++]=node(r,1); &#125; sort(a,a+cnt); double pre=0; double ans=0,now=0,len=0,sum=0; for(int i=0;i&lt;cnt;i++)&#123; len = a[i].y - pre; sum += 1LL*now*len*2; ans = max(ans,sum); now += a[i].w; pre = a[i].y; &#125; printf("%.0f\n",ans);&#125; 第十场B-Coffee Chicken 题意：求斐波那契规则构成的n个字符串，第n个的第k-k+9个字符 思路：根据斐波那契的实现，输出长度只有10，最后输出的字符肯定会落在第一个和第二个串上 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e6+5;string s[5]=&#123;"", " COFFEE", " CHICKEN"&#125;;ll f[505];void pr(int n,ll k)&#123; while(n&gt;2)&#123; if(f[n-2]&gt;=k) n-=2; else k-=f[n-2],n--; &#125; putchar(s[n][k]);&#125; int main()&#123; f[0] = 0; f[1] = 6; f[2] = 7; for(int i=3;i&lt;=500;i++) f[i] = min(f[i-1]+f[i-2],(ll)1e12+10); int T; scanf("%d",&amp;T); while(T--)&#123; int n;ll k; scanf("%d%lld",&amp;n,&amp;k); for(int i=0;i&lt;10;i++)&#123; if(k+i&lt;=f[n]) pr(n,k+i); &#125; puts(""); &#125;&#125; F-Popping Balloons 题意：二维平面上一些点上有气球，现在可以射击6次，水平垂直各3次，射击可使一行或一列的气球都命中，两种方式任意两次射击的距离只能为r，求最大射击气球数 思路：线段树维护的叶子结点表示第一发打中x，后面x+r,x+r+r一起的收益，这样固定x轴的，枚举y轴，然后更新减掉x，y重复的，求x轴的最大值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define lc o&lt;&lt;1#define rc o&lt;&lt;1|1#define lson l,mid,lc#define rson mid+1,r,rcusing namespace std;typedef long long ll;const int maxn = 3e5+5;int sumx[maxn],Max[maxn&lt;&lt;2];vector&lt;int&gt;Y[maxn];int n,r;void push_up(int o)&#123; Max[o]=max(Max[lc],Max[rc]);&#125;void update(int p,int v,int l,int r,int o)&#123; if(l==r)&#123; Max[o] += v; return; &#125; int mid =(l+r)&gt;&gt;1; if(p&lt;=mid) update(p,v,lson); else update(p,v,rson); push_up(o);&#125;int Mx,My;void sub(int p)&#123; update(p,-1,0,Mx,1); if(p-r&gt;=0)update(p-r,-1,0,Mx,1); if(p-r-r&gt;=0)update(p-r-r,-1,0,Mx,1);&#125;void add(int p)&#123; update(p,1,0,Mx,1); if(p-r&gt;=0)update(p-r,1,0,Mx,1); if(p-r-r&gt;=0)update(p-r-r,1,0,Mx,1);&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;r); Mx=0,My=0; for(int i=0;i&lt;n;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); sumx[x]++; Y[y].push_back(x); Mx=max(Mx,x); My=max(My,y); &#125; for(int i=0;i&lt;=Mx;i++)&#123; update(i,sumx[i]+sumx[i+r]+sumx[i+r+r],0,Mx,1); &#125; int ans=0; for(int i=0;i&lt;=My;i++)&#123; for(auto p:Y[i]) sub(p); for(auto p:Y[i+r]) sub(p); for(auto p:Y[i+r+r]) sub(p); int sumX = Max[1]; int sumY = Y[i].size()+Y[i+r].size()+Y[i+r+r].size(); //printf("%d %d %d\n",i,sumX,sumY); ans=max(ans,sumX+sumY); for(auto p:Y[i]) add(p); for(auto p:Y[i+r]) add(p); for(auto p:Y[i+r+r]) add(p); &#125; printf("%d\n",ans);&#125; 完结撒花&gt;&gt;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>dfs</tag>
        <tag>STL</tag>
        <tag>二分</tag>
        <tag>dp</tag>
        <tag>离散化</tag>
        <tag>并查集</tag>
        <tag>分治</tag>
        <tag>单调栈</tag>
        <tag>bitset</tag>
        <tag>单调队列</tag>
        <tag>模拟</tag>
        <tag>SAM</tag>
        <tag>PAM</tag>
        <tag>组合数学</tag>
        <tag>几何</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC2019女生专场D-Tree]]></title>
    <url>%2FCCPC2019%E5%A5%B3%E7%94%9F%E4%B8%93%E5%9C%BAD-Tree.html</url>
    <content type="text"><![CDATA[今天花一天时间好好学习了下树链剖分，之前听上去很高大上的样子，上半年寒假集训学长讲的时候还完全不懂，现在学着学着就很好理解了。刚好这道最近要补的题就是个裸题，拿来练练手。 原题链接 如果想区间维护更新的话因为是开根号，不满足加减乘幂等运算性质，所以只好单点更新，但这样复杂度会是O(qnlogn)？实际上，因为ai最大1e9，对其在在10次开根号的操作下会变为1，然后就不会变了，所以维护一个区间最大值，每次更新看是否最大值&lt;=1，是的话线段树就不要递归向下更新了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;typedef long long ll;const int maxn = 1e5+10;const int maxm = 1e5+10;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct edge&#123; int next,to;&#125;e[maxm*2];int head[maxn],cnt;void addedge(int u,int v)&#123; e[++cnt]=edge&#123;head[u],v&#125;; head[u]=cnt;&#125;int n,q,val[maxn];int fa[maxn],deep[maxn],siz[maxn],son[maxn],rk[maxn],top[maxn],id[maxn];void dfs1(int u,int pre,int dep)&#123; fa[u]=pre;deep[u]=dep;siz[u]=1; for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v==pre)continue; dfs1(v,u,dep+1); siz[u]+=siz[v]; if(siz[v]&gt;siz[son[u]])son[u]=v; &#125;&#125;void dfs2(int u,int t)&#123; top[u]=t;id[u]=++cnt;rk[cnt]=u; if(!son[u])return; dfs2(son[u],t); for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v!=son[u]&amp;&amp;v!=fa[u])dfs2(v,v); &#125;&#125;ll Max[maxn&lt;&lt;2],Sum[maxn&lt;&lt;2];void push_up(int o)&#123; Sum[o]=Sum[o&lt;&lt;1]+Sum[o&lt;&lt;1|1]; Max[o]=max(Max[o&lt;&lt;1],Max[o&lt;&lt;1|1]);&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; Max[o]=Sum[o]=val[rk[l]]; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;void update(int L,int R,int l,int r,int o)&#123; if(Max[o]&lt;=1) return; if(l==r)&#123; Sum[o]=(int)sqrt(Sum[o]); Max[o]=Sum[o]; return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) update(L,R,lson); if(R&gt;mid) update(L,R,rson); push_up(o);&#125;ll querysum(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Sum[o]; &#125; int mid=(l+r)&gt;&gt;1;ll ret=0; if(L&lt;=mid) ret+=querysum(L,R,lson); if(R&gt;mid) ret+=querysum(L,R,rson); return ret;&#125;void PathUpdate(int x,int y)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); update(id[top[x]],id[x],1,n,1); x=fa[top[x]]; &#125; if(id[x]&gt;id[y]) swap(x,y); update(id[x],id[y],1,n,1);&#125;ll PathQuery(int x,int y)&#123; ll ret=0; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); ret+=querysum(id[top[x]],id[x],1,n,1); x=fa[top[x]]; &#125; if(id[x]&gt;id[y])swap(x,y); ret+=querysum(id[x],id[y],1,n,1); return ret;&#125;int main()&#123; n=read(),q=read(); for(int i=1;i&lt;=n;i++) val[i]=read(); cnt=0; for(int i=1;i&lt;=n;i++) head[i]=0; for(int i=0;i&lt;n-1;i++)&#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; cnt=0; dfs1(1,0,1); dfs2(1,1); build(1,n,1); while(q--)&#123; int op=read(),x=read(),y=read(); if(op==0)&#123; PathUpdate(x,y); &#125; else&#123; printf("%lld\n",PathQuery(x,y)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客小白月赛16&&CodeForces1191 补题]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B16-CodeForces1191-%E8%A1%A5%E9%A2%98.html</url>
    <content type="text"><![CDATA[又是自闭的一天… D-小阳买水果求序列连续子段和大于0的最长子序列长度 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3ftypedef long long ll;using namespace std;const int maxn = 2e6+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int ans,sum,n;int a[maxn];int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; //枚举r二分l (l,r] int x=read(); sum+=x; a[i]=min(a[i-1],sum); if(sum-a[i-1]&lt;=0) continue; int l=0,r=i-1; while(l&lt;r)&#123; int m=(l+r)&gt;&gt;1; if(sum-a[m]&gt;0) r=m; else l=m+1; &#125; ans=max(ans,i-l); &#125; printf("%d\n",ans);&#125; F-小石的妹子拓扑思想+线段树维护区间最大值 发现用数组数组常数小，代码量也少 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1#define INF 0x3f3f3f3ftypedef long long ll;using namespace std;const int maxn = 1e5+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct node&#123; int a,b,id; bool operator &lt; (const node&amp;hs)const&#123; return a&gt;hs.a; &#125;&#125;p[maxn];int n;int bb[maxn],ans[maxn];int Max[maxn&lt;&lt;2];void update(int p,int v,int l,int r,int o)&#123; if(l==r)&#123; Max[o]=v; return; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) update(p,v,lson); else update(p,v,rson); Max[o]=max(Max[o&lt;&lt;1],Max[o&lt;&lt;1|1]);&#125;int querymax(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Max[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=-1; if(L&lt;=mid) ret=max(ret,querymax(L,R,lson)); if(R&gt;mid) ret=max(ret,querymax(L,R,rson)); return ret;&#125;int main()&#123; n=read(); for(int i=0;i&lt;n;i++)&#123; int a=read(),b=read(); bb[i]=b; p[i]=node&#123;a,b,i&#125;; &#125; sort(p,p+n); sort(bb,bb+n); //离散化bi for(int i=0;i&lt;n;i++)&#123; p[i].b=lower_bound(bb,bb+n,p[i].b)-bb+1; &#125; //因为已经对ai排序,满足aj&gt;ai,则只要考虑bj&gt;bi的最大排名即可 for(int i=0;i&lt;n;i++)&#123; ans[p[i].id]=querymax(p[i].b,n,1,n,1)+1; update(p[i].b,ans[p[i].id],1,n,1); &#125; for(int i=0;i&lt;n;i++) printf("%d\n",ans[i]);&#125; H-小阳的贝壳$gcd(a,b,c)=gcd(a,b-a,c-b)=gcd(a,gcd(b-a,c-b));$ $gcd([l,r])=gcd(a[l],gcd([l+1,r]))$ a[l]=$\sum_{i=1}^{l}f[i]$,f[i]为差分数列f[i]=a[i]-a[i-1] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1#define INF 0x3f3f3f3ftypedef long long ll;using namespace std;const int maxn = 1e5+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int a[maxn],f[maxn];int Sum[maxn&lt;&lt;2],Max[maxn&lt;&lt;2],Gcd[maxn&lt;&lt;2];void push_up(int o)&#123; Sum[o]=Sum[o&lt;&lt;1]+Sum[o&lt;&lt;1|1]; Max[o]=max(Max[o&lt;&lt;1],Max[o&lt;&lt;1|1]); Gcd[o]=__gcd(Gcd[o&lt;&lt;1],Gcd[o&lt;&lt;1|1]);&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; Sum[o]=f[l]; Max[o]=Gcd[o]=abs(Sum[o]); return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;void update(int p,int v,int l,int r,int o)&#123; if(l==r)&#123; Sum[o]+=v; Max[o]=Gcd[o]=abs(Sum[o]); return; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) update(p,v,lson); else update(p,v,rson); push_up(o);&#125;int querymax(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Max[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=0; if(L&lt;=mid) ret=max(ret,querymax(L,R,lson)); if(R&gt;mid) ret=max(ret,querymax(L,R,rson)); return ret;&#125;int querysum(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Sum[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=0; if(L&lt;=mid) ret+=querysum(L,R,lson); if(R&gt;mid) ret+=querysum(L,R,rson); return ret;&#125;int querygcd(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Gcd[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=0; if(L&lt;=mid) ret=__gcd(ret,querygcd(L,R,lson)); if(R&gt;mid) ret=__gcd(ret,querygcd(L,R,rson)); return ret;&#125;int main()&#123; int n=read(),m=read(); for(int i=1;i&lt;=n;i++)&#123; a[i]=read(); f[i]=a[i]-a[i-1]; &#125; build(1,n,1); while(m--)&#123; int op=read(),l=read(),r=read(); if(op==1)&#123; int x=read(); update(l,x,1,n,1); if(r+1&lt;=n) update(r+1,-x,1,n,1); &#125; else if(op==2)&#123; if(l==r) puts("0"); else printf("%d\n",querymax(l+1,r,1,n,1)); &#125; else&#123; if(l==r) printf("%d\n",querysum(1,l,1,n,1)); else printf("%d\n",__gcd(querysum(1,l,1,n,1),querygcd(l+1,r,1,n,1))); &#125; &#125;&#125; 复习一下线段树~好久没写的样子 C-Tokitsukaze and Discard Items123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5+5;ll a[maxn];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); ll n,m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;a[i]; &#125; int ans=0,cnt=0; int i=1; while(i&lt;=m)&#123; ll r = ((a[i]-cnt-1)/k+1)*k+cnt; //计算第一个特殊数所在页上限 while(i&lt;=m&amp;&amp;a[i]&lt;=r)&#123; cnt++; i++; &#125; ans++; &#125; cout&lt;&lt;ans&lt;&lt;'\n';&#125; D-Tokitsukaze, CSL and Stone Game12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5+5;int a[maxn];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int n;cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; sort(a,a+n); if(n&gt;=2&amp;&amp;a[0]==0&amp;&amp;a[1]==0)&#123;//注意特判 puts("cslnb"); return 0; &#125; ll sum=0; int has2=0;//相同数对的个数 for(int i=0;i&lt;n;i++)&#123; sum+=a[i]-i; //贪心选取,要使不重复,最后每堆数目留下的肯定是0,1,2,... if(i&lt;n-1&amp;&amp;a[i]==a[i+1]) has2++; if(i&gt;0&amp;&amp;i&lt;n-1&amp;&amp;a[i]==a[i+1]&amp;&amp;a[i-1]+1==a[i])&#123;//x,x+1,x+1这种情况无论怎么取都先手输 puts("cslnb"); return 0; &#125; &#125; if((sum&amp;1)==0 || has2&gt;=2) puts("cslnb"); else puts("sjfnb");&#125; 补完Div2的CD发现真的不难，因为读错题和读题太慢很影响心态，下次还得细心点啊]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>二分</tag>
        <tag>树状数组</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法学习(转)]]></title>
    <url>%2F%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BD%AC.html</url>
    <content type="text"><![CDATA[b站上无意翻到新疆小姐姐莎依拜 (Sahiba Anwar)的英语语法视频《一堂课让你懂得英语语法百分之九十五》，全长103分钟，语速较慢，2倍速下不到1小时可以看完。中学上的语法课都是零零散散的，整体总结一下，感觉知识体系清晰了很多。（BTW，小姐姐声音真好听） 概要 语法是一座体系，是一座大楼，但是中学期间学习的语法是零散的，我们学习的内容都是砖块，无法看到英语语法的大楼。这个视频能够让我们快速认识语法大楼的全貌（相当于理解了95%）。剩余的5%，都是小碎砖，再去细地探索。视频作者是新疆小姐姐莎依拜 (Sahiba Anwar)。本篇内容完全来自视频。 结构分类 按照结构分类时，所有英文句子能够分成三类： 简单句： 1主语 + 谓语 + 宾语 并列句： 1234主谓宾， 并列词 + 主谓宾 ————————————————⟶ ↓ ↳ e.g. and,or,but etc. ↓(简单句) (简单句) |-----------同等地位，并列关系------------| 复合句： 123主谓宾， 从句引导词 + 主谓宾 ————————————————⟶ ↓ ↳ e.g. which,when,where... ↓主句(主导地位，大哥，简单句) 从句(从属地位，小弟，简单句) 从句类型： 名词性从句（名词） 定语从句（形容词） 状语从句（副词） 主语：subject → 动作的发出者 ⇒ 我谓语： verb → 动作 ⇒ 踢宾语： object → 动作的承受者 ⇒ 球 主谓宾和它的五个兄弟（简单句的六个基本句型） 所有的英文句子无外乎主谓宾的问题，把主谓宾研究清楚了，把所有句子就搞清楚了。 句型112主（名） 谓（及物） 宾（名） I play games. 句型2123主（名） 谓（不及物） Spring comes. ↳此动作无承受者，所以没有宾语 句型312345678主（名） 系 表 ↳共3种 （名词；形容词；不定式；介宾[介词+名词]）&lt;1&gt; Be动词：am, is, are, was, were&lt;2&gt; 感官动词（五官）：look, sound, smell, taste, feel&lt;3&gt; 变化动词：become, turn, go, get, grow&lt;4&gt; 静止动词：stay, remain, keep* 不定式[to do], 但是如果遇到to + 动词ing，这里的to是介词。 句型4123 主 谓 宾 宾（名） (及物) （名） （名） I give you money 句型512345678主 谓 宾 补（名） （及物） （名） （1.形容词 2.不定式）|----结构完成，意思不完整---| |---补充说明意思---|1. The music makes me sad.2. He tells me to go. * He helps me (to) understand the problem. 特殊 句型61234567There be 句型，表达&quot;存在&quot;。There be 名词There is a dog.There be 名词 介宾There is a dog under the tree. 从句：引导词 + 主谓宾（或其五个兄弟）名词性从句 主语从句 宾语从句 表语从句 同位语从句 一模一样的句子，只不过位置不同，所以名称不同。 12345主 谓 宾语(名词) (及物动词) (名词)名词性从句 名词性从句 ↓ ↓主语从句 宾语从句 名词性从句常用的引导词有:that, whether, what 12345678e.g. 名词性从句： that he likes football (引导词) (名) (动) (名) | |------主谓宾(句子)-------| ⇒ 不能做句子成分* |-----------------------| | ⇓ ↲ 降级成 名词（可以做句子成分）* 为什么不能做句子成分？英文里一个句子只能有一个谓语动词，否则句子不成立。 主语从句 1234That he likes football surprised us.--------------------- ▲ ▲ 名词 及物动词 名词 （主语） （谓语）（宾语） 宾语从句 1234 He said that he likes football. ▲ ▲ ---------------------- 名词 及物动词 名词（主语）（谓语） （宾语） 表语从句 1234 The fact is that he likes football. -------- ▲ ▲ 名词 be动词 名词（主语） （系语） （表语） 同位语从句什么是同位语？同位语起解释说明名词的作用，和其解释的名词相等；同位语是[名词] 123456789101112如： 主， 同位语， 谓宾. Yusuf, a Uyghur man, loves spring. 主谓宾， 同位语 . Yusuf loves spring, on of the four season.上面的同位语是以插入语的形式。The fact that he likes football surprised us.-------- ---------------------- ▲ ▲ 名词 同位语从句 动词（谓） 名词（宾）He states the fact that he likes football. ▲ ▲ ▲ ------------------------* 同位语从句的引导词只有that。 定语从句什么是定语？修饰限定名词，红红的花定语Ⅰ：形容词（短一些）定语Ⅱ：短语或从句（长一些） 1234567891011121314151617181920**为什么要分两种呢**？因为英语忌讳头重脚轻，定语稍微长一点，马上往后挪。 定Ⅰ 主 定Ⅱ 谓 定Ⅰ 宾 定Ⅱ （名） （动） （名） A beautiful girl shared a fascinating story. --------- ▲ ----------- ▲ 定Ⅰ(形) 定Ⅰ(形) A girl from Mars shared a story about her people. ▲ --------- ▲ --------------- 定Ⅱ(介宾短语) 定Ⅱ(介宾短语) A task to tackle is the potential crisis. ▲ --------- --------- ▲ 定Ⅱ(不定式) 定Ⅰ(形) A girl who likes spring shared a story which moved us. ▲ ---------------- ▲ --------------- (定语从句) （定语从句） 状语从句 什么是状语？ 副词：修饰动词:walk slowly； 修饰形容词：slightly higher； 起副词作用的句子：状语从句 按作用划分： 时间状语(从句)：何时？ 地点状语(从句)：在哪？ 原因状语(从句)：为啥？因为…； 条件状语(从句)：在什么情况下？如果…；只要…；只有…； 目的状语(从句)：为了啥？为了…；这样就能…； 结果状语(从句)：导致了啥？结果…；以至于…； 让步状语(从句)：转折的前奏，强调前的东西不重要。虽然…； 方式状语(从句)：怎么做的（发生的）？用…；通过…； 状语从句是存在于简单句（主谓宾）之外的。 例子： 1234Yusuf smiles happily. 副词修饰动词，出现在动词之后Yusuf quickly understood. 副词修饰动词，出现在动词之前She is strikingly beautiful. 副词修饰形容词，表示程度：强He is pretty tall. 副词修饰形容词，表示程度：弱 123456789101112131415He came yesterday. 时间副词，位置灵活Yesterday he came.He called me when I was sleeping. 时间状语从句He celebrated hes birthday at school. 地点副词，位置灵活At school he celebrated his birthday.We met where we used to go for a walk. 地点状语从句He likes spring for its beauty.He likes srping for it is beautiful.He likes spring because it is beautiful.He likes spring as it is beautiful.He likes spring since it is beautiful. 都是从句，原因除了since前后都可以外，其他的都靠后Because开头的不是状语从句，而是一个名词性句子 12If you win, there will be a reward. 条件状语从句As long as you win, there will be a reward. 条件状语从句 1234I study for my well-being. I don&apos;t spend extra to save money. (to is short for in order to)I don&apos;t spend extra in order to save money. (in order to 可以提前)I don&apos;t spend extra so that I can save money. 目的状语从句 12He tried so hard that he finally succeeded. 结果状语从句这里的so...that...和目的状语从句的so that不同，目的状语从句中的so that不能加任何东西，so that共同引导。 12Although you have a point there, I don&apos;t agree with your proposal.让步状语从句，不需转折词。重点在转折后面的东西。 1234567I learned English through an online course.I contact my friends via Wechat.I draw with my pen.I found differences by contasting the two.She looks at me as if she knows me.He finished the work as I told him to.方式状语 三个特殊句式（对六种基本句型的操纵） 强调句 12345678He hit me.It was him that hit me.I learned about this project through this site.It was through this site that I learned about this project.It is 名 that 动(名)It is 介宾 that 主谓(宾) 倒装句 1234567891011正常句序：主 谓 (宾)倒装句序：谓 主 (宾） -&gt; 强调加强语气的作用正常：We can win only when we try harder. (情态动词+实意动词 才算一个谓语)倒装：Only when we try harder can we win. 部分倒装正常：The bus comes.倒装： Here comes the bus.正常：The Queen live long!倒装：Long live The Queen! 虚拟语句 假设一个有可能发生的事情–&gt;条件状语If it rains, the event will be canceled. (主将从现) 假设一件不可能发生的事-&gt;虚拟语气现在不可能： If I were a boy, I would be a soldier. (过去时)过去不可能（和既成事实相反）If I had studied English, it would have been easier now.If I hadn’t had that extra cake, I wouldn’t have been feeling guilty.(过去完成) （过去时 + 完成时） 时态 一般（习惯性） 进行（正在发生） 完成（有结果） 完成进行时（持续性：一直在做） 语态 主动语态 1I finished my task. 被动语态 1My task is finished. 非谓语分词： 现在分词（doing）：和主句主语为主动关系 过去分词（done）：和主句主语为被动关系 1234567The boy was lost, failing to find the way back home. ---------------------------------- 非谓语The boy was lost, failed by his poor memory. ------------------------- 非谓语 至此，语法大楼搭建结束，赶紧去拾小砖块。]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-1182C Beautiful Lyrics]]></title>
    <url>%2FCodeforces-1182C-Beautiful-Lyrics.html</url>
    <content type="text"><![CDATA[原题链接 题意： 给出最多1e5个字符串，问求最多能构成多少个字符串四元组，要求四元组的前两个字符串中的元音字母个数相同，后两个元音字母个数相同且还要每个字符串的最后一个元音字母相同 思路： 先对所有字符串用STL嵌套分类，把符合后两个字符串条件的优先先分到一块，然后剩下的元音字母数量相同的在分到一块，最后两两合并 #auto &amp; 表示可以修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;bool isvowel(char ch)&#123; return (ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u');&#125;int getcount(string &amp;str)&#123; int res=0; for(auto ch:str) if(isvowel(ch)) res++; return res;&#125;char getlast(string &amp;str)&#123; for(int i=str.length()-1;i&gt;=0;i--)&#123; if(isvowel(str[i])) return str[i]; &#125;&#125;unordered_map&lt;int,unordered_map&lt;char,vector&lt;string&gt;&gt;&gt; all;vector&lt;pair&lt;string,string&gt;&gt; both1,both2,ans;string a,b;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; string str; cin&gt;&gt;str; all[getcount(str)][getlast(str)].push_back(str); &#125; for(auto &amp;same_count:all)&#123; for(auto &amp;same_last:same_count.second)&#123; while(same_last.second.size()&gt;=2)&#123; a=same_last.second.back(); same_last.second.pop_back(); b=same_last.second.back(); same_last.second.pop_back(); both2.push_back(&#123;a,b&#125;); &#125; &#125; vector&lt;string&gt;rest; for(auto &amp;same_last:same_count.second)&#123; if(same_last.second.size())&#123; rest.push_back(same_last.second.back()); &#125; &#125; while(rest.size()&gt;=2)&#123; a=rest.back(); rest.pop_back(); b=rest.back(); rest.pop_back(); both1.push_back(&#123;a,b&#125;); &#125; &#125; pair&lt;string,string&gt; b1,b2; while(both1.size()&amp;&amp;both2.size())&#123; b1=both1.back(); both1.pop_back(); b2=both2.back(); both2.pop_back(); ans.push_back(&#123;b1.first,b2.first&#125;); ans.push_back(&#123;b1.second,b2.second&#125;); &#125; while(both2.size()&gt;=2)&#123; b1=both2.back(); both2.pop_back(); b2=both2.back(); both2.pop_back(); ans.push_back(&#123;b1.first,b2.first&#125;); ans.push_back(&#123;b1.second,b2.second&#125;); &#125; cout&lt;&lt;ans.size()/2&lt;&lt;'\n'; for(auto s:ans)&#123; cout&lt;&lt;s.first&lt;&lt;' '&lt;&lt;s.second&lt;&lt;'\n'; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>STL</tag>
        <tag>贪心</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[湘潭大学2019程序设计实践]]></title>
    <url>%2F%E6%B9%98%E6%BD%AD%E5%A4%A7%E5%AD%A62019%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5.html</url>
    <content type="text"><![CDATA[抄袭一时爽，查重火葬场因考前会查重，故仅提供思路参考，代码后续补上，有问题欢迎下方评论留言 ericxie官方解析点这里 食用此篇博文代码前建议上网自学一些C++STL容器(set、vector、map等)的用法 1262 Fish贪心，优先队列维护每个池塘能钓到鱼的数量即可，当前池塘有最多鱼的池塘优先出队列 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e3+5;struct fish&#123; int a,b; fish()&#123;&#125; fish(int a,int b):a(a),b(b)&#123;&#125; bool operator &lt; (const fish &amp;hs)const&#123; return a&lt;hs.a; &#125;&#125;;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; priority_queue&lt;fish&gt;pq; int n,m,a,b; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;a,&amp;b); pq.push(fish(a,b)); &#125; int ans=0; fish now; while(m--)&#123; now=pq.top(); pq.pop(); ans+=now.a; now.a=max(0,now.a-now.b); pq.push(now); &#125; printf("%d\n",ans); &#125;&#125; 1271 Color结论：n*m-(x的种类数)*(y的种类数) 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e3+5;set&lt;int&gt;x,y;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; x.clear(); y.clear(); int n,m,k,a,b; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=0;i&lt;k;i++)&#123; scanf("%d%d",&amp;a,&amp;b); x.insert(a); y.insert(b); &#125; printf("%d\n",n*m-x.size()*y.size()); &#125;&#125; 1163 ASCLL直接模拟，输出%05X和%02X即带前导0的十六进制，回车的ASCLL码也要输出，注意输出空格和回车的地方 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+5;string s;int main()&#123; char ch; while(ch=getchar())&#123; if(ch==-1) break; else s+=ch; &#125; int id=0,cnt=0; int lens=s.length(); for(int i=0;i&lt;lens;i++)&#123; if(cnt==0) printf("%05X ",id++); printf("%02X",(int)s[i]); cnt++; if(i!=lens-1)&#123; if(cnt!=16) printf(" "); else&#123; cnt=0; printf("\n"); &#125; &#125; &#125;&#125; 1243 Bob’s Password枚举九个数字会非法的情况即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+5;char s[10];int vis[10];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; for(int i=0;i&lt;10;i++) vis[i]=0; scanf("%s",s); int lens=strlen(s); bool ok=true; for(int i=0;i&lt;lens;i++)&#123; int a=s[i]-'0'; if(i==0)&#123; vis[a]=1; continue; &#125; if(a==1)&#123; if((!vis[2]&amp;&amp;s[i-1]=='3')||(!vis[4]&amp;&amp;s[i-1]=='7')||(!vis[5]&amp;&amp;s[i-1]=='9'))&#123; ok=false; break; &#125; &#125; else if(a==2)&#123; if(!vis[5]&amp;&amp;s[i-1]=='8')&#123; ok=false; break; &#125; &#125; else if(a==3)&#123; if((!vis[2]&amp;&amp;s[i-1]=='1')||(!vis[5]&amp;&amp;s[i-1]=='7')||(!vis[6]&amp;&amp;s[i-1]=='9'))&#123; ok=false; break; &#125; &#125; else if(a==4)&#123; if(!vis[5]&amp;&amp;s[i-1]=='6')&#123; ok=false; break; &#125; &#125; else if(a==6)&#123; if(!vis[5]&amp;&amp;s[i-1]=='4')&#123; ok=false; break; &#125; &#125; else if(a==7)&#123; if((!vis[4]&amp;&amp;s[i-1]=='1')||(!vis[5]&amp;&amp;s[i-1]=='3')||(!vis[8]&amp;&amp;s[i-1]=='9'))&#123; ok=false; break; &#125; &#125; else if(a==8)&#123; if(!vis[5]&amp;&amp;s[i-1]=='2')&#123; ok=false; break; &#125; &#125; else if(a==9)&#123; if((!vis[5]&amp;&amp;s[i-1]=='1')||(!vis[6]&amp;&amp;s[i-1]=='3')||(!vis[8]&amp;&amp;s[i-1]=='7'))&#123; ok=false; break; &#125; &#125; vis[a]=1; &#125; if(ok) puts("Yes"); else puts("No"); &#125;&#125; 1246 Matrix Transposition看半天题意，n,m没用，将输入的x看做y，输入的y看做x，反过来按y优先排序即可 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+5;struct node&#123; int x,y,v; node()&#123;&#125; node(int x,int y,int v):x(x),y(y),v(v)&#123;&#125; bool operator &lt; (const node &amp;b) const&#123; if(y!=b.y) return y&lt;b.y; return x&lt;b.x; &#125;&#125;p[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,m,k; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=0;i&lt;k;i++)&#123; int x,y,v; scanf("%d%d%d",&amp;x,&amp;y,&amp;v); p[i]=node(x,y,v); &#125; sort(p,p+k); for(int i=0;i&lt;k;i++)&#123; printf("%d %d %d\n",p[i].y,p[i].x,p[i].v); &#125; puts(""); &#125;&#125; 1248 Alice and Bob直接模拟，将1作为数字7处理会很好写很多，注意求和依然是+1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;int cnta[10],cntb[10];int suma,sumb;bool pd1()&#123; int a=0,b=0; for(int i=2;i&lt;=7;i++)&#123; if(cnta[i]==3)a=i; if(cntb[i]==3)b=i; &#125; if(a||b)&#123; if(a&amp;&amp;b)&#123; if(a&gt;b) puts("Alice"); else if(a&lt;b) puts("Bob"); else puts("Draw"); &#125; else if(a) puts("Alice"); else if(b) puts("Bob"); return true; &#125; return false;&#125;bool pd2()&#123; int a=0,aa=0,b=0,bb=0; for(int i=2;i&lt;=7;i++)&#123; if(cnta[i]==2)a=i; if(cntb[i]==2)b=i; if(cnta[i]==1)aa=i; if(cntb[i]==1)bb=i; &#125; if(a||b)&#123; if(a&amp;&amp;b)&#123; if(a&gt;b) puts("Alice"); else if(a&lt;b) puts("Bob"); else &#123; if(aa&gt;bb) puts("Alice"); else if(aa&lt;bb) puts("Bob"); else puts("Draw"); &#125; &#125; else if(a) puts("Alice"); else if(b) puts("Bob"); return true; &#125; return false;&#125;bool pd3()&#123; if(suma&gt;sumb) puts("Alice"); else if(suma&lt;sumb) puts("Bob"); else puts("Draw"); return true;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; for(int i=0;i&lt;10;i++) cnta[i]=cntb[i]=0; suma=0,sumb=0; for(int i=0;i&lt;3;i++)&#123; int x; scanf("%d",&amp;x); suma+=x; if(x==1) x=7; cnta[x]++; &#125; for(int i=0;i&lt;3;i++)&#123; int x; scanf("%d",&amp;x); sumb+=x; if(x==1) x=7; cntb[x]++; &#125; if(pd1()); else if(pd2()); else if(pd3()); &#125;&#125; 1251 Colombian Number简单数学，注意到[1,1000000000]区间内数位和在[1,81]内，所以只需在区间[n-81,n]内枚举k看是否能使k+sum(k)==n成立即可 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int calc(int x)&#123; int sum=0; while(x)&#123; sum+=x%10; x/=10; &#125; return sum;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); bool ok=false; for(int i=max(1,n-100);i&lt;n;i++)&#123; if(i+calc(i)==n)&#123; ok=true; break; &#125; &#125; if(ok) puts("No"); else puts("Yes"); &#125;&#125; 1253 Robot贪心，如果在中途转弯肯定不如每次从头走到尾，可以证明最多转n-1次，时间复杂度O($n^2$) 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3+5;int vis[maxn],a[maxn];int main()&#123; int n; while(~scanf("%d",&amp;n))&#123; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; int cnt=0,ans=0; while(1)&#123; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i]&amp;&amp;cnt&gt;=a[i])&#123; vis[i]=1; cnt++; &#125; &#125; if(cnt==n) break; else ans++; for(int i=n;i&gt;=1;i--)&#123; if(!vis[i]&amp;&amp;cnt&gt;=a[i])&#123; vis[i]=1; cnt++; &#125; &#125; if(cnt==n) break; else ans++; &#125; printf("%d\n",ans); &#125;&#125; 1252 Matrix Word统计每个字符在每一行每一列的出现次数，最后判断是否都为1即可 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;char s[maxn][maxn];int x[maxn][26],y[maxn][26];int main()&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; memset(x,0,sizeof(x)); memset(y,0,sizeof(y)); for(int i=1;i&lt;=n;i++)&#123; scanf("%s",s[i]+1); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; x[i][s[i][j]-'a']++; y[j][s[i][j]-'a']++; &#125; &#125; string ans=""; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; if(x[i][s[i][j]-'a']==1 &amp;&amp; y[j][s[i][j]-'a']==1) ans+=s[i][j]; &#125; &#125; cout&lt;&lt;ans&lt;&lt;'\n'; &#125;&#125; 1261 Duplicate Elementsunordered_map或map或set记录每个值是否出现即可,当然也可以用其他的哈希方法 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;using namespace std;const int maxn = 1e4+5;unordered_map&lt;int,int&gt;mp;vector&lt;int&gt;ans;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int main()&#123; int T;T=read(); while(T--)&#123; mp.clear(); int n;n=read(); ans.clear(); for(int i=0;i&lt;n;i++)&#123; int x;x=read(); if(mp.find(x)==mp.end())&#123; ans.push_back(x); mp[x]=1; &#125; &#125; for(int i=0;i&lt;ans.size();i++)&#123; printf("%d%c",ans[i],i==ans.size()-1?'\n':' '); &#125; &#125;&#125; 1263 矩形面积的并哪一年的蓝桥杯原题来着，求出相交矩形的边界,判掉不会相交的情况，在不知道位置相对位置的情况下计算面积注意取绝对值，面积并=两矩形面积和-两矩形面积交 l=max(min(x1,x2),min(x3,x4));r=min(max(x1,x2),max(x3,x4));d=max(min(y1,y2),min(y3,y4));u=min(max(y1,y2),max(y3,y4)); 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int main()&#123; int x1,y1,x2,y2,x3,y3,x4,y4,a,b,c,d; while(~scanf("%d%d%d%d%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;x3,&amp;y3,&amp;x4,&amp;y4))&#123; a=max(min(x1,x2),min(x3,x4)); b=min(max(x1,x2),max(x3,x4)); c=max(min(y1,y2),min(y3,y4)); d=min(max(y1,y2),max(y3,y4)); int sum=abs(x2-x1)*abs(y2-y1)+abs(x4-x3)*abs(y4-y3); if(a&gt;=b||c&gt;=d) printf("%d\n",sum); else printf("%d\n",sum-(b-a)*(d-c)); &#125;&#125; 1268 鞍点输入的时候就记录每行每列的最值即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int minx[maxn],miny[maxn],maxx[maxn],maxy[maxn];int a[maxn][maxn];struct Ans&#123; int x,y,v; Ans()&#123;&#125; Ans(int x,int y,int v):x(x),y(y),v(v)&#123;&#125;&#125;ans[maxn*maxn];inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int main()&#123; int T;T=read(); while(T--)&#123; int n,m;n=read(),m=read(); for(int i=0;i&lt;n;i++) minx[i]=1001,maxx[i]=-1; for(int j=0;j&lt;m;j++) miny[j]=1001,maxy[j]=-1; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; a[i][j]=read(); minx[i]=min(minx[i],a[i][j]); miny[j]=min(miny[j],a[i][j]); maxx[i]=max(maxx[i],a[i][j]); maxy[j]=max(maxy[j],a[i][j]); &#125; &#125; int cnt=0; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if((a[i][j]==minx[i]&amp;&amp;a[i][j]==maxy[j])||(a[i][j]==maxx[i]&amp;&amp;a[i][j]==miny[j]))&#123; ans[cnt++]=Ans(i,j,a[i][j]); &#125; &#125; &#125; if(!cnt) puts("None"); else&#123; printf("%d\n",cnt); for(int i=0;i&lt;cnt;i++)&#123; printf("%d %d %d\n",ans[i].x,ans[i].y,ans[i].v); &#125; &#125; &#125;&#125; 1272 Robot统计L,R,U,D的个数，假定其中有一种没有，那么剩下三种中使多余的那一种变为另外两种的其中一种看是否这两种数目相等 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char s[205]; int L,R,U,D; while(~scanf(&quot;%s&quot;,s))&#123; L=R=U=D=0; int lens=strlen(s); for(int i=0;i&lt;lens;i++)&#123; if(s[i]==&apos;L&apos;) L++; else if(s[i]==&apos;R&apos;) R++; else if(s[i]==&apos;U&apos;) U++; else D++; &#125; bool ok=false; if(!L)&#123; if(R+U==D||R+D==U) ok=true; &#125; else if(!R)&#123; if(L+U==D||L+D==U) ok=true; &#125; else if(!U)&#123; if(R+D==L||L+D==R) ok=true; &#125; else if(!D)&#123; if(R+U==L||L+U==R) ok=true; &#125; if(ok) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125;&#125; 1277 Tri-Triangle找规律然后直接输出 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main() &#123; char ch; while(scanf("%c",&amp;ch)!=EOF) &#123; int n=ch-'A'+1; int space=2*n-1; for(int i=1; i&lt;=n; i++) &#123; for(int j=1;j&lt;=space;j++) printf(" "); for(int k=1;k&lt;=i;k++) printf("%c",64+k); for(int k=i-1;k&gt;=1;k--) printf("%c",64+k); puts(""); space--; &#125; space=n-1; for(int i=1; i&lt;=n; i++) &#123; for(int j=1;j&lt;=space;j++) printf(" "); for(int k=1;k&lt;=i;k++) printf("%c",64+k); for(int k=i-1;k&gt;=1;k--) printf("%c",64+k); for(int j=1;j&lt;=2*space+1;j++) printf(" "); for(int k=1;k&lt;=i;k++) printf("%c",64+k); for(int k=i-1;k&gt;=1;k--) printf("%c",64+k); puts(""); space--; &#125; &#125;&#125; 1280 String Hash就是26进制转10进制 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;typedef __int64 ll;const int P = 1e9+7;const int maxn = 1e3+5;char s[maxn];int main()&#123; while(~scanf("%s",s+1)) &#123; s[0]='b'; int lens=strlen(s); ll ans=0; for(int i=0;i&lt;lens;i++)&#123; ans=(ans*26%P+(s[i]-'a'))%P; &#125; printf("%lld\n",ans); &#125;&#125; 1281 Cute String输入用gets或者循环getchar()，跳过字符串首部空格后，统计中间空格个数便可知道单词个数，看空格个数是否&gt;9和字母种类个数&gt;10即可 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;unordered_map&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; char s[205],ch; while(1)&#123; int cnt=0; ch=getchar(); if(ch==-1) break; s[cnt++]=ch; while(ch=getchar())&#123; if(ch=='\n') break; s[cnt++]=ch; &#125; s[cnt]='\0'; int space=0,lens=strlen(s); int p=0; unordered_map&lt;char,int&gt;mp; while(s[p++]==' '); for(int i=p;i&lt;lens;i++)&#123; if(s[i]==' ') space++; else mp[s[i]]=1; &#125; if(mp.size()&gt;10||space&gt;9) puts("No"); else puts("Yes"); &#125;&#125; 1284 多项式直接求和，求和过程中取模 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;using namespace std;typedef __int64 ll;const int maxn = 1e4+5;ll qpow(ll a,ll b,ll p)&#123; ll res=1%p; while(b)&#123; if(b&amp;1) res=res*a%p; a=a*a%p; b&gt;&gt;=1; &#125; return res;&#125;int a[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,m,x; scanf("%d%d%d",&amp;n,&amp;m,&amp;x); for(int i=n;i&gt;=0;i--) scanf("%d",&amp;a[i]); ll ans=0; for(int i=0;i&lt;=n;i++)&#123; ans=(ans+a[i]*qpow(x,i,m)%m)%m; &#125; printf("%lld\n",ans); &#125;&#125; 1286 比赛当时找的规律+猜结论？ 好像是dp[i]表示冠军最多打i场需要的最多选手人数，那么容易退推出前几项dp[0]=1,dp[1]=2,dp[2]=4… dp[i]=dp[i-1]+dp[i-2]+1，如果n&lt;=dp[i]，那么答案就是i 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;typedef __int64 ll;ll f[105];int main()&#123; f[0]=1; f[1]=2; for(int i=2;i&lt;=85;i++) f[i]=f[i-1]+f[i-2]+1; ll n; while(~scanf("%I64d",&amp;n))&#123; for(int i=0;i&lt;=85;i++)&#123; if(n&lt;=f[i])&#123; printf("%d\n",i); break; &#125; &#125; &#125;&#125; 1291 Buying Gifts要想最大值和最小值相差最小，那么连续的m长连续段礼物价格序列是最有可能的 将价格升序排序后以长度m尺取找出最小价格差即可，由于排好序所以总和肯定取之前的更小 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#define inf 0x3f3f3f3fusing namespace std;typedef __int64 ll;const int maxn = 1e3+5;int a[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); &#125; sort(a,a+n); int d=inf,pos=0; for(int i=0;i&lt;n-m+1;i++)&#123; if(a[i+m-1]-a[i]&lt;d)&#123; d=a[i+m-1]-a[i]; pos=i; &#125; &#125; int sum=0; for(int i=pos;i&lt;=pos+m-1;i++) sum+=a[i]; printf("%d %d\n",d,sum); &#125;&#125; 1292 Co-stringhash预处理+枚举最大长度或者暴力枚举左右端点+剪枝 看statu应该有更简单的解法（直接枚举最大可能长度，找到了就退出 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;string.h&gt;const int maxn = 1e3+5;typedef unsigned long long ull;using namespace std;char s[maxn];int lens;ull base=233;ull p[maxn],hs[maxn];ull geths(int l,int r)&#123; return (ull)hs[r]-p[r-l+1]*hs[l-1];&#125;bool pd(int k)&#123; for(int i=1;i+2*k-1&lt;=lens;i++)&#123; if(geths(i,i+k-1)==geths(i+k,i+2*k-1)) return true; &#125; return false;&#125;int main()&#123; p[0]=1; for(int i=1;i&lt;maxn;i++)&#123; p[i]=p[i-1]*base; &#125; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%s",s+1); lens=strlen(s+1); for(int i=1;i&lt;=lens;i++)&#123; hs[i]=hs[i-1]*base+s[i]; &#125; bool ok=false; for(int i=lens/2;i&gt;=1;i--)&#123; if(pd(i))&#123; ok=true; printf("%d\n",i*2); break; &#125; &#125; if(!ok) puts("0"); &#125;&#125; 1293 Diamond找规律直接输出 1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int T,n; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); for(int i=1; i&lt;=n; i++) &#123; for(int j=1;j&lt;=n-i;j++)printf(" "); for(int j=1;j&lt;=i;j++) printf("%c",65+n-j); for(int j=1;j&lt;=i-1;j++)printf("%c",65+n-i+j); puts(""); &#125; for(int i=n-1;i&gt;=1;i--) &#123; for(int j=1;j&lt;=n-i;j++)printf(" "); for(int j=1;j&lt;=i;j++) printf("%c",65+n-j); for(int j=1;j&lt;=i-1;j++)printf("%c",65+n-i+j); puts(""); &#125; &#125;&#125; 1294 Enquiry维护一个前缀和,sum[i]表示1…i有多少男女相邻的个数 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;const int maxn = 1e4+5;char s[maxn];int sum[maxn];int main()&#123; int T,n; scanf("%d",&amp;T); while(T--)&#123; scanf("%s",s); int lens=strlen(s),cnt=0; sum[0]=0; for(int i=1; i&lt;lens; i++)&#123; if(s[i]!=s[i-1]) cnt++; sum[i]=cnt; &#125; scanf("%d",&amp;n); while(n--) &#123; int l,r; scanf("%d%d",&amp;l,&amp;r); printf("%d\n",sum[r-1]-sum[l-1]); &#125; &#125;&#125; 1296 GCD容斥，与6互素就不会有和6一样的因子2,3，所以[l,r]区间的数减去2和3的倍数再加上6的倍数(计算2和3的倍数时多减了一次)即为答案 12345678910111213#include&lt;stdio.h&gt;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); int cnt2=r/2-(l-1)/2; int cnt3=r/3-(l-1)/3; int cnt6=r/6-(l-1)/6; printf("%d\n",r-l+1-cnt2-cnt3+cnt6); &#125;&#125; 1299 String按题意模拟即可 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char s[105]; while(~scanf("%s",s))&#123; char op[5]; int lens=strlen(s),step=0; while(scanf("%s",op)&amp;&amp;strcmp(op,"END")!=0)&#123; if(op[0]=='S')&#123; int l,r;char ch[5]; scanf("%d%d%s",&amp;l,&amp;r,ch);l--,r--; for(int i=l;i&lt;=r;i++) s[i]=ch[0]; &#125; else&#123; char ss[5],tt[5]; scanf("%s%s",ss,tt); for(int i=0;i&lt;lens;i++) if(s[i]==ss[0]) s[i]=tt[0]; &#125; printf("%d:%s\n",++step,s); &#125; puts(""); &#125;&#125; 1300 Dice按题意模拟即可 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int T; scanf("%d",&amp;T); char s[10]; int n,m,k,cnt[10]; while(T--)&#123; scanf("%s",s); for(int i=1;i&lt;=6;i++) cnt[i]=0; for(int i=0;i&lt;6;i++) cnt[s[i]-'0']++; scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;n,&amp;k); int num=cnt[k]; if(k!=1) num+=cnt[1]; printf("%d:%s\n",i,num&gt;=n?"true":"false"); &#125; puts(""); &#125;&#125; 1301 Zeroes按题意模拟循环1000次即可 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;algorithm&gt;int main()&#123; int T; scanf("%d",&amp;T); int a[20]; while(T--)&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); bool ok; for(int k=0;k&lt;=1000;k++)&#123; ok=true; for(int i=0;i&lt;n;i++)&#123; if(a[i]) ok=false; &#125; if(ok)&#123; printf("%d\n",k); break; &#125; int tmp=a[0]; for(int i=0;i&lt;n-1;i++)&#123; a[i]=abs(a[i]-a[i+1]); &#125; a[n-1]=abs(a[n-1]-tmp); &#125; if(!ok) puts("Impossible"); &#125;&#125; 1305 斐波那契区间直接扫描一遍即可，注意防止越界，如果中途a[i]+a[i+1]!=a[i+2],那么左端点起点重新从i+1开始 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;algorithm&gt;const int maxn = 1e4+5;int a[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); int ans=0; for(int i=0;i&lt;n;i++)&#123; int cnt=2; while(i+2&lt;n&amp;&amp;a[i]+a[i+1]==a[i+2])&#123; cnt++; i++; &#125; if(cnt&gt;ans) ans=cnt; &#125; printf("%d\n",ans); &#125;&#125; 1308 比赛按题意模拟计算即可 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;algorithm&gt;const int maxn = 1e4+5;int a[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); int rounds=0,fields=0; while(n&gt;1)&#123; int k=2; while(k&lt;=n) k*=2; k/=2; fields+=k/2; rounds++; n-=k/2; &#125; printf("%d %d\n",rounds,fields); &#125;&#125; 1239 2048巨恶心的大模拟，建议直接写相关函数每次调用，方便调试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;int a[5][5],tmp[5];void gatherL(int k)&#123; int cnt=0; for(int j=1;j&lt;=4;j++)&#123; if(a[k][j]) tmp[++cnt]=a[k][j]; a[k][j]=0; &#125; for(int i=1;i&lt;=cnt;i++) a[k][i]=tmp[i];&#125;void gatherR(int k)&#123; int cnt=4; for(int j=4;j&gt;=1;j--)&#123; if(a[k][j]) tmp[cnt--]=a[k][j]; a[k][j]=0; &#125; for(int i=4;i&gt;cnt;i--) a[k][i]=tmp[i];&#125;void gatherU(int k)&#123; int cnt=0; for(int i=1;i&lt;=4;i++)&#123; if(a[i][k]) tmp[++cnt]=a[i][k]; a[i][k]=0; &#125; for(int i=1;i&lt;=cnt;i++) a[i][k]=tmp[i];&#125;void gatherD(int k)&#123; int cnt=4; for(int i=4;i&gt;=1;i--)&#123; if(a[i][k]) tmp[cnt--]=a[i][k]; a[i][k]=0; &#125; for(int i=4;i&gt;cnt;i--) a[i][k]=tmp[i];&#125;void LEFT() &#123; for(int i=1;i&lt;=4;i++)&#123; gatherL(i); for(int j=1;j&lt;=3;j++)&#123; if(a[i][j]==a[i][j+1])&#123; a[i][j]*=2; a[i][j+1]=0; gatherL(i); &#125; &#125; &#125;&#125;void RIGHT() &#123; for(int i=1;i&lt;=4;i++)&#123; gatherR(i); for(int j=4;j&gt;=2;j--)&#123; if(a[i][j]==a[i][j-1])&#123; a[i][j]*=2; a[i][j-1]=0; gatherR(i); &#125; &#125; &#125;&#125;void UP() &#123; for(int j=1;j&lt;=4;j++)&#123; gatherU(j); for(int i=1;i&lt;=3;i++)&#123; if(a[i][j]==a[i+1][j])&#123; a[i][j]*=2; a[i+1][j]=0; gatherU(j); &#125; &#125; &#125;&#125;void DOWN() &#123; for(int j=1;j&lt;=4;j++)&#123; gatherD(j); for(int i=4;i&gt;=2;i--)&#123; if(a[i][j]==a[i-1][j])&#123; a[i][j]*=2; a[i-1][j]=0; gatherD(j); &#125; &#125; &#125;&#125;int main() &#123; int T; scanf("%d",&amp;T); while(T--) &#123; for(int i=1; i&lt;=4; i++) &#123; for(int j=1; j&lt;=4; j++) &#123; scanf("%d",&amp;a[i][j]); &#125; &#125; char op[10]; scanf("%s",op); if(op[0]=='L') LEFT(); else if(op[0]=='R') RIGHT(); else if(op[0]=='U') UP(); else DOWN(); for(int i=1; i&lt;=4; i++) &#123; for(int j=1; j&lt;=4; j++) &#123; printf("%d%c",a[i][j],j==4?'\n':' '); &#125; &#125; puts(""); &#125;&#125; 1264 字符不重复子串如果是简单的求长度就直接用两个指针+标记数组做就好了，有点像滑动窗口 这里要用动态规划，pre[s[i]]为前一个s[i]的位置，f[i]表示以s[i]结尾的最长不重复子串长度 那么对于s[i]有两种情况，一是s[i]在前面未出现，那么f[i]=f[i-1]+1；二是前面已经出现了s[i]，如果控制的区间左端点l在pre[s[i]]前面，说明当前控制的区间中有部分要跳过，f[i]=i-pre[s[i]]，区间要缩小，否则依然是f[i]=f[i-1]+1 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e4+5;char s[maxn];int pre[26],f[maxn];int main() &#123; ios::sync_with_stdio(false); cin.tie(0); while(cin&gt;&gt;s)&#123; for(int i=0;i&lt;26;i++) pre[i]=-1; int ans=1,lens=strlen(s); int l=0; pre[s[0]-'a']=0; f[0]=1; for(int i=1;i&lt;lens;i++)&#123; int ch=s[i]-'a'; if(pre[ch]==-1) f[i]=f[i-1]+1; else&#123; if(l&lt;=pre[ch])&#123; f[i]=i-pre[ch]; l=pre[ch]+1; &#125; else&#123; f[i]=f[i-1]+1; &#125; &#125; pre[s[i]-'a']=i; ans=max(ans,f[i]); &#125; string ss=s; set&lt;string&gt;anss; for(int i=0;i&lt;lens;i++)&#123; if(f[i]==ans)&#123; anss.insert(ss.substr(i-ans+1,ans)); &#125; &#125; cout&lt;&lt;ans&lt;&lt;'\n'; for(set&lt;string&gt;::iterator it=anss.begin();it!=anss.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;'\n'; &#125; &#125;&#125; 1273 Set用set或map或其他容器等统计数字种类数，种类数&lt;=3肯定可以，&gt;4肯定不行，==4特判一下 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;inline int read(int &amp;x)&#123; x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); vector&lt;int&gt;v; for(int i=0;i&lt;n;i++)&#123; int x;read(x); v.push_back(x); &#125; sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end()); bool ok=false; if(v.size()&lt;=3) ok=true; else if(v.size()&gt;4) ok=false; else &#123; if(v[0]+v[1]==v[2]+v[3]||v[0]+v[2]==v[1]+v[3]||v[0]+v[3]==v[1]+v[2]) ok=true; &#125; if(ok) puts("Yes"); else puts("No"); &#125;&#125; 1274 Matrix很容易看出规律$ans=1+2^2+2^2+1+4^2+4^2+1+…+(2n)^2+(2n)^2+1$ 由于$1^2+2^2+3^2+…+n^2=n(n+1)(2n+1)/6$ 可以推出$2^2+4^2+6^2+…+(2n)^2=2n(n+1)(2n+1)/3$ 因为答案要取模,又因为公式中有除法需用到数论中逆元的知识解决，即(a/b)%p=a*(b^(p-2))%p，p为素数 当然也可以直接上Java大数，最终结果再取模 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;typedef __int64 ll;const int P = 1e9+7;ll qmul(ll a,ll b,ll p)&#123; ll res=0; while(b)&#123; if(b&amp;1) res=res+a%p; a=a+a%p; b&gt;&gt;=1; &#125; return res;&#125;ll qpow(ll a,ll b,ll p)&#123; ll res=1; while(b)&#123; if(b&amp;1) res=res*a%p; a=a*a%p; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; ll n; while(scanf("%I64d",&amp;n)&amp;&amp;n)&#123; ll num1=(n+1)/2; ll m=n/2; ll ans=(num1+(4*(m*(m+1)%P*(2*m+1)%P)%P)*qpow(3,P-2,P)%P)%P; if(n%2==0) ans-=qmul(n,n,P); while(ans&lt;0) ans+=P; printf("%I64d\n",ans); &#125;&#125; 1275 Exam Schedule直接模拟 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;string.h&gt;int sche[10][20];struct Ans&#123; int d,s,t;&#125;ans[30];char table[5][10]=&#123;"Mon","Tue","Wen","Thur","Fri"&#125;;int pd(int d,int s,int t)&#123; for(int i=s;i&lt;=t;i++)&#123; if(sche[d][i]) return 0; &#125; return 1;&#125;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; memset(sche,0,sizeof(sche)); int n,k; scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;n;i++)&#123; char day[5];int s,t; scanf("%s%d%d",day,&amp;s,&amp;t); if(strcmp(day,"Mon")==0)&#123; for(int i=s;i&lt;=t;i++) sche[1][i]=1; &#125; else if(strcmp(day,"Tue")==0)&#123; for(int i=s;i&lt;=t;i++) sche[2][i]=1; &#125; else if(strcmp(day,"Wen")==0)&#123; for(int i=s;i&lt;=t;i++) sche[3][i]=1; &#125; else if(strcmp(day,"Thur")==0)&#123; for(int i=s;i&lt;=t;i++) sche[4][i]=1; &#125; else if(strcmp(day,"Fri")==0)&#123; for(int i=s;i&lt;=t;i++) sche[5][i]=1; &#125; &#125; int cnt=0; for(int d=1;d&lt;=5;d++)&#123; for(int i=1;i&lt;=4;i++)&#123; if(4-i+1&gt;=k&amp;&amp;pd(d,i,i+k-1))&#123; ans[cnt].d=d-1; ans[cnt].s=i; ans[cnt].t=i+k-1; cnt++; &#125; &#125; for(int i=5;i&lt;=8;i++)&#123; if(8-i+1&gt;=k&amp;&amp;pd(d,i,i+k-1))&#123; ans[cnt].d=d-1; ans[cnt].s=i; ans[cnt].t=i+k-1; cnt++; &#125; &#125; for(int i=9;i&lt;=11;i++)&#123; if(11-i+1&gt;=k&amp;&amp;pd(d,i,i+k-1))&#123; ans[cnt].d=d-1; ans[cnt].s=i; ans[cnt].t=i+k-1; cnt++; &#125; &#125; &#125; printf("%d\n",cnt); for(int i=0;i&lt;cnt;i++)&#123; printf("%s %d %d\n",table[ans[i].d],ans[i].s,ans[i].t); &#125; &#125;&#125; 1170 ICPC统计每列的最高等级和所有列最高等级的出现次数即可 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;char s[3][105];int cnt[5],Min[105];int main()&#123; int n; while(scanf("%d",&amp;n),n)&#123; for(int i=0;i&lt;3;i++)&#123; scanf("%s",s[i]); &#125; for(int i=0;i&lt;5;i++) cnt[i]=0; for(int j=0;j&lt;n;j++)&#123; Min[j]=10; for(int i=0;i&lt;3;i++)&#123; Min[j]=min(Min[j],s[i][j]-'A'); &#125; for(int i=0;i&lt;5;i++)&#123; if(Min[j]==i) cnt[i]++; &#125; &#125; for(int j=0;j&lt;n;j++) printf("%c",Min[j]+'A');puts(""); for(int i=0;i&lt;5;i++) printf("%d%c",cnt[i],i==4?'\n':' '); &#125;&#125; 1241 Permutation首先先学习一下置换的定义和置换乘法的性质，离散数学刘任任版P190 其实就是要通过不断映射使得序列回到初始序列 如果暴力模拟，可能会卡成O(n!)的复杂度，即全排列的情况 其实只需要计算对每一个数使a[i]变为i的次数，然后计算所有次数的最小公倍数即为答案 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;typedef __int64 ll;using namespace std;const int maxn = 105;int a[maxn];int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; int ans=1; for(int i=1;i&lt;=n;i++)&#123; int cnt=1,p=a[i]; while(p!=i)&#123; cnt++; p=a[p]; &#125; ans=ans/__gcd(ans,cnt)*cnt; &#125; printf("%d\n",ans); &#125;&#125; 1249 Alice’s Prime首先一位的素数只有2,3,5,7，然后dfs将这四个数后面不断添加1,3,5,7,9再判断素数，最后排个序 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;typedef __int64 ll;using namespace std;vector&lt;int&gt;ans;bool pd(ll x)&#123; for(ll i=2;i*i&lt;=x;i++)&#123; if(x%i==0) return false; &#125; return true;&#125;void dfs(ll x)&#123; if(x&gt;INT_MAX) return; for(int i=1;i&lt;=9;i+=2)&#123; if(pd(x*10+i))&#123; ans.push_back(x*10+i); dfs(x*10+i); &#125; &#125;&#125;int main() &#123; ans.push_back(2); ans.push_back(3); ans.push_back(5); ans.push_back(7); for(int i=0;i&lt;4;i++)&#123; dfs(ans[i]); &#125; sort(ans.begin(),ans.end()); for(int i=0;i&lt;ans.size();i++)&#123; printf("%d %d\n",i+1,ans[i]); &#125;&#125; 1266 RGB统计R,G,B的出现次数，在0…R-1统计G,B的出现次数，记为R1,R2，在R…R+G-1统计R,B的出现次数，记为G1,G2，在R+G…lens-1统计R,G的出现次数，记为B1,B2 那么首先肯定是两个两个区间互相交换，R1,G1交换，R2,B1交换和G2,B2交换，有可能交换不完，成为0…R-1还有’G’，R…R+G-1还有’B’，R+G…lens-1还有’R’的情况，那对于每个未交换字符的需要交换2次 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;typedef __int64 ll;using namespace std;const int maxn = 1e4+5;char s[maxn];int main() &#123; while(~scanf("%s",s))&#123; int lens=strlen(s); int R=0,G=0,B=0; for(int i=0;i&lt;lens;i++)&#123; if(s[i]=='R') R++; else if(s[i]=='G') G++; else B++; &#125; int R1=0,R2=0; //0...R-1 G,B for(int i=0;i&lt;R;i++)&#123; if(s[i]=='G') R1++; else if(s[i]=='B')R2++; &#125; int G1=0,G2=0; //R...R+G-1 R,B for(int i=R;i&lt;R+G;i++)&#123; if(s[i]=='R') G1++; else if(s[i]=='B') G2++; &#125; int B1=0,B2=0; //R+G...lens-1 R,G for(int i=R+G;i&lt;lens;i++)&#123; if(s[i]=='R') B1++; else if(s[i]=='G') B2++; &#125; int tmp=0,ans=0; if(R1&amp;&amp;G1)&#123; tmp=min(R1,G1); ans+=tmp; R1-=tmp; G1-=tmp; &#125; if(R2&amp;&amp;B1)&#123; tmp=min(R2,B1); ans+=tmp; R2-=tmp; B1-=tmp; &#125; if(G2&amp;&amp;B2)&#123; tmp=min(G2,B2); ans+=tmp; G2-=tmp; B2-=tmp; &#125; ans+=(R1+R2+G1+G2+B1+B2)/3*2; printf("%d\n",ans); &#125;&#125; 1267 Matrix直接模拟 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 15;int a[maxn][maxn],b[maxn][maxn];int tmp[maxn];int n,m;void swapx(int x,int y)&#123; for(int i=1;i&lt;=m;i++) tmp[i]=a[x][i]; for(int i=1;i&lt;=m;i++) a[x][i]=a[y][i]; for(int i=1;i&lt;=m;i++) a[y][i]=tmp[i];&#125;void swapy(int x,int y)&#123; for(int i=1;i&lt;=n;i++) tmp[i]=a[i][x]; for(int i=1;i&lt;=n;i++) a[i][x]=a[i][y]; for(int i=1;i&lt;=n;i++) a[i][y]=tmp[i];&#125;int main()&#123; char op[5]; int x,y; while(~scanf("%s",op))&#123; if(strcmp(op,"IN")==0)&#123; scanf("%d%d",&amp;n,&amp;m); int num=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; a[i][j]=++num; &#125; &#125; &#125; else if(strcmp(op,"SR")==0)&#123; scanf("%d%d",&amp;x,&amp;y); swapx(x,y); &#125; else if(strcmp(op,"SC")==0)&#123; scanf("%d%d",&amp;x,&amp;y); swapy(x,y); &#125; else if(strcmp(op,"TR")==0)&#123; for(int j=1;j&lt;=m;j++)&#123; for(int i=1;i&lt;=n;i++)&#123; b[j][i]=a[i][j]; &#125; &#125; swap(n,m); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; a[i][j]=b[i][j]; &#125; &#125; &#125; else if(strcmp(op,"FR")==0)&#123; for(int i=1,j=n;i&lt;=n/2;i++,j--)&#123; swapx(i,j); &#125; &#125; else if(strcmp(op,"FC")==0)&#123; for(int i=1,j=m;i&lt;=m/2;i++,j--)&#123; swapy(i,j); &#125; &#125; else if(strcmp(op,"PR")==0)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; printf("%d%c",a[i][j],j==m?'\n':' '); &#125; &#125; puts(""); &#125; &#125;&#125; 1279 Dual Prime素数打表，1e6以内最多不到1e5个素数，然后枚举任意两个不同的素数，弄个前缀和维护1..i 内符合条件的个数 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;int p[maxn],sum[maxn];int cnt=0;bool isp[maxn];void getprime()&#123; memset(isp,true,sizeof(isp)); isp[0]=isp[1]=false; isp[2]=true; for(int i=2;i&lt;maxn;i++)&#123; if(isp[i]) p[cnt++]=i; for(int j=0;j&lt;cnt&amp;&amp;p[j]*i&lt;maxn;j++)&#123; isp[p[j]*i]=false; &#125; &#125;&#125;void getsum()&#123; for(int i=0;i&lt;cnt;i++)&#123; for(int j=0;j&lt;cnt;j++)&#123; if(i==j) continue; if(p[i]*p[j]&lt;maxn) sum[p[i]*p[j]]=1; else break; &#125; &#125; for(int i=1;i&lt;maxn;i++)&#123; sum[i]+=sum[i-1]; &#125;&#125;int main() &#123; getprime(); getsum(); int T; scanf("%d",&amp;T); while(T--)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); printf("%d\n",sum[r]-sum[l-1]); &#125;&#125; 1283 Good Number首先n位数第一位必须是1，满足条件只需要n-1个数中的1的个数&gt;=0的个数，那么对n-1分奇偶谈论 n-1为奇，$ans=C_{n-1}^{n/2}+C_{n-1}^{n/2+1}+…+C_{n-1}^{n-1}$ n-1为偶，$ans=C_{n-1}^{n-1/2}+C_{n-1}^{n-1/2+1}+…+C_{n-1}^{n-1}$ n==1特判下，组合数用杨辉三角打表就好 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;ll C[70][70];void getC()&#123; for(int i=1;i&lt;=65;i++)&#123; C[i][0]=C[i][i]=1; for(int j=1;j&lt;i;j++)&#123; C[i][j]=C[i-1][j-1]+C[i-1][j]; &#125; &#125;&#125;int main() &#123; getC(); int n; while(~scanf("%d",&amp;n))&#123; if(n==1)&#123; puts("1"); continue; &#125; ll ans=0; if(n-1%2)&#123; for(int i=n/2;i&lt;=n-1;i++)&#123; ans+=C[n-1][i]; &#125; &#125; else&#123; for(int i=(n-1)/2;i&lt;=n-1;i++)&#123; ans+=C[n-1][i]; &#125; &#125; printf("%I64d\n",ans); &#125;&#125; 1287 银行因为所有业务在当天，则可以把时间化为分钟数，然后枚举一天的所有分钟24*60=1440 对于每一分钟，如果有新的用户来了，则加入优先队列；如果过了上一个业务办理的时间，把队列中等待超时的出队列，然后队列中选一个优先级最高的业务开始处理 每个业务的等待时间：超时的就是最大等待时间，没超时的就是当前处理时间-业务开始时间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 205;struct user&#123; string id; int i,s,t,d,ans; bool done; user()&#123;&#125; user(string id,int i,int s,int t,int d,bool done):id(id),i(i),s(s),t(t),d(d),done(done)&#123;&#125; bool operator &lt; (const user &amp;hs)const&#123; if(id[0]!=hs.id[0]) return id[0]!='V'; return s&gt;hs.s; &#125;&#125;p[maxn];int main()&#123; char id[10]; int h,m,t,d,cnt=0; while(~scanf("%s%d:%d%d%d",id,&amp;h,&amp;m,&amp;t,&amp;d))&#123; p[cnt]=user(id,cnt,h*60+m,t,d,false); p[cnt].ans=p[cnt].d; cnt++; &#125; int nowtime=0,k=0; priority_queue&lt;user&gt;pq; for(int i=1;i&lt;=1440;i++)&#123; if(k&lt;cnt&amp;&amp;i&gt;=p[k].s)&#123; pq.push(p[k++]); &#125; if(i&gt;=nowtime)&#123; while(!pq.empty()&amp;&amp;pq.top().s+pq.top().d&lt;nowtime) pq.pop(); if(!pq.empty())&#123; user tmp=pq.top(); pq.pop(); p[tmp.i].done=true; p[tmp.i].ans=i-tmp.s; nowtime=i+tmp.t; &#125; &#125; &#125; for(int i=0;i&lt;cnt;i++)&#123; cout&lt;&lt;p[i].id&lt;&lt;' '&lt;&lt;p[i].ans&lt;&lt;' '&lt;&lt;(p[i].done?"Yes":"No")&lt;&lt;'\n'; &#125;&#125; 1295 Flawless Prime首先判断数位是否有0，存在0肯定不是，然后依次去掉最高位暴力判断是否为素数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;bool has0(int x)&#123; while(x)&#123; if(x%10==0) return true; x/=10; &#125; return false;&#125;bool isprime(int x)&#123; if(x==1) return false; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0) return false; &#125; return true;&#125;int len(int x)&#123; int res=0; while(x)&#123; res++; x/=10; &#125; return res;&#125;bool pd(int x)&#123; while(x)&#123; if(!isprime(x)) return false; int cnt=len(x); int tmp=1; for(int i=1;i&lt;cnt;i++) tmp*=10; x%=tmp; &#125; return true;&#125;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); if(has0(n) || !pd(n)) puts("No"); else puts("Yes"); &#125;&#125; 1297 Homework发现与题目号无关，只需要通过学号和排名的关系来用map记录对应学号的积分，最后算出成绩排个序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;unordered_map&lt;int,int&gt;mp;struct stu&#123; int sid,grade; stu()&#123;&#125; stu(int a,int b):sid(a),grade(b)&#123;&#125; bool operator &lt; (const stu &amp;b)const&#123; if(grade==b.grade) return sid&lt;b.sid; return grade&gt;b.grade; &#125;&#125;s[maxn];int main()&#123; int pid,sid,prank; int MaxS=0; while(~scanf("%d%d%d",&amp;pid,&amp;sid,&amp;prank))&#123; if(1&lt;=prank&amp;&amp;prank&lt;=12)&#123; mp[sid]+=32; &#125; else if(13&lt;=prank&amp;&amp;prank&lt;=24)&#123; mp[sid]+=16; &#125; else if(25&lt;=prank&amp;&amp;prank&lt;=48)&#123; mp[sid]+=8; &#125; else if(49&lt;=prank&amp;&amp;prank&lt;=96)&#123; mp[sid]+=4; &#125; else if(97&lt;=prank&amp;&amp;prank&lt;=192)&#123; mp[sid]+=2; &#125; else&#123; mp[sid]+=1; &#125; MaxS=max(MaxS,mp[sid]); &#125; int cnt=0; for(unordered_map&lt;int,int&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123; s[cnt++]=stu(it-&gt;first,round(100+10*log(it-&gt;second*1.0/MaxS))); &#125; sort(s,s+cnt); for(int i=0;i&lt;cnt;i++)&#123; printf("%d %d\n",s[i].sid,s[i].grade); &#125;&#125; 1304 ZUMA!模拟把c放到第i个和第i+1个之间后的结果，然后答案取最大值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 105;int n,c;int b[maxn];int tmp[maxn],a[maxn];int func(int x)&#123; for(int i=0;i&lt;n;i++) a[i]=b[i]; int cnt=1; int i=x,j=x+1,p=0; while(i&gt;=0&amp;&amp;a[i]==c)&#123; i--; cnt++; &#125; while(j&lt;n&amp;&amp;a[j]==c)&#123; j++; cnt++; &#125; if(cnt&lt;3) return 0; else&#123; for(int k=0;k&lt;=i;k++) tmp[p++]=a[k]; for(int k=j;k&lt;n;k++) tmp[p++]=a[k]; &#125; for(int i=0;i&lt;p;i++) a[i]=tmp[i]; while(1)&#123; int pp=0; for(int i=0;i&lt;p;i++)&#123; cnt=1; while(i+1&lt;p&amp;&amp;a[i]==a[i+1])&#123; cnt++; i++; &#125; if(cnt&lt;3)&#123; for(int k=i-cnt+1;k&lt;=i;k++) tmp[pp++]=a[k]; &#125; &#125; if(pp==p) break; for(int i=0;i&lt;pp;i++) a[i]=tmp[i]; p=pp; &#125; return n-p;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;c); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;b[i]); &#125; int ans=0; for(int i=0;i&lt;n-1;i++)&#123; ans=max(ans,func(i)); &#125; printf("%d\n",ans); &#125;&#125; 1307 Beautiful Number二进制枚举0的位置和二进制串的长度，对于64位整数第63位是符号位，唯一的0前面必须有1，不然就会成为前导0，如果0…61个位置中的第i个位置为0，那么len…i+1的位置为1，i-1…0的位置也为1， 计算出所有这样的数后排序，求答案每次遍历即可 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;int main()&#123; vector&lt;ll&gt;v; for(int i=0;i&lt;62;i++)&#123; for(int len=62;len&gt;=i+1;len--)&#123; ll res=0; for(int j=len;j&gt;=i+1;j--)&#123; res=res*2+1; &#125; res*=2; for(int j=i-1;j&gt;=0;j--)&#123; res=res*2+1; &#125; v.push_back(res); &#125; &#125; sort(v.begin(),v.end()); int T; scanf("%d",&amp;T); while(T--)&#123; ll l,r; scanf("%I64d%I64d",&amp;l,&amp;r); int ans=0; for(int i=0;i&lt;v.size();i++)&#123; if(l&lt;=v[i]&amp;&amp;v[i]&lt;=r) ans++; else if(v[i]&gt;r) break; &#125; printf("%d\n",ans); &#125;&#125; 1309 唯一的子串枚举左端点取出子串丢到set或map中去重，自动排序 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int m;char str[105]; scanf("%d%s",&amp;m,str); string s=str; map&lt;string,int&gt;mp; for(int i=0;i+m-1&lt;s.length();i++)&#123; mp.insert(&#123;s.substr(i,m),1&#125;); &#125; for(map&lt;string,int&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123; cout&lt;&lt;it-&gt;first&lt;&lt;'\n'; &#125; puts(""); &#125;&#125; 1270 Unique Digit Number看top应该可以推公式，根据排列组合可以算出位数为1…10的符合条件数的个数…然后不会了 只会暴力dfs打表，根据位数打表就可以确保大小顺序，然后注意0不能作为前导 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 9e6+5;ll ans[maxn];int cnt,vis[10];void dfs(ll x,int k,int len)&#123; if(k==len)&#123; ans[++cnt]=x; return; &#125; for(int i=0;i&lt;10;i++)&#123; if(i==0&amp;&amp;k&gt;0&amp;&amp;!vis[0])&#123; vis[i]=1; dfs(x*10+i,k+1,len); vis[i]=0; &#125; if(i&amp;&amp;!vis[i])&#123; vis[i]=1; dfs(x*10+i,k+1,len); vis[i]=0; &#125; &#125;&#125;int main()&#123; ans[++cnt]=0; for(int len=1;len&lt;=10;len++)&#123; dfs(0,0,len); &#125; int n; while(~scanf("%d",&amp;n))&#123; printf("%I64d\n",ans[n]); &#125;&#125; 1289 3的倍数一道神奇的动态规划，输入为s[]字符串数组，能被3整除说明新的数的数位和%3=0 f[i][j]表示以s[i]为前导的所有新正整数数中 %3==j 的种类数 对于s[i]分数码%3=0,1,2的3种情况讨论，且对于每个s[i]又分取和不取2种情况，这样f[i]可由f[i+1]递推而来，最后f[0][0]是包含所有s[i]为前导的数%3=0的种类数，此时答案包含前导0的情况 因为不能有前导0，所以去掉所有以s[i]==0为前导的的种类数，就是f[0][0]-(f[i+1][0]+1)，即当前位是0，后面符合条件共有f[i+1][0]种，然后后面全部不选，只选0也满足，所以减掉f[i+1]+1 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 5005;const int P = 1e9+7;char s[maxn];int f[maxn][3];int main()&#123; while(~scanf("%s",s))&#123; int lens=strlen(s); f[lens][0]=f[lens][1]=f[lens][2]=0; for(int i=lens-1;i&gt;=0;i--)&#123; int x=(s[i]-'0')%3; if(x==0)&#123; f[i][0]=(f[i+1][0]+f[i+1][0]+1)%P; f[i][1]=(f[i+1][1]+f[i+1][1])%P; f[i][2]=(f[i+1][2]+f[i+1][2])%P; &#125; else if(x==1)&#123; f[i][0]=(f[i+1][0]+f[i+1][2])%P; f[i][1]=(f[i+1][1]+f[i+1][0]+1)%P; f[i][2]=(f[i+1][2]+f[i+1][1])%P; &#125; else &#123; f[i][0]=(f[i+1][0]+f[i+1][1])%P; f[i][1]=(f[i+1][1]+f[i+1][2])%P; f[i][2]=(f[i+1][2]+f[i+1][0]+1)%P; &#125; &#125; int ans=f[0][0]; for(int i=0;i&lt;lens;i++)&#123; if(s[i]=='0') ans=(ans-(f[i+1][0]+1))%P; &#125; while(ans&lt;0) ans+=P; printf("%d\n",ans); &#125;&#125; 1303 Sequence乍一看以为是贪心，每次取较大的一端，其实这样有问题 记忆化搜索（备忘录），直接深搜的话对于当前长度都有两个选择，要么取左端点要么取右端点，时间复杂度O($2^n$) ans[l][r]表示区间l,r的最优解，回溯的时候如果已经求出了子区间的，直接返回对应值即可，不必重复计算 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 65;ll a[maxn],b[maxn];ll ans[maxn][maxn];ll dfs(int l,int r,int k)&#123; if(l&gt;r) return 0; if(ans[l][r]) return ans[l][r]; return ans[l][r]=min(a[l]*b[k-1]+dfs(l+1,r,k+1),a[r]*b[k-1]+dfs(l,r-1,k+1));&#125;int main()&#123; b[0]=1; for(int i=1;i&lt;60;i++) b[i]=b[i-1]*2; int T; scanf("%d",&amp;T); while(T--)&#123; memset(ans,0,sizeof(ans)); int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%I64d",&amp;a[i]); &#125; printf("%I64d\n",dfs(1,n,1)); &#125;&#125; 1244 Estrella’s Chocolate求最小的最大值，二分最大热量 以当前最大热量值吃完所有巧克力所需天数&gt;m，说明最大热量需要再大一些，左指针右移；反过来同理 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e4+5;int n,m;int a[maxn];int pd(int x)&#123; int day=1,sum=0; for(int i=0;i&lt;n;i++)&#123; if(sum+a[i]&lt;=x) sum+=a[i]; else&#123; day++; sum=a[i]; &#125; &#125; return day&lt;=m;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); &#125; int l=*max_element(a,a+n),r=1e9; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(pd(mid)) r=mid; else l=mid+1; &#125; printf("%d\n",l); &#125;&#125; 1269 Craftman求制作手套最大值，二分手套件数 如果制作当前x件所需多余原料数&gt;k，说明原材料不够，右指针左移；反过来同理 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e3+5;int n,k;ll a[maxn],b[maxn];bool pd(ll x)&#123; ll need=0; for(int i=0;i&lt;n;i++)&#123; need+=(x*a[i]-b[i]&gt;0?x*a[i]-b[i]:0); &#125; return need&lt;=k;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;n;i++) scanf("%I64d",&amp;a[i]); for(int i=0;i&lt;n;i++) scanf("%I64d",&amp;b[i]); ll l=0,r=*max_element(b,b+n)+k; while(l&lt;r)&#123; ll mid=(l+r+1)&gt;&gt;1; if(pd(mid)) l=mid; else r=mid-1; &#125; printf("%I64d\n",l); &#125;&#125; 1167 逆序数（大数据）既然是大数据，暴力O($n^2$)肯定T 树状数组或者归并排序O(nlogn) 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e4+5;int n;int a[maxn],b[maxn],c[maxn];int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int v)&#123; while(x&lt;=n)&#123; c[x]+=v; x+=lowbit(x); &#125;&#125;int sum(int x)&#123; int res=0; while(x)&#123; res+=c[x]; x-=lowbit(x); &#125; return res;&#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; memset(c,0,sizeof(c)); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); b[i]=a[i]; &#125; sort(b,b+n); int m=unique(b,b+n)-b; for(int i=0;i&lt;n;i++)&#123; a[i]=lower_bound(b,b+m,a[i])-b+1; &#125; int ans=0; for(int i=n-1;i&gt;=0;i--)&#123; ans+=sum(a[i]-1); add(a[i],1); &#125; printf("%d\n",ans); &#125;&#125; 1160 猜数字需要满足所有的k个条件，则需要把询问存起来离线操作，然后枚举$C_n^4$个的所有组合，回溯法或者直接枚举，对于每个组合看是否满足这k个询问 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 3e5+5;const int maxk = 105;int n,K;int x[maxk],y[maxk];int a[maxk][5],b[5],vis[maxn],cnt;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;bool pd()&#123; for(int k=0;k&lt;K;k++)&#123; int xx=0,yy=0; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; if(i==j&amp;&amp;a[k][i]==b[j]) xx++; if(i!=j&amp;&amp;a[k][i]==b[j]) yy++; &#125; &#125; if(x[k]!=xx||y[k]!=yy)return false; &#125; return true;&#125;void dfs(int k)&#123; if(k==4)&#123; if(pd())&#123; cnt++; printf("%d %d %d %d\n",b[0],b[1],b[2],b[3]); &#125; return; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i])&#123; vis[i]=1; b[k]=i; dfs(k+1); vis[i]=0; &#125; &#125;&#125;int main()&#123; while(n=read())&#123; K=read(); for(int i=0;i&lt;K;i++)&#123; for(int j=0;j&lt;4;j++) a[i][j]=read(); x[i]=read(),y[i]=read(); &#125; cnt=0; dfs(0); printf("%d\n",cnt); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 3e5+5;const int maxk = 105;int n,K;int x[maxk],y[maxk];int a[maxk][5];int ans[maxn][5],cnt;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;bool pd(int b[])&#123; for(int k=0;k&lt;K;k++)&#123; int xx=0,yy=0; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; if(i==j&amp;&amp;a[k][i]==b[j]) xx++; if(i!=j&amp;&amp;a[k][i]==b[j]) yy++; &#125; &#125; if(x[k]!=xx||y[k]!=yy)return false; &#125; return true;&#125;int main()&#123; while(n=read())&#123; K=read(); for(int i=0;i&lt;K;i++)&#123; for(int j=0;j&lt;4;j++) a[i][j]=read(); x[i]=read(),y[i]=read(); &#125; cnt=0; int b[5]; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; for(int k=1;k&lt;=n;k++)&#123; for(int l=1;l&lt;=n;l++)&#123; if(i==j||i==k||i==l||j==k||j==l||k==l) continue; b[0]=i,b[1]=j,b[2]=k,b[3]=l; if(pd(b))&#123; ans[cnt][0]=i,ans[cnt][1]=j,ans[cnt][2]=k,ans[cnt][3]=l; cnt++; &#125; &#125; &#125; &#125; &#125; for(int i=0;i&lt;cnt;i++)&#123; printf("%d %d %d %d\n",ans[i][0],ans[i][1],ans[i][2],ans[i][3]); &#125; printf("%d\n",cnt); &#125;&#125; 1179 Shortest PathDijkstra求k+1次最短路然后求和，注意指定的城市只能走一次，所以跑Dij的时候需要稍稍标记即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3ftypedef __int64 ll;using namespace std;const int maxn = 1e3+5;const int maxm = 1e4+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n,m,k;int city[5];struct node&#123; int val,id; node(int id,int val):id(id),val(val) &#123;&#125; bool operator &lt;(const node &amp;hs)const&#123; return val&gt;hs.val; &#125;&#125;;struct edge&#123; int next,to,w;&#125;e[maxm*2];int head[maxn],cnt;void addedge(int u,int v,int w)&#123; e[++cnt]=edge&#123;head[u],v,w&#125;; head[u]=cnt;&#125;int dis[maxn],vis[maxn];void dijkstra(int from,int to)&#123; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++) dis[i]=INF; for(int i=0;i&lt;=k+1;i++) vis[city[i]]=true; vis[from]=vis[to]=false; priority_queue&lt;node&gt;q; q.push(node(from,0)); dis[from]=0; while(!q.empty())&#123; int cur=q.top().id; q.pop(); if(vis[cur])continue; vis[cur]=true; for(int i=head[cur]; i ; i=e[i].next)&#123; int v=e[i].to; if(dis[cur]+e[i].w &lt; dis[v])&#123; dis[v]=dis[cur]+e[i].w; q.push(node(v,dis[v])); &#125; &#125; &#125;&#125;int main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;k)&amp;&amp;(n||m||k))&#123; cnt=0; memset(head,0,sizeof(head)); for(int i=0;i&lt;m;i++)&#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; city[0]=1;city[k+1]=n; for(int i=1;i&lt;=k;i++)&#123; city[i]=read(); &#125; bool ok=true; int ans=0; for(int i=0;i&lt;=k;i++)&#123; dijkstra(city[i],city[i+1]); if(dis[city[i+1]]==INF)&#123; ok=false; break; &#125; ans+=dis[city[i+1]]; &#125; if(!ok) puts("Impossible"); else printf("%d\n",ans); &#125;&#125; 1186 Tourist 2经典的TSP问题，回溯法O(n!)求出最优值并记录路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3ftypedef __int64 ll;using namespace std;const int maxn = 15;int n,c[maxn][maxn];inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int ans,ways;int vis[maxn],path[maxn][maxn],tmp[maxn];void dfs(int k,int cur,int cost)&#123; if(cost&gt;ans) return; if(k==n)&#123; cost+=c[cur][0]; if(cost&lt;ans)&#123; ans=cost; for(int i=0;i&lt;n;i++) path[0][i]=tmp[i]; ways=1; &#125; else if(cost==ans&amp;&amp;ways&lt;10)&#123; for(int i=0;i&lt;n;i++) path[ways][i]=tmp[i]; ways++; &#125; return; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i])&#123; vis[i]=1; tmp[k]=i; dfs(k+1,i,cost+c[cur][i]); vis[i]=0; &#125; &#125;&#125;int main()&#123; int T=read(); while(T--)&#123; n=read(); for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=n;j++)&#123; c[i][j]=read(); &#125; &#125; ans=INF,ways=0; dfs(0,0,0); printf("%d\n",ans); for(int i=0;i&lt;ways;i++)&#123; for(int j=0;j&lt;n;j++)&#123; printf("%d%c",path[i][j],j==n-1?'\n':' '); &#125; &#125; &#125;&#125; 1195 Large Population要求边最少，互相连通且边权最大，就是求最大生成树，把边按边权降序排然后Kruskal跑一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3ftypedef __int64 ll;using namespace std;const int maxn = 1e3+5;const int maxm = 1e4+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n,m;int f[maxn];struct edge&#123; int u,v,w; bool operator &lt; (const edge &amp;hs)const&#123; return w&gt;hs.w; &#125;&#125;e[maxm];int Find(int x)&#123; return x==f[x]?x:f[x]=Find(f[x]);&#125;int main()&#123; int T=read(); while(T--)&#123; n=read(); m=read(); for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=0;i&lt;m;i++)&#123; e[i]=edge&#123;read(),read(),read()&#125;; &#125; sort(e,e+m); int cnt=0,ans=0; for(int i=0;i&lt;m;i++)&#123; int u=e[i].u,v=e[i].v,w=e[i].w; int fu=Find(u),fv=Find(v); if(fu!=fv)&#123; f[fu]=fv; cnt++; ans+=w; &#125; if(cnt==n-1) break; &#125; printf("%d\n",ans); &#125;&#125; 1245 Lisa’s Puzzle把二进制反过来看做求前缀，构造一个只有01结点的trie树，就是哈夫曼树，把每个数化为二进制01串插入到trie树，并记录每个结点经过的次数，每个数的答案就是该数最后一个结点的下面两个结点的经过次数和，下面没有结点说明该数不是其他数的前缀了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int tot=0;int a[maxn];unordered_map&lt;int,int&gt;cnt;int trie[maxn][2],vis[maxn],End[maxn];int len(int x)&#123; int res=0; while(x)&#123; res++; x&gt;&gt;=1; &#125; return res;&#125;void Insert(int k,int x)&#123; int now=0; for(int i=0;i&lt;cnt[x];i++)&#123; int next=((1&lt;&lt;i)&amp;x)?1:0; if(!trie[now][next]) trie[now][next]=++tot; now=trie[now][next]; vis[now]++; &#125; End[k]=now;&#125;int query(int k,int x)&#123; return vis[trie[End[k]][0]]+vis[trie[End[k]][1]];&#125;int main()&#123; int n=read(); for(int i=0;i&lt;n;i++)&#123; a[i]=read(); cnt[a[i]]=len(a[i]); Insert(i,a[i]); &#125; for(int i=0;i&lt;n;i++)&#123; printf("%d\n",query(i,a[i])); &#125;&#125; 1250 Bonus把输入看做有向图，从出度为0的开始拓扑排序，也就是和常规的反过来，求出每个人的等级即可算工资 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e4+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;vector&lt;int&gt;V[maxn];int n,m;int out[maxn],Rank[maxn];bool topu()&#123; queue&lt;int&gt;q; for(int i=1;i&lt;=n;i++)&#123; if(out[i]==0) q.push(i); &#125; int cnt=0; while(!q.empty())&#123; int x=q.front(); q.pop(); cnt++; for(int i=0;i&lt;V[x].size();i++)&#123; int next=V[x][i]; if(--out[next]==0) q.push(next); Rank[next]=Rank[x]+1; &#125; &#125; return cnt==n;&#125;int main()&#123; int T=read(); while(T--)&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++)&#123; V[i].clear(); Rank[i]=out[i]=0; &#125; for(int i=0;i&lt;m;i++)&#123; int u=read(),v=read(); V[v].push_back(u); out[u]++; &#125; if(topu())&#123; int sum=0; for(int i=1;i&lt;=n;i++)&#123; sum+=Rank[i]*1000+888; &#125; printf("%d\n",sum); for(int i=1;i&lt;=n;i++)&#123; printf("%d%c",Rank[i]*1000+888,i==n?'\n':' '); &#125; &#125; else&#123; printf("%d\n",n*888); for(int i=0;i&lt;n;i++)&#123; printf("888%c",i==n-1?'\n':' '); &#125; &#125; &#125;&#125; 1288 Binary Search Tree用new和free动态开结点再释放不是MLE就是TLE 因为最多100个数，可以把静态数组空间分配给新节点，但也不能用数组下标直接将左儿子下标为父节点的2倍，右儿子下标为父节点的2倍+1，100个数可以卡成$2^{100}$，明显数组不够大 其实只要空间为100的结构体数组给新节点使用就行了，每次建树初始化一个递增值记录下标用到第几个即可，其他就和数据结构课上实现的差不多，最后左右递归比较 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 105;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct node&#123; int v; node *l,*r;&#125;tree[2][maxn];int tot;node* Newnode(int k,int x)&#123; tree[k][tot].v=x; tree[k][tot].l=NULL; tree[k][tot].r=NULL; return &amp;tree[k][tot++];&#125;void Insert(int k,node *root,int x)&#123; if(x &lt; root-&gt;v)&#123; if(root-&gt;l==NULL) root-&gt;l=Newnode(k,x); else Insert(k,root-&gt;l,x); &#125; else&#123; if(root-&gt;r==NULL) root-&gt;r=Newnode(k,x); else Insert(k,root-&gt;r,x); &#125;&#125;bool same(node *root0,node *root1)&#123; if(root0==NULL&amp;&amp;root1==NULL) return true; if(root0!=NULL&amp;&amp;root1!=NULL)&#123; return same(root0-&gt;l,root1-&gt;l)&amp;&amp;same(root0-&gt;r,root1-&gt;r); &#125; return false;&#125;int main()&#123; int T=read(); while(T--)&#123; int n=read(),m=read(); tot=0; node *root0 = Newnode(0,read()); for(int i=1;i&lt;n;i++)&#123; Insert(0,root0,read()); &#125; for(int ca=1;ca&lt;=m;ca++)&#123; tot=0; node *root1 = Newnode(1,read()); for(int i=1;i&lt;n;i++)&#123; Insert(1,root1,read()); &#125; printf("%d: ",ca); if(same(root0,root1)) puts("Yes"); else puts("No"); &#125; puts(""); &#125;&#125; 1302 Balance Tree和上一题差不多，静态开结点建树，然后dfs求每个结点的左子树高度和右子树高度判断是否平衡 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1005;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct node&#123; int v; node *l,*r;&#125;tree[maxn];int tot;node* Newnode(int x)&#123; tree[tot].v=x; tree[tot].l=NULL; tree[tot].r=NULL; return &amp;tree[tot++];&#125;void Insert(node *root,int x)&#123; if(x &lt; root-&gt;v)&#123; if(root-&gt;l==NULL) root-&gt;l=Newnode(x); else Insert(root-&gt;l,x); &#125; else&#123; if(root-&gt;r==NULL) root-&gt;r=Newnode(x); else Insert(root-&gt;r,x); &#125;&#125;bool ok;int dfs(node *root)&#123; if(root==NULL) return 0; int lh=dfs(root-&gt;l); int rh=dfs(root-&gt;r); if(abs(lh-rh)&gt;1) ok=false; return max(lh,rh)+1;&#125;int main()&#123; int T=read(); while(T--)&#123; int n=read(); tot=0; node *root = Newnode(read()); for(int i=1;i&lt;n;i++)&#123; Insert(root,read()); &#125; ok=true; dfs(root); if(ok) puts("Yes"); else puts("No"); &#125;&#125; 模拟测试1 E-合并堆典型的区间dp，和矩阵连乘、石子合并等问题相似，可是考试的时候读错了题以为是贪心，气气+1 维护一个前缀和为了方便计算两两区间合并代价值，首先算出短区间最小代价，再自底向上算出长区间最小代价，转移方程看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 305;ll dp[maxn][maxn],h[maxn];ll inf = (1LL&lt;&lt;63)-1;ll sum[maxn];ll cost(int i,int j,int ii,int jj)&#123; ll H1=sum[j]-sum[i-1]; ll H2=sum[jj]-sum[ii-1]; ll a=min(H1,H2); ll b=max(H1,H2); return a*(log2(b)+1);&#125;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;h[i]); sum[i]=sum[i-1]+h[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; dp[i][j]=inf; &#125; dp[i][i]=0; &#125;//dp[i][j]表示区间[i,j]合并的最小代价，那么自己和自己合并dp[i][i]为0//把区间[i,j]分为两部分[i,k]和[k+1,j]，由最优子结构性质可知dp[i][j]=dp[i][k]+dp[k+1][j]//这样只要在每个长度区间下每次枚举k的位置就行了 for(int len=2;len&lt;=n;len++)&#123; for(int i=1;i+len-1&lt;=n;i++)&#123; int j=i+len-1; for(int k=i;k&lt;=j-1;k++)&#123; dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+cost(i,k,k+1,j)); &#125; &#125; &#125; printf("%lld\n",dp[1][n]); &#125;&#125; 模拟测试2 F-Split去年期末+补考原题 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3fusing namespace std;typedef long long ll;ll dp[55][55];ll a[55],sum[55];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); sum[i]=sum[i-1]+a[i]; &#125; //dp[i][j]表示前i个数分为j段的最大价值 //起始全部状态初始为负无穷大,dp[i][1]和dp[i][i]容易求得 dp[1][1]=a[1]; for(int i=2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; dp[i][j]=-inf; &#125; dp[i][1]=abs(a[i]-a[1])*i; dp[i][i]=sum[i]; &#125; //对于每个a[i]就两种情况,要么单独作为一段,要么和前面的最后一段合并 for(int i=2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; //i个数最多分为i段 //将a[i]单独作一段 dp[i][j]=max(dp[i][j],dp[i-1][j-1]+a[i]); //将a[i]与前面第j段合并 for(int k=j;k&lt;=i-1;k++)&#123; //枚举前i-1个数第j段的所有可能起始位置,这样就是[1,k-1]分为j-1段,[k-1,i]作为第j段 dp[i][j]=max(dp[i][j],dp[k-1][j-1]+abs(a[i]-a[k])*(i-k+1)); &#125; &#125; &#125; &#125;&#125; 期末考试 E给一个无向带权图，其中图中有k个点是救助站，问图中所有点到最近救助站路程的总和 其实是很简单的一道最短路模板题，稍微改改就行了，考试想复杂了，气气+2 首先我们把k个点看作一个超级源点，那么图中其他点到源点的最短路就也是这个源点到其他所有点的最短路 把这个超级源点和这k个救助站分别加上一条边权为0的边，从这个源点开始跑dij就相当于把这k个点同时丢到优先队列中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3ftypedef __int64 ll;using namespace std;const int maxn = 1e3+5;const int maxm = 1e4+5;int n,m,k;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct node&#123; int val,id; node(int id,int val):id(id),val(val) &#123;&#125; bool operator &lt;(const node &amp;hs)const&#123; return val&gt;hs.val; &#125;&#125;;struct edge&#123; int next,to,w;&#125;e[maxm*2];int head[maxn],cnt;void addedge(int u,int v,int w)&#123; e[++cnt]=edge&#123;head[u],v,w&#125;; head[u]=cnt;&#125;int dis[maxn],vis[maxn];void dijkstra(int from)&#123; for(int i=1;i&lt;=n+1;i++)&#123; dis[i]=INF; vis[i]=0; &#125; priority_queue&lt;node&gt;q; q.push(node(from,0)); dis[from]=0; while(!q.empty())&#123; int cur=q.top().id; q.pop(); if(vis[cur])continue; vis[cur]=true; for(int i=head[cur]; i ; i=e[i].next)&#123; int v=e[i].to; if(dis[cur]+e[i].w &lt; dis[v])&#123; dis[v]=dis[cur]+e[i].w; q.push(node(v,dis[v])); &#125; &#125; &#125;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; n=read(),m=read(),k=read(); cnt=0; for(int i=1;i&lt;=n+1;i++)&#123; head[i]=0; &#125; for(int i=0;i&lt;m;i++)&#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; int X=n+1; for(int i=0;i&lt;k;i++)&#123; int x=read(); addedge(X,x,0); addedge(x,X,0); &#125; dijkstra(X); ll sum=0; bool ok=true; for(int i=1;i&lt;=n;i++)&#123; if(dis[i]==INF)&#123; ok=false; break; &#125; sum+=dis[i]; &#125; if(ok) printf("%I64d\n",sum); else puts("-1"); &#125;&#125; 2019程序设计实践总结就到这，总的来说不是特别满意(还被ericxie点名批评了)，图论和动态规划不是特别掌握，毕竟我主数据结构的呀qwq 一门课程的结束不代表以后永远不会再接触，我觉得程设就是对之前所学的C语言、离散数学、数据结构、Java等课程结合的实践性特别强的一门课程，在职场也一样，面试要求的算法都是平时积累起来的，包括编程语言的掌握程度，所以如果你对算法和编程感兴趣，欢迎通过自己的努力加入湘潭大学ACM集训队。]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>STL</tag>
        <tag>暴力</tag>
        <tag>模拟</tag>
        <tag>程序设计实践</tag>
        <tag>动态规划</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[湖南大学第15届校赛 H-Longest Common Palindrome Substring]]></title>
    <url>%2F%E6%B9%96%E5%8D%97%E5%A4%A7%E5%AD%A6%E7%AC%AC15%E5%B1%8A%E6%A0%A1%E8%B5%9B-H-Longest-Common-Palindrome-Substring.html</url>
    <content type="text"><![CDATA[原题链接 题意：给两个1e5长的字符串，求两者最长公共回文子串长度 思路： manacher 分别求出s,t串的mp[]数组，同时也可以求出对应最长奇回文子串长度(a,c)和最长偶回文子串长度(c,d) 由于manacher求出的是以i为中心的最长回文半径，且长度为len的子串为回文子串,len-2的的子串也为回文子串 那么s,t的最长公共回文子串长度可能是[0,1,3,5,…min(a,c)]和[0,2,4,6,…,min(b,d)]这两个区间内的一个长度 hash预处理字符串，然后分别二分这两个区间，check的时候就要用到mp[]数组来判断二分的长度子串是否为回文子串，注意分奇偶讨论 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn = 1e5+5;char ma[maxn*2];int mp[2][maxn*2];void manacher(char s[],int len,int k)&#123; int l=0; ma[l++]='$'; ma[l++]='#'; for(int i=1;i&lt;=len;i++)&#123; ma[l++]=s[i]; ma[l++]='#'; &#125; ma[l]=0; int mx=0,id=0; for(int i=0;i&lt;l;i++)&#123; mp[k][i]=mx&gt;i?min(mp[k][2*id-i],mx-i):1; while(ma[i+mp[k][i]]==ma[i-mp[k][i]]) mp[k][i]++; if(i+mp[k][i]&gt;mx)&#123; mx=i+mp[k][i]; id=i; &#125; &#125;&#125;char s[maxn],t[maxn];int lens,lent;ull base=233;ull p[maxn],hs[maxn],ht[maxn];ull geths(int l,int r)&#123; return (ull)hs[r]-p[r-l+1]*hs[l-1];&#125;ull getht(int l,int r)&#123; return (ull)ht[r]-p[r-l+1]*ht[l-1];&#125;vector&lt;ull&gt;tmp;bool check(int k)&#123; tmp.clear(); ull ss,tt; for(int i=0;i&lt;2*lens+2;i++)&#123; if(mp[0][i]-1&gt;=k)&#123; if((mp[0][i]-1)&amp;1)&#123; ss=geths(i/2-k/2,i/2+k/2); &#125; else&#123; ss=geths(i/2-k/2+1,i/2+k/2); &#125; tmp.push_back(ss); &#125; &#125; sort(tmp.begin(),tmp.end()); for(int i=0;i&lt;2*lent+2;i++)&#123; if(mp[1][i]-1&gt;=k)&#123; if((mp[1][i]-1)&amp;1)&#123; tt=getht(i/2-k/2,i/2+k/2); &#125; else&#123; tt=getht(i/2-k/2+1,i/2+k/2); &#125; if(binary_search(tmp.begin(),tmp.end(),tt)) return true; &#125; &#125; return false;&#125;int main() &#123; //freopen("in.txt","r",stdin); p[0]=1; for(int i=1;i&lt;maxn;i++)&#123; p[i]=p[i-1]*base; &#125; vector&lt;int&gt;len; while(~scanf("%s%s",s+1,t+1))&#123; lens=strlen(s+1); lent=strlen(t+1); for(int i=1;i&lt;=lens;i++)&#123; hs[i]=hs[i-1]*base+s[i]-'a'; &#125; for(int i=1;i&lt;=lent;i++)&#123; ht[i]=ht[i-1]*base+t[i]-'a'; &#125; int a=0,b=0,c=0,d=0; manacher(s,lens,0); for(int i=0;i&lt;2*lens+2;i++)&#123; int k=mp[0][i]-1; if(k&amp;1) a=max(a,k); else b=max(b,k); &#125; manacher(t,lent,1); for(int i=0;i&lt;2*lent+2;i++)&#123; int k=mp[1][i]-1; if(k&amp;1) c=max(c,k); else d=max(d,k); &#125; int Maxodd=min(a,c),Maxeven=min(b,d); len.clear(); len.push_back(0); for(int i=1;i&lt;=Maxodd;i+=2)&#123; len.push_back(i); &#125; int l=0,r=len.size()-1,ans=0; while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(check(len[mid])) l=mid; else r=mid-1; &#125; ans=max(ans,len[l]); len.clear(); for(int i=0;i&lt;=Maxeven;i+=2)&#123; len.push_back(i); &#125; l=0,r=len.size()-1; while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(check(len[mid])) l=mid; else r=mid-1; &#125; ans=max(ans,len[l]); printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>manacher</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template of ACM]]></title>
    <url>%2FTemplate-of-ACM.html</url>
    <content type="text"><![CDATA[快读1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//C++关闭同步流 切记不要和C风格混用ios::sync_with_stdio(false);cin.tie(0);//正负整数inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;namespace FastIO &#123; const int SIZE = 1 &lt;&lt; 16; char buf[SIZE], obuf[SIZE], str[60]; int bi = SIZE, bn = SIZE, opt; int read(char *s) &#123; while (bn) &#123; for (; bi &lt; bn &amp;&amp; buf[bi] &lt;= ' '; bi++); if (bi &lt; bn) break; bn = fread(buf, 1, SIZE, stdin); bi = 0; &#125; int sn = 0; while (bn) &#123; for (; bi &lt; bn &amp;&amp; buf[bi] &gt; ' '; bi++) s[sn++] = buf[bi]; if (bi &lt; bn) break; bn = fread(buf, 1, SIZE, stdin); bi = 0; &#125; s[sn] = 0; return sn; &#125; bool read(int&amp; x) &#123; int n = read(str), bf; if (!n) return 0; int i = 0; if (str[i] == '-') bf = -1, i++; else bf = 1; for (x = 0; i &lt; n; i++) x = x * 10 + str[i] - '0'; if (bf &lt; 0) x = -x; return 1; &#125;&#125;;using namespace FastIO;//O2优化#pragma GCC optimize(2)//javaInputReader in = new InputReader();PrintWriter out = new PrintWriter(System.out); out.close();class InputReader &#123; BufferedReader buf; StringTokenizer tok; InputReader() &#123; buf = new BufferedReader(new InputStreamReader(System.in)); &#125; boolean hasNext() &#123; while (tok == null || !tok.hasMoreElements()) &#123; try &#123; tok = new StringTokenizer(buf.readLine()); &#125; catch (Exception e) &#123; return false; &#125; &#125; return true; &#125; String next() &#123; if (hasNext()) return tok.nextToken(); return null; &#125; int nextInt() &#123; return Integer.parseInt(next()); &#125; long nextLong() &#123; return Long.parseLong(next()); &#125; double nextDouble() &#123; return Double.parseDouble(next()); &#125; BigInteger nextBigInteger() &#123; return new BigInteger(next()); &#125; BigDecimal nextBigDecimal() &#123; return new BigDecimal(next()); &#125;&#125; STL1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;ext/pb_ds/assoc_container.hpp&gt;#include&lt;ext/pb_ds/tree_policy.hpp&gt;//用tree#include&lt;ext/pb_ds/hash_policy.hpp&gt;//用hash#include&lt;ext/pb_ds/trie_policy.hpp&gt;//用trie#include&lt;ext/pb_ds/priority_queue.hpp&gt;//用priority_queueusing namespace __gnu_pbds;//hash表 用法类似map,时间复杂度O(n)cc_hash_table&lt;int,bool&gt; h; //拉链法gp_hash_table&lt;int,bool&gt; h; //探测法// 平衡树 以下操作时间复杂度均为O(logn)struct team&#123; int t,p,id; bool operator &lt;(const team&amp;hs)const&#123; return t!=hs.t?t&gt;hs.t:p!=hs.p?p&lt;hs.p:id&lt;hs.id; &#125;&#125;typedef tree&lt;team,null_type,less&lt;team&gt;,rb_tree_tag,tree_order_statistics_node_update&gt; rebtree;null_type //无映射(低版本g++为null_mapped_type)less&lt;T&gt; //从小到大排序rb_tree_tag //红黑树tree_order_statistics_node_update //更新方式tr.insert(x); //插入;tr.erase(x); //删除;tr.order_of_key(x); //求比x小的个数 rank=res+1tr.find_by_order(k-1); //找k小值,返回迭代器 k值非法，则会返回end()tr.join(b); //将b并入tr,前提是两棵树类型一样且没有重复元素tr.split(v,b); //分裂,key小于等于v的元素属于tr,其余的属于btr.lower_bound(x); //返回第一个&gt;=x的元素的迭代器 x的前驱 *--tr.lower_bound(x)tr.upper_bound(x); //返回第一个&gt;x的元素的迭代器 x的后继 *tr.lower_bound(x)//迭代器支持++,--操作//堆priority_queue&lt;int,greater&lt;int&gt;,TAG&gt; Q; //注意命名空间别和std中的那个重了/*其中的TAG为类型，有以下几种：pairing_heap_tag //最快thin_heap_tagbinomial_heap_tagrc_binomial_heap_tagbinary_heap_tag*/__gnu_pbds::priority_queue&lt;int&gt;::point_iterator it; //支持迭代器Q.push(x); //push()会返回迭代器,用一个迭代器数组保存所有进队列的元素的迭代器，就可以持久化操作Q.pop();Q.top();Q.join(b);Q.empty();Q.size();Q.modify(it,6);Q.erase(it);//rope 时间复杂度O(logN)#include &lt;ext/rope&gt;using namespace __gnu_cxx;rope&lt;int&gt; r;push_back(x) 在末尾添加xinsert(pos,x) 在pos插入xerase(pos,x) 从pos开始删除x个copy(pos,len,x) 从pos开始到pos+len为止用x代替replace(pos,x) 从pos开始换成xsubstr(pos,x) 提取pos开始x个at(x)/[x] 访问第x个元素//可持久化 O(1)复制根节点rope&lt;char&gt; *his[maxn];his[0] = new rope&lt;char&gt;();his[i] = new rope&lt;char&gt;(*his[i-1]);//list 合并操作void merge(list &lt;T&gt; &amp; x) //将链表x合并进来并清空x,要求链表自身和x都是有序的void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x ); //在position后把list&amp;x所有的元素到剪接到要操作的list对象void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x, iterator it ); //只会把it的值剪接到要操作的list对象中void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x, iterator first, iterator last ); //把first到last剪接到要操作的list对象中//O(n)查询第k大nth_element(a+1,a+k,a+1+n); ST表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//f[i][j]表示区间[i,i+2^j-1]的最值//一维void ST()&#123; for(int i=1;i&lt;=n;i++) f[i][0]=a[i]; int t=log(n)/log(2); for(int j=1;j&lt;=t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125;int querymax(int l,int r)&#123; int k=log(r-l+1)/log(2); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125;//二维void init() &#123; lo[0]=-1; for(int i=1;i&lt;maxn;++i) lo[i]=(i&amp;(i-1))?lo[i-1]:lo[i-1]+1; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; Min[i][j][0][0] = a[i][j]; Max[i][j][0][0] = a[i][j]; &#125; for (int i = 0; i &lt;= lo[n]; i++) &#123; for (int j = 0; j &lt;= lo[m]; j++) &#123; if (i == 0 &amp;&amp; j == 0) continue; for (int row = 1; row + (1 &lt;&lt; i) - 1 &lt;= n; row++) for (int col = 1; col + (1 &lt;&lt; j) - 1 &lt;= m; col++) &#123; if (i) &#123; Min[row][col][i][j] = min(Min[row][col][i-1][j],Min[row+(1&lt;&lt;(i-1))][col][i-1][j]); Max[row][col][i][j] = max(Max[row][col][i-1][j],Max[row+(1&lt;&lt;(i-1))][col][i-1][j]); &#125; else &#123; Min[row][col][i][j] = min(Min[row][col][i][j-1], Min[row][col+(1&lt;&lt;(j-1))][i][j-1]); Max[row][col][i][j] = max(Max[row][col][i][j-1], Max[row][col+(1&lt;&lt;(j-1))][i][j-1]); &#125; &#125; &#125; &#125;&#125;int askmin(int x1, int y1, int x2, int y2) &#123; int kx = lo[x2-x1+1], ky = lo[y2-y1+1]; int m1 = Min[x1][y1][kx][ky]; int m2 = Min[x2-(1&lt;&lt;kx)+1][y1][kx][ky]; int m3 = Min[x1][y2-(1&lt;&lt;ky)+1][kx][ky]; int m4 = Min[x2-(1&lt;&lt;kx)+1][y2-(1&lt;&lt;ky)+1][kx][ky]; return min(min(m1,m2),min(m3,m4));&#125;int askmax(int x1, int y1, int x2, int y2) &#123; int kx = lo[x2-x1+1], ky = lo[y2-y1+1]; int m1 = Max[x1][y1][kx][ky]; int m2 = Max[x2-(1&lt;&lt;kx)+1][y1][kx][ky]; int m3 = Max[x1][y2-(1&lt;&lt;ky)+1][kx][ky]; int m4 = Max[x2-(1&lt;&lt;kx)+1][y2-(1&lt;&lt;ky)+1][kx][ky]; return max(max(m1,m2),max(m3,m4));&#125; KMP123456789101112131415161718192021222324//next[i] 表示t[i-next[i]...i-1]=t[0...next[i]-1]//循环节len=m%(m-next[m])==0?m-next[m]:1void getNext(char t[],int m)&#123; int i,j; j=Next[0]=-1; i=0; while(i&lt;m)&#123; while(j!=-1&amp;&amp;t[i]!=t[j]) j=Next[j]; Next[++i]=++j; //if(t[++i]==t[++j]) Next[i]=Next[j]; //优化 //else Next[i]=j; &#125;&#125;int kmp(char s[],int n,char t[],int m)&#123; getNext(t,m); int i=0,j=0; while(i&lt;n)&#123; while(j!=-1&amp;&amp;s[i]!=t[j]) j=Next[j]; i++,j++; if(j&gt;=m)&#123; //匹配成功 ; &#125; &#125;&#125; ExtendKMP12345678910111213141516171819202122232425262728293031323334353637383940//next[i]表示t[i...m-1]与t[0...m-1]的最长公共前缀//extend[i]表示s[i...n-1]与t[0...m-1]的最长公共前缀int Next[maxn],extend[maxn];void getNext(char t[],int m)&#123; Next[0]=m; int j=0; while(j+1&lt;m&amp;&amp;t[j]==t[j+1]) j++; Next[1]=j; int k=1; for(int i=2;i&lt;m;i++)&#123; int p=Next[k]+k-1; int L=Next[i-k]; if(i+L&lt;p+1) Next[i]=L; else &#123; j=max(0,p-i+1); while(i+j&lt;m&amp;&amp;t[i+j]==t[j]) j++; Next[i]=j; k=i; &#125; &#125;&#125;void extendkmp(char t[],int m,char s[],int n)&#123; getNext(t,m); int j=0; while(j&lt;n&amp;&amp;j&lt;m&amp;&amp;t[j]==s[j]) j++; extend[0]=j; int k=0; for(int i=1;i&lt;n;i++)&#123; int p=extend[k]+k-1; int L=Next[i-k]; if(i+L&lt;p+1) extend[i]=L; else &#123; j=max(0,p-i+1); while(i+j&lt;n&amp;&amp;j&lt;m&amp;&amp;s[i+j]==t[j]) j++; extend[i]=j; k=i; &#125; &#125;&#125; 最小表示法12345678910111213141516//取得最小表示法下标的开始位置int getmin(char *s,int n) &#123; int n=strlen(s); int i=0,j=1,k=0,t; while(i&lt;n &amp;&amp; j&lt;n &amp;&amp; k&lt;n) &#123; t=s[(i+k)%n]-s[(j+k)%n]; if (!t) k++; else &#123; if (t&gt;0) i+=k+1; else j+=k+1; if (i==j) j++; k=0; &#125; &#125; return i&lt;j?i:j;&#125; 手写Hash1234567891011121314151617181920212223struct Hash &#123; static const int MOD = 1999997; static const int N = 1e6; int head[MOD + 10], nx[N], top; int hs[N], id[N]; void init() &#123; memset(head, -1, sizeof head); top = 0; &#125; void insert(int x, int y) &#123; int k = x % MOD; hs[top] = x; id[top] = y; nx[top] = head[k]; head[k] = top++; &#125; int find(int x) &#123; int k = x % MOD; for (int i = head[k]; i != -1; i = nx[i]) &#123; if (hs[i] == x) &#123; return id[i]; &#125; &#125; return -1; &#125;&#125;hs; 字符串Hash123456789101112131415161718192021//这里为ull自然溢出取模,手动取模模数可取998244353,1004535809,1e9+7,1e9+9...typedef unsigned long long ull;char s[maxn],t[maxn];int lens,lent;ull base=233; //冲突可换其它素数ull p[maxn],hs[maxn];ull geths(int l,int r)&#123; return (ull)hs[r]-p[r-l+1]*hs[l-1];&#125;p[0]=1;for(int i=1;i&lt;maxn;i++)&#123; p[i]=p[i-1]*base;&#125;scanf("%s%s",s+1,t+1);lens=strlen(s+1);lent=strlen(t+1);for(int i=1;i&lt;=lens;i++)&#123; hs[i]=hs[i-1]*base+s[i];&#125; Manacher1234567891011121314151617181920212223//mp[i]表示以i为中心的最长回文的半径，mp[i]-1为原串中最长回文串的长度//mp[0...2*n+1]/2 求和即为所有子串中回文子串个数char ma[maxn*2];int mp[maxn*2];void manacher(char s[],int len)&#123; int l=0; ma[l++]='$'; ma[l++]='#'; for(int i=0;i&lt;len;i++)&#123; ma[l++]=s[i]; ma[l++]='#'; &#125; ma[l]=0; int mx=0,id=0; for(int i=0;i&lt;l;i++)&#123; mp[i]=mx&gt;i?min(mp[2*id-i],mx-i):1; while(ma[i+mp[i]]==ma[i-mp[i]]) mp[i]++; if(i+mp[i]&gt;mx)&#123; mx=i+mp[i]; id=i; &#125; &#125;&#125; Trie1234567891011121314151617181920212223struct trie &#123; int nex[maxn][26],cnt; bool exist[maxn]; // 该结点结尾的字符串是否存在 void Insert(char s[], int len) &#123; int p = 0; for (int i = 0; i &lt; len; i++) &#123; int c = s[i] - 'a'; if (!nex[p][c]) nex[p][c] = ++cnt; p = nex[p][c]; &#125; exist[p] = 1; &#125; bool Find(char s[], int len) &#123; int p = 0; for (int i = 0; i &lt; len; i++) &#123; int c = s[i] - 'a'; if (!nex[p][c]) return 0; p = nex[p][c]; &#125; return exist[p]; &#125;&#125;; AC自动机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124//查询多个模式串在文本串中出现了多少次#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e6+6;namespace AC&#123; int tr[N][26],tot; int e[N],fail[N]; void init()&#123; memset(tr,0,sizeof(tr)); memset(e,0,sizeof(e)); memset(fail,0,sizeof(fail)); tot=0; &#125; void Insert(char *s)&#123; int u=0; for(int i=1;s[i];i++)&#123; if(!tr[u][s[i]-'a'])tr[u][s[i]-'a']=++tot; u=tr[u][s[i]-'a']; &#125; e[u]++; &#125; queue&lt;int&gt; q; void build()&#123; for(int i=0;i&lt;26;i++)if(tr[0][i])q.push(tr[0][i]); while(q.size())&#123; int u=q.front();q.pop(); for(int i=0;i&lt;26;i++)&#123; if(tr[u][i])fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]); else tr[u][i]=tr[fail[u]][i]; &#125; &#125; &#125; int query(char *t)&#123; int u=0,res=0; for(int i=1;t[i];i++)&#123; u=tr[u][t[i]-'a'];// 转移 for(int j=u;j&amp;&amp;e[j]!=-1;j=fail[j])&#123; res+=e[j],e[j]=-1; &#125; &#125; return res; &#125;&#125;char s[N];int main()&#123; int T;scanf("%d",&amp;T); while(T--)&#123; int n;scanf("%d",&amp;n); AC::init(); for(int i=1;i&lt;=n;i++)scanf("%s",s+1),AC::Insert(s); scanf("%s",s+1); AC::build(); printf("%d\n",AC::query(s)); &#125; return 0;&#125;/*有N个由小写字母组成的模式串以及一个文本串T每个模式串可能会在文本串中出现多次。你需要找出哪些模式串在文本串T中出现的次数最多*/#include&lt;bits/stdc++.h&gt;using namespace std;const int N=155,L=1e6+5;namespace AC&#123; const int SZ=N*80; int tot,tr[SZ][26]; int fail[SZ],idx[SZ],val[SZ]; int cnt[N];// 记录第 i 个字符串的出现次数 void init()&#123; memset(fail,0,sizeof(fail)); memset(tr,0,sizeof(tr)); memset(val,0,sizeof(val)); memset(cnt,0,sizeof(cnt)); memset(idx,0,sizeof(idx)); tot=0; &#125; void Insert(char *s,int id)&#123;//id 表示原始字符串的编号 int u=0; for(int i=1;s[i];i++)&#123; if(!tr[u][s[i]-'a'])tr[u][s[i]-'a']=++tot; u=tr[u][s[i]-'a']; &#125; idx[u]=id; &#125; queue&lt;int&gt; q; void build()&#123; for(int i=0;i&lt;26;i++)if(tr[0][i])q.push(tr[0][i]); while(q.size())&#123; int u=q.front();q.pop(); for(int i=0;i&lt;26;i++)&#123; if(tr[u][i])fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]); else tr[u][i]=tr[fail[u]][i]; &#125; &#125; &#125; int query(char *t)&#123;// 返回最大的出现次数 int u=0,res=0; for(int i=1;t[i];i++)&#123; u=tr[u][t[i]-'a']; for(int j=u;j;j=fail[j])val[j]++; &#125; for(int i=0;i&lt;=tot;i++)if(idx[i])res=max(res,val[i]),cnt[idx[i]]=val[i]; return res; &#125;&#125;int n;char s[N][100],t[L];int main()&#123; while(~scanf("%d",&amp;n))&#123;if(n==0)break; AC::init(); for(int i=1;i&lt;=n;i++)scanf("%s",s[i]+1),AC::Insert(s[i],i); AC::build(); scanf("%s",t+1); int x=AC::query(t); printf("%d\n",x); for(int i=1;i&lt;=n;i++)if(AC::cnt[i]==x)printf("%s\n",s[i]+1); &#125; return 0;&#125; 后缀数组SA123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687struct SuffixArray&#123; int s[N&lt;&lt;1],t[N&lt;&lt;1],ht[N],sa[N],rk[N],p[N],c[N],w[N]; inline int trans(int n,const char* S)&#123; int m=*max_element(S+1,S+1+n); memset(rk,0,(n+1)&lt;&lt;2); for(int i=1;i&lt;=n;++i) rk[S[i]]=1; for(int i=1;i&lt;=m;++i) rk[i]+=rk[i-1]; for(int i=1;i&lt;=n;++i) s[i]=rk[S[i]]; return rk[m]; &#125; #define ps(x) sa[w[s[x]]--]=x #define pl(x) sa[w[s[x]]++]=x inline void radix(int* v,int* s,int* t,int n,int m,int n1)&#123; memset(sa,0,(n+1)&lt;&lt;2); memset(c,0,(m+1)&lt;&lt;2); for(int i=1;i&lt;=n;++i) ++c[s[i]]; for(int i=1;i&lt;=m;++i) w[i]=c[i]+=c[i-1]; for(int i=n1;i;--i) ps(v[i]); for(int i=1;i&lt;=m;++i) w[i]=c[i-1]+1; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;1 &amp;&amp; t[sa[i]-1]) pl(sa[i]-1); for(int i=1;i&lt;=m;++i) w[i]=c[i]; for(int i=n;i;--i) if(sa[i]&gt;1 &amp;&amp; !t[sa[i]-1]) ps(sa[i]-1); &#125; inline void SAIS(int n,int m,int* s,int* t,int* p)&#123; int n1=0,ch=rk[1]=0,*s1=s+n; t[n]=0; for(int i=n-1;i;--i) t[i]=s[i]==s[i+1]?t[i+1]:s[i]&gt;s[i+1]; for(int i=2;i&lt;=n;++i) rk[i]=t[i-1]&amp;&amp;!t[i]?(p[++n1]=i,n1):0; radix(p,s,t,n,m,n1); for(int i=1,x,y;i&lt;=n;++i) if(x=rk[sa[i]])&#123; if(ch&lt;=1 || p[x+1]-p[x]!=p[y+1]-p[y]) ++ch; else for(int j=p[x],k=p[y];j&lt;=p[x+1];++j,++k) if((s[j]&lt;&lt;1|t[j])^(s[k]&lt;&lt;1|t[k]))&#123; ++ch; break; &#125; s1[y=x]=ch; &#125; if(ch&lt;n1) SAIS(n1,ch,s1,t+n,p+n1); else for(int i=1;i&lt;=n1;++i) sa[s1[i]]=i; for(int i=1;i&lt;=n1;++i) s1[i]=p[sa[i]]; radix(s1,s,t,n,m,n1); &#125; inline void init(int n,const char* S)&#123; int m=trans(++n,S); SAIS(n,m,s,t,p); for(int i=1;i&lt;n;++i) rk[sa[i]=sa[i+1]]=i; for(int i=1,j,k=0;i&lt;n;++i) if(rk[i]&gt;1)&#123; for(j=sa[rk[i]-1];S[i+k]==S[j+k];++k); if(ht[rk[i]]=k) --k; &#125; &#125; int get_lcs(int n,int mid)&#123; //mid为两串分隔位置，n为拼接后总长 int ans=0; for(int i=2;i&lt;=n;i++)&#123; if(ht[i]&gt;ans)&#123; if(sa[i]&gt;=1&amp;&amp;sa[i]&lt;=mid&amp;&amp;sa[i-1]&gt;=mid+1) ans=max(ans,ht[i]); if(sa[i-1]&gt;=1&amp;&amp;sa[i-1]&lt;=mid&amp;&amp;sa[i]&gt;=mid+1) ans=max(ans,ht[i]); &#125; &#125; return ans; &#125; ll get_subcnt(int n)&#123; //不同子串个数 ll ans=0; for(int i=1;i&lt;=n;i++)&#123; ans += n-sa[i]+1-ht[i]; &#125; return ans; &#125; int get_looplen(int n)&#123; //循环节长度 for(int i=1;i&lt;=n;i++)&#123; if(n%i) continue; //不能整除的话，一定不能构成循环节 if(rk[1] != rk[i+1]+1) continue; //rank数组必须要相邻才能构成循环节 if(ht[rk[1]] != n-i) continue; //若第一个和第二个的最长公共前缀不符合条件 return n/i; &#125; return 1; &#125;&#125;SA;char S[N],T[N];int main()&#123; while(scanf("%s",S+1)&amp;&amp;strcmp(S+1,".")!=0)&#123; int n=strlen(S+1); SA.init(n,S); printf("%d\n",SA.get_looplen(n)); &#125;// for(int i=1;i&lt;=n;i++)&#123;// printf("%d %d %d %s\n",SA.sa[i],SA.rk[i],SA.ht[i],S+i);// &#125;&#125; 后缀自动机SAM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108const int maxn = 1e6 + 5;const int N = 26;struct SAM&#123; int tot, last, ch[maxn &lt;&lt; 1][N], fa[maxn &lt;&lt; 1], len[maxn &lt;&lt; 1]; int sum[maxn &lt;&lt; 1], tp[maxn &lt;&lt; 1], cnt[maxn &lt;&lt; 1]; //sum,tp用于拓扑排序，tp为排序后的数组 int right[maxn &lt;&lt; 1]; int Tr(char c)&#123;return c - 'a';&#125; int val(int c)&#123;return len[c] - len[fa[c]];&#125; void init() &#123; last = tot = 1; len[1] = 0; memset( ch[1], 0, sizeof ch[1]); &#125; void add(int x) &#123; int p = last, np = last = ++tot; len[np] = len[p] + 1, cnt[last] = 1; memset( ch[np], 0, sizeof ch[np]); while( p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = fa[p]; if( p == 0) fa[np] = 1; else &#123; int q = ch[p][x]; if( len[q] == len[p] + 1) fa[np] = q; else &#123; int nq = ++tot; memcpy( ch[nq], ch[q], sizeof ch[q]); len[nq] = len[p] + 1, fa[nq] = fa[q], fa[q] = fa[np] = nq; while( p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = fa[p]; &#125; &#125; &#125; void build(char s[]) &#123; int lens = strlen(s + 1); for(int i = 1; i &lt;= lens; i++) add(Tr(s[i])); memset(sum, 0, sizeof(int) * (tot + 1)); memset(right, 0, sizeof(int) * (tot + 1)); for(int i = 1; i &lt;= tot; i++) sum[len[i]]++; for(int i = 1; i &lt;= lens; i++) sum[i] += sum[i - 1]; for(int i = 1; i &lt;= tot; i++) tp[sum[len[i]]--] = i; for(int i = tot; i; i--) cnt[fa[tp[i]]] += cnt[tp[i]]; for(int i = 1, p = 1; i &lt;= lens; i++) p = ch[p][Tr(s[i])], right[p]++; for(int i = tot; i; i--) right[fa[tp[i]]] += right[tp[i]]; &#125; ll calc()//洛谷P3804 &#123; ll ans = 0; for(int i = tot; i; i--) &#123; if(cnt[tp[i]] &gt; 1) ans = max(ans, 1LL * cnt[tp[i]] * len[tp[i]]); &#125; return ans; &#125; ll getsubnum() //不同本质子串数 &#123; ll ans = 0; for(int i = tot; i; i--) &#123; ans += val(i); &#125; return ans; &#125; ll get_ab(int a, int b) //出现次数介于[a,b]的子串数 &#123; ll ans = 0; for(int i = 1; i &lt;= tot; i++) &#123; if(a &lt;= right[tp[i]] &amp;&amp; right[tp[i]] &lt;= b) ans += val(tp[i]); &#125; return ans; &#125; int getlcs(char t[]) //最长公共子串长度 &#123; int p = 1, num = 0, ans = 0; for (int i = 1; t[i]; i++) &#123; int c = Tr(t[i]); if (ch[p][c]) p = ch[p][c], num++; else &#123; for(; p &amp;&amp; !ch[p][c]; p = fa[p]); if (!p) p = 1, num = 0; else num = len[p] + 1, p = ch[p][c]; &#125; ans = max(ans, num); &#125; return ans; &#125;&#125; sam;char s[maxn], t[maxn];int main()&#123; while(~scanf("%s",s+1)) &#123; sam.init(); sam.build(s); &#125;&#125; 回文自动机PAM12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*1.求串S前缀0~i内本质不同回文串的个数（两个串长度不同或者长度相同且至少有一个字符不同便是本质不同）2.求串S内每一个本质不同回文串出现的次数3.求串S内回文串的个数（其实就是1和2结合起来） p-24.求以下标i结尾的回文串的个数*/#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 300005 ;const int N = 26 ;struct PAM &#123; int next[maxn][N] ;//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成 int fail[maxn] ;//fail指针，失配后跳转到fail指针指向的节点 int cnt[maxn] ; //在最后统计后它可以表示形如以i为结尾的回文串中最长的那个串个数 int num[maxn] ; //表示以i结尾的回文串的种类数 int len[maxn] ;//len[i]表示节点i表示的回文串的长度 int S[maxn] ;//存放添加的字符 int last ;//指向上一个字符所在的节点，方便下一次add int n ;//字符数组指针 int p ;//节点指针 int newnode ( int l ) &#123; for ( int i = 0 ; i &lt; N ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123;//初始化 p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1 ; &#125; int get_fail ( int x ) &#123;//和KMP一样，失配后找一个尽量最长的 while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; void add ( int c ) &#123; c -= 'a' ; S[++ n] = c ; int cur = get_fail ( last ) ;//通过上一个回文串找这个回文串的匹配位置 if ( !next[cur][c] ) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode ( len[cur] + 2 ) ;//新建节点 fail[now] = next[get_fail ( fail[cur] )][c] ;//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; &#125; last = next[cur][c] ; cnt[last] ++ ; &#125; void Count () &#123; for ( int i = p - 1 ; i &gt;= 0 ; -- i ) cnt[fail[i]] += cnt[i] ; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！ &#125;&#125; pam;char s[maxn];int main()&#123; scanf("%s",s); pam.init(); int lens=strlen(s); for(int i=0;i&lt;lens;i++)&#123; pam.add(s[i]); &#125; pam.Count();&#125; 二维树状数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//单点修改+区间查询/*求(x1,y1)~(x2,y2)的sumsum=sum(x2,y2)-sum(x1-1,y2)-sum(x2,y1-1)+sum(x1-1,y1-1)*/void add(int x,int y,int v) &#123; while(x&lt;=n) &#123; int ty=y; while(ty&lt;=n) c[x][ty]+=v,ty+=lowbit(ty); x+=lowbit(x); &#125;&#125;int sum(int x,int y) &#123; int res=0; while(x) &#123; int ty=y; while(ty) res+=c[x][ty],ty-=lowbit(ty); x-=lowbit(x); &#125; return res;&#125;//区间修改+单点查询void add(int x,int y,int v) &#123; while(x&lt;=n) &#123; int ty=y; while(ty&lt;=n) c[x][ty]+=v,ty+=lowbit(ty); x+=lowbit(x); &#125;&#125;void real_add(int x1,int y1,int x2,int y2,int v) &#123; add(x1,y1,v); add(x1,y2+1,-v); add(x2+1,y1,-v); add(x2+1,y2+1,v);&#125;int sum(int x, int y) &#123; int res=0; while(x) &#123; int ty=y; while(ty) res+=c[x][ty],ty-=lowbit(ty); x-=lowbit(x); &#125; return res;&#125;//区间修改+区间查询void add(int x,int y,int v) &#123; for(int i=x; i&lt;=n; i+=lowbit(i)) for(int j=y; j&lt;=m; j+=lowbit(j)) &#123; t1[i][j]+=v; t2[i][j]+=v*x; t3[i][j]+=v*y; t4[i][j]+=v*x*y; &#125;&#125;void real_add(int x1,int y1,int x2,int y2,int v) &#123; add(x1,y1,v); add(x1,y2+1,-v); add(x2+1,y1,-v); add(x2+1,y2+1,v);&#125;int sum(int x, int y) &#123; int res=0; for(int i=x; i; i-=lowbit(i)) for(int j=y; j; j-=lowbit(j)) res+=(x+1)*(y+1)*t1[i][j]-(y+1)*t2[i][j]-(x+1)*t3[i][j]+t4[i][j]; return res;&#125;int real_sum(int x1,int y1,int x2,int y2) &#123; return sum(x2,y2)-sum(x2,y1-1)-sum(x1-1,y2)+sum(x1-1,y1-1);&#125; 树链剖分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202//点权版#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1const int maxn = 1e5+10;const int maxm = 1e5+10;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct edge&#123; int next,to;&#125;e[maxm*2];int head[maxn],cnt;void addedge(int u,int v)&#123; e[++cnt]=edge&#123;head[u],v&#125;; head[u]=cnt;&#125;int n,m,root,P;int w[maxn];int fa[maxn],deep[maxn],siz[maxn],son[maxn],rk[maxn],top[maxn],id[maxn];void dfs1(int u,int pre,int dep)&#123; fa[u]=pre;deep[u]=dep;siz[u]=1; for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v==pre)continue; dfs1(v,u,dep+1); siz[u]+=siz[v]; if(siz[v]&gt;siz[son[u]])son[u]=v; &#125;&#125;void dfs2(int u,int t)&#123; top[u]=t;id[u]=++cnt;rk[cnt]=u; if(!son[u])return; dfs2(son[u],t); for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v!=son[u]&amp;&amp;v!=fa[u])dfs2(v,v); &#125;&#125;/*************************************/int sum[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2];void push_up(int o)&#123; sum[o]=sum[o&lt;&lt;1]+sum[o&lt;&lt;1|1];&#125;void push_down(int ls,int rs,int o)&#123; if(lazy[o])&#123; sum[o&lt;&lt;1]=(sum[o&lt;&lt;1]+lazy[o]*ls)%P; sum[o&lt;&lt;1|1]=(sum[o&lt;&lt;1|1]+lazy[o]*rs)%P; lazy[o&lt;&lt;1]=(lazy[o&lt;&lt;1]+lazy[o])%P; lazy[o&lt;&lt;1|1]=(lazy[o&lt;&lt;1|1]+lazy[o])%P; lazy[o]=0; &#125;&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; sum[o]=w[rk[l]]; //重新编号后的 return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;void update(int L,int R,int v,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; sum[o]=(sum[o]+v*(r-l+1))%P; lazy[o]=(lazy[o]+v)%P; return; &#125; int mid=(l+r)&gt;&gt;1; push_down(mid-l+1,r-mid,o); if(L&lt;=mid) update(L,R,v,lson); if(R&gt;mid) update(L,R,v,rson); push_up(o);&#125;int querysum(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return sum[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=0; push_down(mid-l+1,r-mid,o); if(L&lt;=mid) ret=(ret+querysum(L,R,lson))%P; if(R&gt;mid) ret=(ret+querysum(L,R,rson))%P; return ret;&#125;void PathUpdate(int x,int y,int v)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); update(id[top[x]],id[x],v,1,n,1); x=fa[top[x]]; &#125; if(id[x]&gt;id[y]) swap(x,y); update(id[x],id[y],v,1,n,1);&#125;int PathQuery(int x,int y)&#123; int ret=0; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); ret=(ret+querysum(id[top[x]],id[x],1,n,1))%P; x=fa[top[x]]; &#125; if(id[x]&gt;id[y])swap(x,y); ret=(ret+querysum(id[x],id[y],1,n,1))%P; return ret;&#125;int main()&#123; n=read(),m=read(),root=read(),P=read(); for(int i=1;i&lt;=n;i++)&#123; w[i]=read(); &#125; cnt=0; for(int i=1;i&lt;=n;i++) head[i]=0; for(int i=0;i&lt;n-1;i++)&#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; cnt=0; dfs1(root,0,1); //注意根节点不一定是1 dfs2(root,root); build(1,n,1); while(m--)&#123; int op=read(),x,y,z; if(op==1)&#123; //更新x-y最短路径上所有点 x=read(),y=read(),z=read(); PathUpdate(x,y,z); &#125; else if(op==2)&#123; //查询x-y最短路径上所有点 x=read(),y=read(); printf("%d\n",PathQuery(x,y)); &#125; else if(op==3)&#123; //更新以x为根节点的子树 x=read(),z=read(); update(id[x],id[x]+siz[x]-1,z,1,n,1); &#125; else&#123; //查询以x为根节点的子树 x=read(); printf("%d\n",querysum(id[x],id[x]+siz[x]-1,1,n,1)); &#125; &#125;&#125;//边权版int fa[maxn],deep[maxn],siz[maxn],son[maxn],rk[maxn],top[maxn],id[maxn];int dis[maxn],w[maxn];void dfs1(int u,int pre,int dep)&#123; fa[u]=pre;deep[u]=dep;siz[u]=1; for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v==pre)continue; dis[v]=dis[u]+e[i].v; dfs1(v,u,dep+1); siz[u]+=siz[v]; if(siz[v]&gt;siz[son[u]])son[u]=v; &#125;&#125;void dfs2(int u,int t)&#123; top[u]=t;id[u]=++cnt;rk[cnt]=u; if(!son[u])return; dfs2(son[u],t); for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v!=son[u]&amp;&amp;v!=fa[u])dfs2(v,v); &#125;&#125;int PathQuery(int x,int y)&#123; int ans=0; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); ans=max(ans,query(id[top[x]],id[x],1,n,1)); x=fa[top[x]]; &#125; if(x==y)return ans; if(deep[x]&gt;deep[y]) swap(x,y); ans=max(ans,query(id[son[x]],id[y],1,n,1)); return ans;&#125;void PathUpdate(int x,int y,int v)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); update(id[top[x]],id[x],v,1,n,1); x=fa[top[x]]; &#125; if(x==y)return; if(deep[x]&gt;deep[y]) swap(x,y); update(id[son[x]],id[y],v,1,n,1);&#125;for(int i=0;i&lt;n-1;i++)&#123; if(deep[E[i].u]&lt;deep[E[i].v]) swap(E[i].u,E[i].v); w[E[i].u]=E[i].w; //边权放在下面结点上变为点权&#125; LCA123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//倍增法int deep[maxn],f[maxn],dis[maxn],p[maxn][30];void dfs(int x,int pre,int d)&#123; deep[x]=d; f[x]=pre; for(int i=head[x];i;i=e[i].next)&#123; int to=e[i].to; if(to!=pre)&#123; dis[to]=dis[x]+e[i].w; dfs(to,x,d+1); &#125; &#125;&#125;void init()&#123; //p[i][j]表示i结点的第2^j祖先 for(int j=0;(1&lt;&lt;j)&lt;=n;j++) for(int i=1;i&lt;=n;i++) p[i][j]=-1; for(int i=1;i&lt;=n;i++)p[i][0]=f[i]; for(int j=1;(1&lt;&lt;j)&lt;=n;j++) for(int i=1;i&lt;=n;i++) if(p[i][j-1]!=-1) p[i][j]=p[p[i][j-1]][j-1];//i的第2^j祖先就是i的第2^(j-1)祖先的第2^(j-1)祖先&#125;int LCA(int a,int b)&#123; int i,j; if(deep[a]&lt;deep[b])swap(a,b); for(i=0;(1&lt;&lt;i)&lt;=deep[a];i++); i--; //使a,b两点的深度相同 for(j=i;j&gt;=0;j--) if(deep[a]-(1&lt;&lt;j)&gt;=deep[b]) a=p[a][j]; if(a==b)return a; //倍增法，每次向上进深度2^j，找到最近公共祖先的子结点 for(j=i;j&gt;=0;j--)&#123; if(p[a][j]!=-1&amp;&amp;p[a][j]!=p[b][j])&#123; a=p[a][j]; b=p[b][j]; &#125; &#125; return f[a];&#125;//树链剖分int query_lca(int x,int y)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]])swap(x,y); x=fa[top[x]]; &#125;return deep[x]&lt;deep[y]?x:y;&#125; 线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233//线段树区间合并//根据题意修改条件void pushup(int l,int r,int o)&#123; tree[o].ls=tree[lc].ls; //左端点最长连续 tree[o].rs=tree[rc].rs; //右端点最长连续 tree[o].ms=max( tree[lc].rs+tree[rc].ls,max( tree[lc].ms,tree[rc].ms) ); //区间最长连续 int mid=(l+r)&gt;&gt;1; if(tree[lc].ls==mid-l+1) tree[o].ls+=tree[rc].ls; if(tree[rc].rs==r-mid) tree[o].rs+=tree[lc].rs;&#125; //对于query()也要考虑mid两侧的情况,一般分三种情况 全左,全右,左右相交,左右端点完全一致才return//区间最长连续LCISvoid push_up(int l,int r,int o)&#123; int mid = (l+r)&gt;&gt;1; lmax[o]=lmax[lc]; rmax[o]=rmax[rc]; mmax[o]=max(mmax[lc],mmax[rc]); if(a[mid]&lt;a[mid+1])&#123; if(lmax[o]==mid-l+1) lmax[o]+=lmax[rc]; if(rmax[o]==r-mid) rmax[o]+=rmax[lc]; mmax[o]=max(mmax[o],rmax[lc]+lmax[rc]); &#125;&#125;int query(int L,int R,int l,int r,int o)&#123; if(L==l&amp;&amp;r==R)&#123; return mmax[o]; &#125; int mid = (l+r)&gt;&gt;1; if(R&lt;=mid) return query(L,R,lson); if(L&gt;mid) return query(L,R,rson); int x = query(L,mid,lson); int y = query(mid+1,R,rson); if(a[mid]&lt;a[mid+1])&#123; int z = min(mid-L+1,rmax[lc]) + min(R-mid,lmax[rc]); return max(max(x,y),z); &#125; else &#123; return max(x,y); &#125;&#125;//区间最大子段和ll sum[maxn&lt;&lt;2],lsum[maxn&lt;&lt;2],rsum[maxn&lt;&lt;2],msum[maxn&lt;&lt;2];void push_up(int o)&#123; sum[o] = sum[ls] + sum[rs]; msum[o] = max(max(msum[ls],msum[rs]),rsum[ls]+lsum[rs]); lsum[o] = max(lsum[ls],sum[ls]+lsum[rs]); rsum[o] = max(rsum[rs],sum[rs]+rsum[ls]);&#125;void build(int l,int r,int o)&#123; sum[o]=lsum[o]=rsum[o]=msum[o]=0; if(l==r) return; int mid = (l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;void update(int p,int v,int l,int r,int o)&#123; if(l==r)&#123; sum[o]+=v; lsum[o]=rsum[o]=msum[o]=sum[o]; return; &#125; int mid = (l+r)&gt;&gt;1; if(p&lt;=mid) update(p,v,lson); else update(p,v,rson); push_up(o);&#125;//query() 区间查询与push_up同理，如果包含两个区间需要比较//区间离散化,每个结点维护[ v[l],v[l+1] )for(int i=1;i&lt;=n;i++)&#123; r[i]++; v.push_back(l[i]);v.push_back(r[i]);&#125;sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());m=v.size();for(int i=1;i&lt;=n;i++)&#123; l[i] = lower_bound(v.begin(),v.end(),l[i])-v.begin()+1; r[i] = lower_bound(v.begin(),v.end(),r[i])-v.begin()+1; r[i]--;&#125;build(1,m-1,1);update(l[i],r[i],1,m-1,1);//矩形面积并/交#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1#define N 205using namespace std;int cnt[N&lt;&lt;2]; //记录cnt[i]表示区间是否被覆盖 为-1时表示其左右区间状态不一致,需要下推double len[N&lt;&lt;2]; //储存区间被覆盖长度 注意数据类型,每个结点维护的是 [ X[l],X[r+1] ]的区间数double X[N&lt;&lt;1];struct edge&#123; double l,r,h; int f; edge()&#123;&#125; edge(double l,double r,double h,int f):l(l),r(r),h(h),f(f)&#123;&#125; bool operator &lt; (const edge &amp;b) const &#123; return h&lt;b.h; &#125;&#125;e[N&lt;&lt;1];//void push_up(int o)//&#123;// //左右节点区间有状态不一致或者两者状态不一致则该节点区间cnt也为-1// if(cnt[o&lt;&lt;1]==-1 || cnt[o&lt;&lt;1|1]==-1) cnt[o]=-1;// else if(cnt[o&lt;&lt;1]!=cnt[o&lt;&lt;1|1]) cnt[o]=-1;// else cnt[o]=cnt[o&lt;&lt;1];//// len[o]=len[o&lt;&lt;1]+len[o&lt;&lt;1|1];//&#125;void push_up(int l, int r, int o) &#123; if(cnt[o]) len[o] = X[r + 1] - X[l]; else if(l == r) len[o] = 0; else len[o] = len[o&lt;&lt;1] + len[o&lt;&lt;1|1];&#125;//void push_down(int l,int r,int o)//&#123;// if(cnt[o]!=-1) //当状态一致时才下推// &#123;// int mid=l+r&gt;&gt;1;// cnt[o&lt;&lt;1]=cnt[o&lt;&lt;1|1]=cnt[o];// len[o&lt;&lt;1]=(cnt[o] ? X[mid+1]-X[l] :0);// len[o&lt;&lt;1|1]=(cnt[o] ? X[r+1]-X[mid+1] :0);// &#125;//&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; cnt[o]=0; len[o]=0.0; return; &#125; int mid=l+r&gt;&gt;1; build(lson); build(rson); push_up(l,r,o);&#125;void update(int L,int R,int v,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;// if(cnt[o]!=-1)// &#123;// cnt[o]+=v;// len[o]=(cnt[o] ? X[r+1]-X[l]:0); //改动覆盖次数条件求面积交// return;// &#125; cnt[o] += v; push_up(l,r,o); return; &#125; //push_down(l,r,o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) update(L,R,v,lson); if(R&gt;mid) update(L,R,v,rson); push_up(l,r,o);&#125;int main()&#123; int n,ca=1; while(scanf("%d",&amp;n),n)&#123; double x1,y1,x2,y2; for(int i=1;i&lt;=n;i++)&#123; scanf("%lf%lf%lf%lf",&amp;x1,&amp;y1,&amp;x2,&amp;y2); X[i]=x1,X[i+n]=x2; e[i]=edge(x1,x2,y1,1); e[i+n]=edge(x1,x2,y2,-1); &#125; sort(e+1,e+1+2*n); sort(X+1,X+1+2*n); int m=unique(X+1,X+1+2*n)-X-1; //build(1,m-1,1); //m个不同的点分成m-1个区间 memset(len,0,sizeof(len)); memset(cnt,0,sizeof(cnt)); double ans=0.0; for(int i=1;i&lt;2*n;i++)&#123; int l=lower_bound(X+1,X+1+m,e[i].l)-X; int r=lower_bound(X+1,X+1+m,e[i].r)-X-1; //printf("%d %d\n",l,r); update(l,r,e[i].f,1,m-1,1); //printf("%f %f %f\n",len[1],e[i+1].h-e[i].h,ans); ans+=len[1]*(e[i+1].h-e[i].h); &#125; printf("Test case #%d\n",ca++); printf("Total explored area: %.2f\n",ans); puts(""); &#125;&#125;//单点修改字符,区间查询是否为回文串//多项式hash,维护正反串的hash值//h[l,r] = s[l]*p[l]+s[l+1]*p[l+1]+...+s[r]*p[r],区间查询后要移位修正同等幂void build(int l,int r,int o)&#123; if(l==r)&#123; sum[0][o]=(ull)s[l]*p[l]; sum[1][o]=(ull)s[n-l+1]*p[l]; return; &#125; int mid = (l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;while(m--)&#123; scanf("%s",op); if(op[0]=='c')&#123; scanf("%d%s",&amp;x,ch); update(0,x,ch[0],1,n,1); update(1,n-x+1,ch[0],1,n,1); &#125; else&#123; scanf("%d%d",&amp;l,&amp;r); if(l&gt;r) swap(l,r); ull ss = query(0,l,r,1,n,1); ull tt = query(1,n-r+1,n-l+1,1,n,1); int llen = l-1,rlen=n-r; if(llen&gt;rlen) tt*=p[llen-rlen]; else ss*=p[rlen-llen]; if(ss==tt) puts("Yes"); else puts("No"); &#125;&#125; 主席树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295//静态区间第k小const int maxn=1e5+10;const int maxm=maxn*40;int T[maxn],L[maxm],R[maxm],sum[maxm];int sz[maxn],h[maxn]; //sz为原序列,h为离散化之后的序列int n,q,ql,qr,k,tot;void build(int&amp; rt,int l,int r)&#123; rt=++tot; sum[rt]=0; if(l == r) return ; int mid=(l+r)&gt;&gt;1; build(L[rt],l,mid); build(R[rt],mid+1,r);&#125;void update(int&amp; rt,int l,int r,int pre,int x)&#123; rt=++tot; L[rt]=L[pre]; R[rt]=R[pre]; sum[rt]=sum[pre]+1; if(l == r) return ; int mid=(l+r)&gt;&gt;1; if(x &lt;= mid) update(L[rt],l,mid,L[pre],x); else update(R[rt],mid+1,r,R[pre],x);&#125;int query(int s,int e,int l,int r,int k)&#123; if(l == r) return l; int mid=(l+r)&gt;&gt;1; int res=sum[L[e]]-sum[L[s]]; if(k &lt;= res) return query(L[s],L[e],l,mid,k); else return query(R[s],R[e],mid+1,r,k-res);&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;q); tot=0; for(int i=1; i&lt;=n; i++)&#123; scanf("%d",&amp;sz[i]); h[i]=sz[i]; &#125; sort(h+1,h+1+n); int num=unique(h+1,h+1+n)-(h+1); build(T[0],1,num); for(int i=1; i&lt;=n; i++) update(T[i],1,num,T[i-1],lower_bound(h+1,h+1+num,sz[i])-(h)); while(q--)&#123; scanf("%d %d %d",&amp;ql,&amp;qr,&amp;k); printf("%d\n",h[query(T[ql-1],T[qr],1,num,k)]); &#125;&#125;//动态区间第k小const int maxn = 6e4+5;const int maxm = 1e4+5;int T[maxn],S[maxn],L[maxn*32],R[maxn*32],sum[maxn*32];int sz[maxn],h[maxn];int ul[maxn],ur[maxn];int tot,num,n,q;struct node&#123; int l,r,k; bool flag; //ture代表Q，false代表C&#125;Q[maxm]; //存储询问void build(int&amp; rt,int l,int r)&#123; rt = ++tot; sum[rt]=0; if(l==r) return; int mid = (l+r)&gt;&gt;1; build(L[rt],l,mid); build(R[rt],mid+1,r);&#125;void update(int&amp; rt,int pre,int l,int r,int x,int val)&#123; rt = ++tot; L[rt] = L[pre]; R[rt] = R[pre]; sum[rt] = sum[pre]+val; if(l==r) return; int mid = (l+r)&gt;&gt;1; if(x&lt;=mid) update(L[rt],L[pre],l,mid,x,val); else update(R[rt],R[pre],mid+1,r,x,val);&#125;int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int val)&#123; int res = lower_bound(h+1,h+1+num,sz[x])-h; while(x&lt;=n)&#123; update(S[x],S[x],1,num,res,val); x += lowbit(x); &#125;&#125;int Sum(int x,bool flag)&#123; int res=0; while(x&gt;0)&#123; if(flag) res += sum[L[ur[x]]]; else res += sum[L[ul[x]]]; x -= lowbit(x); &#125; return res;&#125;int query(int s,int e,int ts,int te,int l,int r,int k)&#123; if(l==r) return l; int mid = (l+r)&gt;&gt;1; int res = Sum(e,true)-Sum(s,false)+sum[L[te]]-sum[L[ts]]; if(k&lt;=res)&#123; for(int i=e;i;i-=lowbit(i)) ur[i] = L[ur[i]]; for(int i=s;i;i-=lowbit(i)) ul[i] = L[ul[i]]; return query(s,e,L[ts],L[te],l,mid,k); &#125; else&#123; for(int i=e;i;i-=lowbit(i)) ur[i] = R[ur[i]]; for(int i=s;i;i-=lowbit(i)) ul[i] = R[ul[i]]; return query(s,e,R[ts],R[te],mid+1,r,k-res); &#125;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; char str[5]; num=0; scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) scanf("%d",sz+i),h[++num]=sz[i]; for(int i=1;i&lt;=q;i++)&#123; scanf("%s",str); if(str[0]=='Q')&#123; scanf("%d%d%d",&amp;Q[i].l,&amp;Q[i].r,&amp;Q[i].k); Q[i].flag=true; &#125; else&#123; scanf("%d%d",&amp;Q[i].l,&amp;Q[i].r); Q[i].flag=false; h[++num]=Q[i].r; &#125; &#125; sort(h+1,h+1+num); int tmp = unique(h+1,h+1+num)-h-1; num = tmp; tot=0; build(T[0],1,num); for(int i=1;i&lt;=n;i++) update(T[i],T[i-1],1,num,lower_bound(h+1,h+1+num,sz[i])-h,1); for(int i=1;i&lt;=n;i++) S[i] = T[0]; for(int i=1;i&lt;=q;i++)&#123; if(Q[i].flag)&#123; for(int j=Q[i].r;j;j-=lowbit(j)) ur[j] = S[j]; for(int j=Q[i].l-1;j;j-=lowbit(j)) ul[j] = S[j]; printf("%d\n",h[query(Q[i].l-1,Q[i].r,T[Q[i].l-1],T[Q[i].r],1,num,Q[i].k)]); &#125; else&#123; add(Q[i].l,-1); sz[Q[i].l] = Q[i].r; add(Q[i].l,1); &#125; &#125; &#125; return 0;&#125;//可持久化单点修改单点查询#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;struct node &#123; int l, r, val; &#125;;node tr[maxn * 20];int cnt, root[maxn];int n, m;int a[maxn];int clone(int p)&#123; tr[++cnt] = tr[p]; return cnt;&#125;int build(int p, int l, int r)&#123; p = ++cnt; if(l == r) &#123; tr[p].val = a[l]; return p; &#125; int mid = (l + r) &gt;&gt; 1; tr[p].l = build(tr[p].l, l, mid); tr[p].r = build(tr[p].r, mid + 1, r); return p; &#125;int update(int p, int l, int r, int pos, int val)&#123; p = clone(p); if(l == r) tr[p].val = val; else &#123; int mid = (l + r) &gt;&gt; 1; if(pos &lt;= mid) tr[p].l = update(tr[p].l, l, mid, pos, val); else tr[p].r = update(tr[p].r, mid + 1, r, pos, val); &#125; return p;&#125;int query(int p, int l, int r, int pos)&#123; if(l == r) return tr[p].val; int mid = (l + r) &gt;&gt; 1; if(pos &lt;= mid) return query(tr[p].l, l, mid, pos); else return query(tr[p].r, mid + 1, r, pos);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1; i &lt;= n; ++i) scanf("%d",&amp;a[i]); root[0] = build(0, 1, n); for(int i = 1; i &lt;= m; ++i) &#123; int v,op,x,y;scanf("%d%d%d",&amp;v,&amp;op,&amp;x); if(op == 1) &#123; scanf("%d",&amp;y); root[i] = update(root[v], 1, n, x, y); &#125; else &#123; printf("%d\n", query(root[v], 1, n, x)); root[i] = root[v]; &#125; &#125;&#125;//可持久化区间修改区间查询#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define dlson l,mid,lson[nrt]#define drson mid+1,r,rson[nrt]const int maxn = 1e5+5;int n,m;int T[maxn],tot,lson[maxn*20],rson[maxn*20];ll c[maxn*20],cur[maxn*20];void push_up(int rt)&#123; c[rt]=c[lson[rt]]+c[rson[rt]];&#125;void build(int l,int r,int &amp;nrt)&#123; nrt=tot++;cur[nrt]=0; if(l==r)&#123; scanf("%lld",c+nrt);return; &#125;int mid=l+r&gt;&gt;1; build(dlson);build(drson);push_up(nrt);&#125;void update(int L,int R,ll val,int l,int r,int &amp;nrt,int rt)&#123; nrt=tot++; lson[nrt]=lson[rt]; rson[nrt]=rson[rt]; c[nrt]=c[rt]+(R-L+1)*val; cur[nrt]=cur[rt]; if(L==l&amp;&amp;R==r)&#123; cur[nrt]+=val;return; &#125; int mid=l+r&gt;&gt;1; if(R&lt;=mid)update(L,R,val,dlson,lson[rt]); else if(L&gt;mid)update(L,R,val,drson,rson[rt]); else update(L,mid,val,dlson,lson[rt]),update(mid+1,R,val,drson,rson[rt]);&#125;ll query(int L,int R,int l,int r,int nrt,ll add)&#123; if(L==l&amp;&amp;R==r)return c[nrt]+(R-L+1)*add; int mid=l+r&gt;&gt;1; if(R&lt;=mid)return query(L,R,dlson,add+cur[nrt]); else if(L&gt;mid)return query(L,R,drson,add+cur[nrt]); return query(L,mid,dlson,add+cur[nrt])+query(mid+1,R,drson,add+cur[nrt]);&#125;int main()&#123; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; tot=0; build(1,n,T[0]); int time=0; char op[2]; int l,r,d,t; for(int i=1;i&lt;=m;i++)&#123; scanf("%s",op); if(op[0]=='C')&#123; scanf("%d%d%d",&amp;l,&amp;r,&amp;d); update(l,r,d,1,n,T[time+1],T[time]);time++; &#125; else if(op[0]=='Q')&#123; scanf("%d%d",&amp;l,&amp;r); printf("%lld\n",query(l,r,1,n,T[time],0)); &#125; else if(op[0]=='H')&#123; scanf("%d%d%d",&amp;l,&amp;r,&amp;t); printf("%lld\n",query(l,r,1,n,T[t],0)); &#125; else&#123; scanf("%d",&amp;t); tot=T[t+1]; time=t; &#125; &#125; &#125;&#125; Splay123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379/*您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：1.插入 x 数2.删除 x 数(若有多个相同的数，因只删除一个)3.查询 x 数的排名(排名定义为比当前数小的数的个数 +1+1 。若有多个相同的数，因输出最小的排名)4.查询排名为 x 的数5.求 x 的前驱(前驱定义为小于 x ，且最大的数)6.求 x 的后继(后继定义为大于 x ，且最小的数)*/#include&lt;bits/stdc++.h&gt;#define mes(a,b) memset(a,b,sizeof(a))using namespace std;const int N = 1e5+5;int son[N][2],f[N],cou[N],siz[N],key[N];int root,sz;void clear(int x) &#123; son[x][0]=son[x][1]=cou[x]=f[x]=siz[x]=key[x]=0;&#125;bool get(int x) &#123; return son[f[x]][1]==x;&#125;void update(int x) &#123; if(x) &#123; siz[x]=cou[x]; if(son[x][0])siz[x]+=siz[son[x][0]]; if(son[x][1])siz[x]+=siz[son[x][1]]; &#125;&#125;void rotate(int x) &#123; int old=f[x],oldf=f[old],whichson=get(x); son[old][whichson]=son[x][whichson^1],f[son[old][whichson]]=old; son[x][whichson^1]=old,f[old]=x; f[x]=oldf; if(oldf) &#123; son[oldf][son[oldf][1]==old]=x; &#125; update(old); update(x);&#125;void splay(int x) &#123; for(int fa; (fa=f[x]); rotate(x)) &#123; if(f[fa]) &#123; rotate((get(x)==get(fa))?fa:x); &#125; &#125; root=x;&#125;void insert(int x) &#123; if(root==0) &#123; sz++; son[sz][0]=son[sz][1]=f[sz]=0; key[sz]=x; cou[sz]=siz[sz]=1; root=sz; return; &#125; int now=root,fa=0; while(1) &#123; if(x==key[now]) &#123; cou[now]++; update(now); update(fa); splay(now); break; &#125; fa=now; now=son[now][key[now]&lt;x]; if(now==0) &#123; sz++; f[sz]=fa; son[sz][0]=son[sz][1]=0; cou[sz]=siz[sz]=1; son[fa][key[fa]&lt;x]=sz; key[sz]=x; update(fa); splay(sz); break; &#125; &#125;&#125;int find(int x) &#123; int now=root,ans=0; while(1) &#123; if(x&lt;key[now]) &#123; now=son[now][0]; &#125; else &#123; ans+=(son[now][0]?siz[son[now][0]]:0); if(x==key[now]) &#123; splay(now); return ans+1; &#125; ans+=cou[now]; now=son[now][1]; &#125; &#125;&#125;int findx(int x) &#123; int now=root; while(1) &#123; if(son[now][0] &amp;&amp; x&lt;=siz[son[now][0]]) &#123; now=son[now][0]; &#125; else &#123; int temp=(son[now][0]?siz[son[now][0]]:0)+cou[now]; if(x&lt;=temp)return key[now]; x-=temp; now=son[now][1]; &#125; &#125;&#125;int pre() &#123; int now=son[root][0]; while(son[now][1])now=son[now][1]; return now;&#125;int next() &#123; int now=son[root][1]; while(son[now][0])now=son[now][0]; return now;&#125;void del(int x) &#123; int whatever=find(x); if(cou[root]&gt;1) &#123; cou[root]--; update(root); return; &#125; if(!son[root][0] &amp;&amp; !son[root][1]) &#123; clear(root); root=0; return; &#125; if(!son[root][0]) &#123; int oldroot=root; root=son[root][1]; f[root]=0; clear(oldroot); return; &#125; if(!son[root][1]) &#123; int oldroot=root; root=son[root][0]; f[root]=0; clear(oldroot); return; &#125; int leftbig=pre(),oldroot=root; splay(leftbig); son[root][1]=son[oldroot][1]; f[son[root][1]]=root; clear(oldroot); update(root); return;&#125;int main() &#123; int n; scanf("%d",&amp;n); int op,x; for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;op,&amp;x); switch(op)&#123; case 1:insert(x);break; case 2:del(x);break; case 3:printf("%d\n",find(x));break; case 4:printf("%d\n",findx(x));break; case 5:insert(x);printf("%d\n",key[pre()]);del(x);break; case 6:insert(x);printf("%d\n",key[next()]);del(x);break; &#125; &#125;&#125;/*给出一个数字序列，有6种操作： （1） ADD x y d： 第x个数到第y个数加d 。 （2） REVERSE x y ： 将区间[x,y]中的数翻转 。 （3） REVOLVE x y t ：将区间[x,y]旋转t次，如1 2 3 4 5 旋转2次后就变成4 5 1 2 3 。 （4） INSERT x p ：在第x个数后面插入p 。 （5） DELETE x ：删除第x个数 。 （6） MIN x y ： 查询区间[x,y]中的最小值 。*/#pragma GCC optimize(2)#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;const int maxn = 2e5+5;struct SplayTree &#123; int n, root; ll Val[maxn],Sum[maxn]; int Add[maxn], Min[maxn], Rev[maxn]; int fa[maxn], c[maxn][2], size[maxn]; void init() &#123; n = root = 0; memset(c, 0, sizeof(c)); memset(fa, 0, sizeof(fa)); &#125; void Push_up(int u) &#123; Min[u] = Val[u]; size[u] = size[c[u][0]] + size[c[u][1]] + 1; Sum[u] = Sum[c[u][0]] + Sum[c[u][1]] + Val[u]; if(c[u][0]) Min[u] = min(Min[u], Min[c[u][0]]); if(c[u][1]) Min[u] = min(Min[u], Min[c[u][1]]); &#125; void Push(int u) &#123; if(fa[u]) Push(fa[u]); Push_down(u); &#125; void Push_down(int u) &#123; if(Add[u]) &#123; ll w = Add[u]; if(c[u][0]) Add[c[u][0]]+=w,Val[c[u][0]]+=w,Min[c[u][0]]+=w,Sum[c[u][0]]+=w*size[c[u][0]]; if(c[u][1]) Add[c[u][1]]+=w,Val[c[u][1]]+=w,Min[c[u][1]]+=w,Sum[c[u][1]]+=w*size[c[u][1]]; &#125; if(Rev[u]) &#123; if(c[u][0]) Rev[c[u][0]] ^= 1; if(c[u][1]) Rev[c[u][1]] ^= 1; swap(c[u][0], c[u][1]); &#125; Add[u]=Rev[u]=0; &#125; int Newnode(int key) &#123; size[++n] = 1; Add[n] = Rev[n] = 0; Val[n] = Min[n] = Sum[n] = key; return n; &#125; void rotate(int u) &#123; int v = fa[u], w = fa[v], t = c[v][1] == u; fa[c[u][t^1]] = v, c[v][t] = c[u][t^1]; c[u][t^1] = v, fa[u] = w, fa[v] = u; if(root==v) root = u; else c[w][c[w][1]==v] = u; Push_up(v); &#125; void Splay(int u, int p) &#123; Push(u); while(fa[u] != p) &#123; int v = fa[u], w = fa[v]; if(fa[v] == p) rotate(u); else if((c[v][0] == u) == (c[w][0] == v)) rotate(v), rotate(u); else rotate(u), rotate(u); &#125; Push_up(u); &#125; void insert(int key) &#123; Newnode(key); c[root][1] = n; fa[n] = root; Splay(n, 0); &#125; int find(int u, int k) &#123; Push_down(u); int t = size[c[u][0]] + 1; if(t == k) return u; else &#123; if(t &gt; k) return find(c[u][0], k); else return find(c[u][1], k-t); &#125; &#125; void update(int u, int v, int w) &#123; int x = find(root, u), y = find(root, v+2); Splay(x, 0), Splay(y, root); Add[c[y][0]] += w; Val[c[y][0]] += w; Min[c[y][0]] += w; Sum[c[y][0]] += w*size[c[y][0]]; &#125; void Reverse(int u, int v) &#123; int x = find(root, u), y = find(root, v+2); Splay(x, 0), Splay(y, root); Rev[c[y][0]] ^= 1; &#125; void Revolve(int u, int v, int w) &#123; int m = v - u + 1; w %= m; w = (w + m) % m; int x = find(root, u), y = find(root, u+1); int _x = find(root, v-w+1), _y = find(root, v+2); Splay(_x, 0), Splay(_y, root); int p = c[_y][0]; c[_y][0] = 0; Splay(x, 0), Splay(y, root); c[y][0] = p; fa[p] = y; &#125; void Join(int u, int v) &#123; int x = find(root, u+1), y = find(root, u+2); Splay(x, 0), Splay(y, root); c[y][0] = Newnode(v); fa[n] = y; &#125; void del(int u) &#123; int x = find(root, u), y = find(root, u+2); Splay(x, 0), Splay(y, root); c[y][0] = 0; &#125; int querymin(int u, int v) &#123; int x = find(root, u), y = find(root, v+2); Splay(x, 0), Splay(y, root); return Min[c[y][0]]; &#125; ll querysum(int u,int v)&#123; int x = find(root, u), y = find(root, v+2); Splay(x, 0), Splay(y, root); return Sum[c[y][0]]; &#125; void inorder(int u)&#123; //中序遍历最后结果 if(!u) return; Push_down(u); inorder(c[u][0]); if(Val[u]!=INF) printf("%d ",Val[u]); inorder(c[u][1]); &#125;&#125; Spt;char s[10];int n,q,l,r,v;int main() &#123; while(~scanf("%d",&amp;n))&#123; Spt.init(); Spt.root = Spt.Newnode(INF); for(int i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;v); Spt.insert(v); &#125; Spt.insert(INF); scanf("%d", &amp;q); while(q--) &#123; scanf("%s", s); if(s[0] == 'A') &#123; scanf("%d%d%d", &amp;l, &amp;r, &amp;v); Spt.update(l, r, v); &#125; else if(s[0] == 'R' &amp;&amp; s[3] == 'E') &#123; scanf("%d%d", &amp;l, &amp;r); Spt.Reverse(l, r); &#125; else if(s[0] == 'R' &amp;&amp; s[3] == 'O') &#123; scanf("%d%d%d", &amp;l, &amp;r, &amp;v); Spt.Revolve(l, r, v); &#125; else if(s[0] == 'I') &#123; scanf("%d%d", &amp;l, &amp;r); Spt.Join(l, r); &#125; else if(s[0] == 'D') &#123; scanf("%d", &amp;l); Spt.del(l); &#125; else if(s[0] == 'M') &#123; scanf("%d%d", &amp;l, &amp;r); printf("%d\n", Spt.querymin(l, r)); &#125; &#125; //Spt.inorder(Spt.root); &#125;&#125; 无旋Treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e6+5;#define ls(x) arr[x].ch[0]#define rs(x) arr[x].ch[1]struct node&#123; int ch[2],siz,val,key;&#125;arr[maxn];int tot;void push_up(int o)&#123; arr[o].siz=arr[ls(o)].siz+arr[rs(o)].siz+1;&#125;void Split(int root,int &amp;x,int &amp;y,int value)&#123; if(!root)&#123; x=y=0; return; &#125; if(arr[root].val&lt;=value) x=root,Split(rs(root),rs(x),y,value); else y=root,Split(ls(root),x,ls(y),value); push_up(root);&#125;void Merge(int &amp;root,int x,int y)&#123; if(!x||!y)&#123; root=x+y; return; &#125; if(arr[x].key&lt;arr[y].key) root=x,Merge(rs(root),rs(x),y); else root=y,Merge(ls(root),x,ls(y)); push_up(root);&#125;void Insert(int &amp;root,int value)&#123; int x=0,y=0,z=++tot; arr[z].val=value,arr[z].siz=1,arr[z].key=rand(); Split(root,x,y,value); Merge(x,x,z); Merge(root,x,y);&#125;void Erase(int &amp;root,int value)&#123; int x=0,y=0,z=0; Split(root,x,y,value); Split(x,x,z,value-1); Merge(z,ls(z),rs(z)); Merge(x,x,z); Merge(root,x,y);&#125;int Kth(int root,int k)&#123; while(arr[ls(root)].siz+1!=k)&#123; if(arr[ls(root)].siz&gt;=k) root=ls(root); else k-=arr[ls(root)].siz+1,root=rs(root); &#125; return arr[root].val;&#125;int Rank(int &amp;root,int value)&#123; int x=0,y=0; Split(root,x,y,value-1); int res=arr[x].siz+1; Merge(root,x,y); return res;&#125;int Pre(int &amp;root,int value)&#123; int x=0,y=0; Split(root,x,y,value-1); int res=Kth(x,arr[x].siz); Merge(root,x,y); return res;&#125;int Suf(int &amp;root,int value)&#123; int x=0,y=0; Split(root,x,y,value); int res=Kth(y,1); Merge(root,x,y); return res;&#125;int n,op,x,root;int main()&#123; srand(19260817); scanf("%d",&amp;n); while(n--)&#123; scanf("%d%d",&amp;op,&amp;x); if(op==1) Insert(root,x); if(op==2) Erase(root,x); if(op==3) printf("%d\n",Rank(root,x)); if(op==4) printf("%d\n",Kth(root,x)); if(op==5) printf("%d\n",Pre(root,x)); if(op==6) printf("%d\n",Suf(root,x)); &#125;&#125;/*您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：1.查询k在区间内的排名2.查询区间内排名为k的值3.修改某一位值上的数值4.查询k在区间内的前驱(前驱定义为严格小于x，且最大的数，若不存在输出-2147483647)5.查询k在区间内的后继(后继定义为严格大于x，且最小的数，若不存在输出2147483647)*/#include&lt;bits/stdc++.h&gt;#define INF 0x7fffffffusing namespace std;typedef long long ll;const int maxn = 5e4+5;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1#define ls(x) arr[x].ch[0]#define rs(x) arr[x].ch[1]struct node&#123; int ch[2],siz,val,key;&#125;arr[maxn*25];int tot;void push_up(int o)&#123; arr[o].siz=arr[ls(o)].siz+arr[rs(o)].siz+1;&#125;void Split(int root,int &amp;x,int &amp;y,int value)&#123; if(!root)&#123; x=y=0; return; &#125; if(arr[root].val&lt;=value) x=root,Split(rs(root),rs(x),y,value); else y=root,Split(ls(root),x,ls(y),value); push_up(root);&#125;void Merge(int &amp;root,int x,int y)&#123; if(!x||!y)&#123; root=x+y; return; &#125; if(arr[x].key&lt;arr[y].key) root=x,Merge(rs(root),rs(x),y); else root=y,Merge(ls(root),x,ls(y)); push_up(root);&#125;void Insert(int &amp;root,int value)&#123; int x=0,y=0,z=++tot; arr[z].val=value,arr[z].siz=1,arr[z].key=rand(); Split(root,x,y,value); Merge(x,x,z); Merge(root,x,y);&#125;void Erase(int &amp;root,int value)&#123; int x=0,y=0,z=0; Split(root,x,y,value); Split(x,x,z,value-1); Merge(z,ls(z),rs(z)); Merge(x,x,z); Merge(root,x,y);&#125;int Kth(int root,int k)&#123; while(arr[ls(root)].siz+1!=k)&#123; if(arr[ls(root)].siz&gt;=k) root=ls(root); else k-=arr[ls(root)].siz+1,root=rs(root); &#125; return arr[root].val;&#125;int Rank(int &amp;root,int value)&#123; int x=0,y=0; Split(root,x,y,value-1); int res=arr[x].siz; Merge(root,x,y); return res;&#125;int Pre(int &amp;root,int value)&#123; int x=0,y=0; Split(root,x,y,value-1); int res= -INF; //可能无前驱 if(arr[x].siz) res=Kth(x,arr[x].siz); Merge(root,x,y); return res;&#125;int Suf(int &amp;root,int value)&#123; int x=0,y=0; Split(root,x,y,value); int res=INF; //可能无后继 if(arr[y].siz) res=Kth(y,1); Merge(root,x,y); return res;&#125;int T[maxn&lt;&lt;2],a[maxn&lt;&lt;2];void Add(int pos,int value,int l,int r,int o)&#123; Insert(T[o],value); if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) Add(pos,value,lson); else Add(pos,value,rson);&#125;void Delete(int pos,int value,int l,int r,int o)&#123; Erase(T[o],value); if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) Delete(pos,value,lson); else Delete(pos,value,rson);&#125;int Query_Rank(int L,int R,int value,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) return Rank(T[o],value); int mid=(l+r)&gt;&gt;1,res=0; if(L&lt;=mid) res+=Query_Rank(L,R,value,lson); if(R&gt;mid) res+=Query_Rank(L,R,value,rson); return res;&#125;int Query_Pre(int L,int R,int value,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) return Pre(T[o],value); int mid=(l+r)&gt;&gt;1,res=-INF; if(L&lt;=mid) res=max(res,Query_Pre(L,R,value,lson)); if(R&gt;mid) res=max(res,Query_Pre(L,R,value,rson)); return res;&#125;int Query_Suf(int L,int R,int value,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) return Suf(T[o],value); int mid=(l+r)&gt;&gt;1,res=INF; if(L&lt;=mid) res=min(res,Query_Suf(L,R,value,lson)); if(R&gt;mid) res=min(res,Query_Suf(L,R,value,rson)); return res;&#125;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n,m,op,l,r,pos,k,root;int main()&#123; srand(19260817); n=read(),m=read(); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); Add(i,a[i],1,n,1); &#125; while(m--)&#123; op=read(); if(op==1)&#123; l=read(),r=read(),k=read(); printf("%d\n",Query_Rank(l,r,k,1,n,1)+1); &#125; if(op==2)&#123; l=read(),r=read(),k=read(); int L=1,R=1e8; while(L&lt;R)&#123; int mid=(L+R+1)&gt;&gt;1; if(Query_Rank(l,r,mid,1,n,1)&lt;k) L=mid; else R=mid-1; &#125; printf("%d\n",L); &#125; if(op==3)&#123; pos=read(),k=read(); Delete(pos,a[pos],1,n,1); a[pos]=k; Add(pos,a[pos],1,n,1); &#125; if(op==4)&#123; l=read(),r=read(),k=read(); printf("%d\n",Query_Pre(l,r,k,1,n,1)); &#125; if(op==5)&#123; l=read(),r=read(),k=read(); printf("%d\n",Query_Suf(l,r,k,1,n,1)); &#125; &#125;&#125; 素数筛12345678910111213int p[maxn],cnt=0;bool isp[maxn];void getprime()&#123; memset(isp,true,sizeof(isp)); isp[0]=isp[1]=false; isp[2]=true; for(int i=2;i&lt;maxn;i++)&#123; if(isp[i]) p[cnt++]=i; for(int j=0;j&lt;cnt&amp;&amp;p[j]*i&lt;maxn;j++)&#123; isp[p[j]*i]=false; &#125; &#125;&#125; Pollard_rho12345678910111213141516171819202122232425262728long long Pollard_rho(long long x,long long c)&#123; long long i=1,k=2; long long x0=rand()%x; long long y=x0; while(1) &#123; i++; x0=(qmul(x0,x0,x)+c)%x; long long d=gcd(y-x0,x); if(d!=1&amp;&amp;d!=x) return d; if(y==x0) return x; if(i==k)&#123;y=x0;k+=k;&#125; &#125;&#125;void findfac(long long n)&#123; if(Miller_Rabin(n)) &#123; factor[tol++]=n; return; &#125; long long p=n; while(p&gt;=n)p=Pollard_rho(p,rand()%(n-1)+1); findfac(p); findfac(n/p);&#125; 快速幂/快速乘1234567891011121314151617181920212223242526272829303132333435363738//a^b%pll qpow(ll a,ll b,ll p)&#123; ll res=1; while(b)&#123; if(b&amp;1) res=(res*a)%p; a=(a*a)%p; b&gt;&gt;=1; &#125; return res;&#125;//a*b%pll qmul(ll a,ll b,ll p)&#123; ll res=0; while(b)&#123; if(b&amp;1) res=(res+a)%p; a=(a+a)%p; b&gt;&gt;=1; &#125; return res;&#125;//十进制快速幂 a^ss % modll pow2(ll a,int n)&#123; ll ans=1; for(ll sum=a%mod;n;n&gt;&gt;=1,sum=sum*sum%mod) if(n&amp;1) ans=ans*sum%mod; return ans;&#125;ll pow10(ll a,ll b)&#123; ll sum=a,ans=1; while(b)&#123; int x = b%10; b/=10; ans=ans*pow2(sum,x)%mod; sum=pow2(sum,10); &#125; return ans;&#125; Lucas组合数取模1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//求解C(n,m)%P//杨辉三角void get_C()&#123; C[0][0] = 1; for(int i=1;i&lt;=maxn;i++)&#123; C[i][0] = 1; for(int j=1;j&lt;=i;j++) C[i][j] = C[i-1][j]+C[i-1][j-1]; //C[i][j] = (C[i-1][j]+C[i-1][j-1])%MOD; &#125;&#125;//P为素数且较小可以阶乘打表ll fac[maxn];ll C(ll n,ll m,ll p)&#123; if(m&gt;n) return 0; return fac[n]*qpow(fac[m]*fac[n-m],p-2,p)%p;&#125;ll Lucas(ll n,ll m,ll p)&#123; if(m==0) return 1; else return (C(n%p,m%p,p)*Lucas(n/p,m/p,p))%p;&#125;//P为素数且较大ll inv(ll x, ll p)&#123; return qpow(x,p-2,p);&#125;ll C(ll n,ll m,ll p)&#123; if(m&gt;n)return 0; ll up=1,down=1; for(int i=n-m+1;i&lt;=n;i++) up=up*i%p; for(int i=1;i&lt;=m;i++)down=down*i%p; return up*inv(down,p)%p;&#125;ll Lucas(ll n,ll m,ll p)&#123; if(m==0) return 1; return C(n%p,m%p,p)*Lucas(n/p,m/p,p)%p;&#125;//P不为素数ll extgcd(ll a,ll b,ll&amp; x,ll&amp; y)&#123; ll d = a; if(b)&#123; d=extgcd(b,a%b,y,x); y-=(a/b)*x; &#125; else x=1,y=0; return d;&#125;ll mod_inverse(ll a,ll m)&#123; ll x,y; ll d=extgcd(a,m,x,y); return d==1?(m+x%m)%m:-1;&#125;ll Mul(ll n,ll pi,ll pk)&#123; if(!n) return 1; ll ans=1; if(n/pk)&#123; for(ll i=2;i&lt;=pk;i++) if(i%pi)ans=ans*i%pk; ans=qpow(ans,n/pk,pk); &#125; for(ll i=2;i&lt;=n%pk;i++) if(i%pi) ans=ans*i%pk; return ans*Mul(n/pi,pi,pk)%pk;&#125;ll C(ll n,ll m,ll p,ll pi,ll pk)&#123; if(m&gt;n)return 0; ll a=Mul(n,pi,pk),b=Mul(m,pi,pk),c=Mul(n-m,pi,pk); ll k=0,ans; for(ll i=n;i;i/=pi) k+=i/pi; for(ll i=m;i;i/=pi) k-=i/pi; for(ll i=n-m;i;i/=pi) k-=i/pi; ans=a*mod_inverse(b,pk)%pk*mod_inverse(c,pk)%pk*qpow(pi,k,pk)%pk; ans=ans*(p/pk)%p*mod_inverse(p/pk,pk)%p; return ans;&#125;ll Lucas(ll n,ll m,ll p)&#123; ll x=p; ll ans=0; for(ll i=2;i&lt;=p;i++)&#123; if(x%i==0)&#123; ll pk=1; while(x%i==0) pk*=i,x/=i; ans=(ans+C(n,m,p,i,pk))%p; &#125; &#125; return ans;&#125; Miller_Pabin 素数判定1234567891011121314151617ll prime[6] = &#123;2, 3, 5, 233, 331&#125;;bool Miller_Rabin(ll p) &#123; if(p &lt; 2) return 0; if(p != 2 &amp;&amp; p % 2 == 0) return 0; ll s = p - 1; while(! (s &amp; 1)) s &gt;&gt;= 1; for(int i = 0; i &lt; 5; ++i) &#123; if(p == prime[i]) return 1; ll t = s, m = qpow(prime[i], s, p); while(t != p - 1 &amp;&amp; m != 1 &amp;&amp; m != p - 1) &#123; m = qmul(m, m, p); t &lt;&lt;= 1; &#125; if(m != p - 1 &amp;&amp; !(t &amp; 1)) return 0; &#125; return 1;&#125; BM递推123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1000000007;ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;// headint _,n;namespace linear_seq &#123; const int N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;int&gt; Md; void mul(ll *a,ll *b,int k) &#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int solve(ll n,VI a,VI b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+...// printf("%d\n",SZ(b)); ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt;p&gt;=0;p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; &#125; VI BM(VI s) &#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int gao(VI a,ll n) &#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); &#125;&#125;;int main() &#123; for (scanf("%d",&amp;_);_;_--) &#123; scanf("%d",&amp;n); printf("%d\n",linear_seq::gao(VI&#123;2,24,96,416,1536,5504,18944,64000,212992,702464&#125;,n-1)); &#125;&#125;#include&lt;bits/stdc++.h&gt;#define ll long long#define VI vector&lt;ll&gt;using namespace std;//BM:求线性递推数列第n项，请保证模数的平方不会爆long longclass Linear_Seq&#123;public: static const int N = 50010;//多项式系数项数最大值 ll res[N],c[N],vis[N],Mod,COEF[N];//COEF是多项式系数 vector&lt;int&gt; md; inline static ll exgcd(ll a,ll b, ll &amp;x,ll &amp;y) &#123; if(!b) &#123; x = 1,y = 0; return a; &#125; ll ret = exgcd(b,a%b,y,x); y -= a/b*x; return ret; &#125; inline static ll getInv(ll a,ll mod)//求a在mod下的逆元，不存在时输出-1 &#123; ll x,y; ll d = exgcd(a,mod,x,y); return d == 1?(x%mod+mod)%mod:-1; &#125; inline void mul(ll *a,ll *b,int k) &#123; fill(c,c+2*k,0); for(int i = 0;i &lt; k;++i) if(a[i]) for(int j = 0;j &lt; k;++j) c[i+j] = (c[i+j]+a[i]*b[j])%Mod; for(int i = 2*k-1;i &gt;= k;--i) if(c[i]) for(size_t j = 0;j &lt; md.size();++j) c[i-k+md[j]] = (c[i-k+md[j]]-c[i]*vis[md[j]])%Mod; copy(c,c+k,a); &#125; int solve(ll n,VI a,VI b)//a系数,b初值b[n+1] = a[0]*b[n]+... &#123; ll ans = 0,cnt = 0; int k = a.size(); for(int i = 0;i &lt; k;++i) vis[k-i-1] = -a[i]; vis[k] = 1;md.clear(); for(int i = 0;i &lt; k;++i) &#123; res[i] = 0; if(vis[i]) md.push_back(i); &#125; res[0] = 1; while((1LL&lt;&lt;cnt) &lt;= n) ++cnt; for(int p = cnt;~p;--p) &#123; mul(res,res,k); if((n&gt;&gt;p)&amp;1) &#123; copy(res,res+k,res+1) ; res[0]=0; for(size_t j = 0;j &lt; md.size();++j) res[md[j]] = (res[md[j]]-res[k]*vis[md[j]])%Mod; &#125; &#125; for(int i = 0;i &lt; k;++i) ans = (ans + res[i]*b[i]) % Mod; return ans + (ans&lt;0?Mod:0); &#125; ///1-st***********模数是质数用这里*******************/ VI BM(VI val) //BM算法求模数是质数的递推式子的通项公式,可以单独用 &#123; VI ans(1,1),lst(1,1); int len = 0,m = 1,fail = 1; for(size_t n = 0;n &lt; val.size();++n) &#123; ll delta = 0; for(int i = 0;i &lt;= len;++i) delta = (delta+(ll)ans[i]*val[n-i])%Mod; if(!delta) ++m; else &#123; VI tmp = ans; ll div = Mod-delta*getInv(fail,Mod)%Mod; while(ans.size() &lt; lst.size()+m) ans.push_back(0); for(size_t i = 0;i &lt; lst.size();++i) ans[i+m] = (ans[i+m]+div*lst[i])%Mod; if(2*len&lt;=(int)n) &#123; len=n+1-len; lst=tmp; fail=delta; m=1; &#125; else ++m ; &#125; &#125; //下边这样写能够输出递推式的系数. printf("F[n] = ") ; for(size_t i(0);i&lt;ans.size();++i) &#123; COEF[i+1] = min(ans[i],Mod-ans[i]) ; if(i&gt;0) &#123; if(i != 1) printf(" + ") ; printf("%lld*F[n-%d]",COEF[i+1],i) ; putchar(i+1==ans.size()?'\n':' ') ; &#125; &#125; return ans; &#125; ///1-ed*************模数是质数用这里*******************/ ///2-st*************模数非质数用这里*******************/ inline static void extand(VI &amp;a,size_t d,ll value = 0) &#123; if(d &lt;= a.size()) return; a.resize(d,value); &#125; inline static ll CRT(const VI &amp;a,const VI &amp;m) &#123; int n = a.size(); ll ans = 0,lcm = 1,x,y; for(int i = 0;i &lt; n;++i) lcm *= m[i]; for(int i = 0;i &lt; n;++i) &#123; ll tp = lcm/m[i]; exgcd(tp,m[i],x,y); x = (x%m[i]+m[i])%m[i]; ans = (ans+tp*x*a[i])%lcm; &#125; return (ans+lcm)%lcm; &#125; static VI ReedsSloane(const VI &amp;s,ll Mod) &#123; auto L = [](const VI &amp;a,const VI &amp;b) &#123; int da = (a.size() &gt; 1 || (a.size() == 1 &amp;&amp; a[0]))?a.size()-1:-1000; int db = (b.size() &gt; 1 || (b.size() == 1 &amp;&amp; b[0]))?b.size()-1:-1000; return max(da,db+1); &#125;; auto prime_power = [&amp;](const VI &amp; s,ll Mod,ll p,ll e) &#123; vector&lt;VI&gt; a(e),b(e),an(e),bn(e),ao(e),bo(e); VI t(e),u(e),r(e),to(e,1),uo(e),pw(e+1); pw[0] = 1; for(int i = 1;i &lt;= e;++i) pw[i] = pw[i-1] * p; for(ll i = 0;i &lt; e;++i) &#123; a[i] = &#123;pw[i]&#125;;an[i] = &#123;pw[i]&#125;; b[i] = &#123;0&#125;,bn[i] = &#123;s[0]*pw[i]%Mod&#125;; t[i] = s[0] * pw[i] %Mod; if(!t[i]) t[i] = 1,u[i] = e; else for(u[i] = 0;t[i] % p == 0;t[i] /= p,++u[i]); &#125; for(size_t k = 1;k &lt; s.size();++k) &#123; for(int g = 0;g &lt; e;++g) &#123; if(L(an[g],bn[g]) &gt; L(a[g],b[g])) &#123; ao[g] = a[e-1-u[g]],bo[g] = b[e-1-u[g]]; to[g] = t[e-1-u[g]],uo[g] = u[e-1-u[g]]; r[g] = k - 1; &#125; &#125; a = an,b = bn; for(int o = 0;o &lt; e;++o) &#123; ll d = 0; for(size_t i = 0;i &lt; a[o].size() &amp;&amp; i &lt;= k;++i) d = (d+a[o][i] * s[k-i])%Mod; if(d == 0) t[o] = 1,u[o] = e; else &#123; for(u[o] = 0,t[o] = d;!(t[o]%p);t[o] /= p,++u[o]); int g(e-1-u[o]); if(!L(a[g],b[g])) &#123; extand(bn[o],k+1); bn[o][k] = (bn[o][k]+d)%Mod; &#125; else &#123; ll coef = t[o]*getInv(to[g],Mod)%Mod*pw[u[o]-uo[g]]%Mod; int m = k-r[g]; extand(an[o],ao[g].size()+m); extand(bn[o],bo[g].size()+m); auto fun = [&amp;](vector&lt;VI&gt; &amp;vn,vector&lt;VI&gt; &amp;vo,bool f) &#123; for (size_t i(0);i &lt; vo[g].size();++i) &#123; vn[o][i+m] -= coef*vo[g][i]%Mod; if (vn[o][i + m]&lt;0) vn[o][i+m] += Mod*(f?1:-1); &#125; while (vn[o].size() &amp;&amp; !vn[o].back()) vn[o].pop_back(); &#125;; fun(an,ao,1),fun(bn,bo,-1); &#125; &#125; &#125; &#125; return make_pair(an[0],bn[0]); &#125;; vector&lt;tuple&lt;ll,ll,int&gt; &gt; fac;//tuple相当于结构体 for(ll i = 2;i * i &lt;= Mod;++i) if(!(Mod% i)) &#123; ll cnt = 0,pw = 1; while(!(Mod%i)) &#123; Mod /= i; ++cnt; pw *= i; &#125; fac.emplace_back(pw,i,cnt);//emplace_back作用同push_back,但直接调用构造函数,相对较快 &#125; if(Mod &gt; 1) fac.emplace_back(Mod,Mod,1); vector&lt;VI&gt; as; size_t n = 0; for(auto &amp;&amp;x: fac) &#123; ll Mod,p,e; VI a,b; std::tie(Mod,p,e) = x; auto ss = s; for(auto &amp;&amp;x: ss) x %= Mod; std::tie(a,b) = prime_power(ss,Mod,p,e); as.emplace_back(a); n = max(n,a.size()); &#125; VI a(n),c(as.size()),m(as.size()); for(size_t i = 0;i &lt; n;++i) &#123; for(size_t j = 0;j &lt; as.size();++j) &#123; m[j] = std::get&lt;0&gt;(fac[j]); c[j] = i &lt; as[j].size()?as[j][i]:0; &#125; a[i] = CRT(c,m); &#125; return a; &#125; ///2-ed***********模数非质数用这里*******************/ ll solve(VI a,ll n,ll Mod,bool prime = true) &#123; VI c; this -&gt; Mod = Mod; if(prime) c = BM(a);//如果已经知道系数了，直接输入到c就行了 else c = ReedsSloane(a,Mod); c.erase(c.begin()); for(size_t i = 0;i &lt; c.size(); ++i) c[i] = (Mod-c[i]) % Mod; return solve(n,c,VI(a.begin(),a.begin() + c.size())); &#125;&#125;BMEX;//BMEX.solve(初始值vector[从0开始],要得到的项数,模数,模数是不是质数)ll qpow(ll a,ll b,ll mod)&#123; ll ans = 1; while(b) &#123; if(b &amp; 1) ans = a * ans %mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans;&#125;ll n;vector&lt;ll&gt; ve;int main()&#123; while(~scanf("%lld",&amp;n))&#123; ve.clear(); ll MOD = 1000000007; ve.push_back(0),ve.push_back(1),ve.push_back(1); for(int i = 3;i &lt; 50;++i) ve.push_back((ve[i-1]+ve[i-2])%MOD); ll ans = BMEX.solve(ve,n,MOD,true); printf("%lld\n",ans); &#125; return 0;&#125; 莫队123456789101112131415161718192021int len = sqrt(n);struct Query&#123; int L,R,id,block; Query()&#123;&#125; Query(int l, int r, int id):L(l), R(r), id(id)&#123; block = L/len; &#125; bool operator &lt; (const Query &amp;hs) const &#123; if(block == hs.block) return R &lt; hs.R; return block &lt; hs.block; &#125;&#125;q[maxm];int L=1,R=1;for(int i=1;i&lt;=m;i++)&#123; while(R &lt; q[i].R) Insert(A[++R]); while(L &gt; q[i].L) Insert(A[--L]); while(R &gt; q[i].R) Erase(A[R--]); while(L &lt; q[i].L) Erase(A[L++]); ans[q[i].id]= ?;&#125; 二分/三分123456789101112131415161718192021222324252627282930313233343536373839404142434445//找a[]中&gt;=x最小的那个while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(a[mid]&gt;=x) r=mid; else l=mid+1;&#125;return a[l];//找a[]中&lt;=x最大的那个while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(a[mid]&lt;=x) l=mid; else r=mid-1;&#125;return a[l];//实数域二分 eps=10^-(k+2)while(l+eps&lt;r)&#123; double mid=(l+r)/2; if(calc(mid)) r=mid;else l=mid;&#125;for(int i=0;i&lt;100;i++)&#123; double mid=(l+r)/2; if(calc(mid)) r=mid;else l=mid;&#125;三分写法//doublewhile(l+eps&lt;r)&#123; double lmid = (2*l+r)/3; //l+(r-l)/3 , (l+r)/2 double rmid = (l+2*r)/3; //r-(r-l)/3 , (lmid+r)/2 if(f(lmid)&gt;=f(rmid)) r=rmid; else l=lmid;&#125;//intwhile(l+1&lt;r)&#123; int lmid = (l+r)/2; int rmid = (lmid+r)/2; if(calc(lmid)&lt;calc(rmid)) r=rmid; else l=lmid;&#125; LIS12345678910111213141516171819//nlogn 求LIS长度以及输出其中一种int len=0;for(int i=1;i&lt;=n;i++)&#123; if(len==0||a[i]&gt;dp[len])&#123; dp[++len]=a[i]; pos[i]=len; &#125; else&#123; *(lower_bound(dp+1,dp+1+len,a[i])) = a[i]; pos[i] = lower_bound(dp+1,dp+1+len,a[i]) - dp; &#125;&#125;int t=len;for(int i=n;i&gt;=1;i--)&#123; if(pos[i]==t)&#123; seq[t--]=a[i]; &#125; if(!t) break;&#125; 线性基123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114const int MN=62;ll p[65],tmp[65];bool flag;void ins(ll x)&#123; for(int i=MN;~i;i--) if(x&amp;(1LL&lt;&lt;i)) if(!p[i])&#123;p[i]=x;return;&#125; else x^=p[i]; flag=true;&#125;//判断是否可以异或出结果xbool check(ll x)&#123; for(int i=MN;~i;i--) if(x&amp;(1LL&lt;&lt;i)) if(!p[i])return false; else x^=p[i]; return true;&#125;//查询异或最大ll qmax(ll res=0)&#123; for(int i=MN;~i;i--) res=max(res,res^p[i]); return res;&#125;//查询异或最小ll qmin()&#123; if(flag)return 0; for(int i=0;i&lt;=MN;i++) if(p[i])return p[i];&#125;//查询异或第k大ll query(ll k)&#123; ll res=0;int cnt=0; k-=flag;if(!k)return 0; for(int i=0;i&lt;=MN;i++)&#123; for(int j=i-1;~j;j--) if(p[i]&amp;(1ll&lt;&lt;j))p[i]^=p[j]; if(p[i])tmp[cnt++]=p[i]; &#125; if(k&gt;=(1ll&lt;&lt;cnt))return -1; for(int i=0;i&lt;cnt;i++) if(k&amp;(1ll&lt;&lt;i))res^=tmp[i]; return res;&#125;//区间异或值最大#pragma GCC optimize(2)#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+5;int b[N][32],p[N][32];//p[r][i] 表示满足下列条件的最大的 l,线性基第 i 位有值且 l≤r//b[r][i] 表示此时第 i 位的线性基void add(int x, int k, int r) &#123; for(int i=0;i&lt;=30;i++)&#123; b[r][i]=b[r-1][i]; p[r][i]=p[r-1][i]; &#125; for (int i = 30; i &gt;= 0; i--) if ((x &gt;&gt; i) &amp; 1) &#123; if (!b[r][i]) &#123; b[r][i] = x; p[r][i] = k; return; &#125; if (p[r][i] &lt; k) &#123; swap(p[r][i], k); swap(x, b[r][i]); &#125; x ^= b[r][i]; &#125;&#125;int ask(int l, int r) &#123; int ans = 0; for (int i = 30; i &gt;= 0; i--) if (p[r][i] &gt;= l) ans = max(ans, ans ^ b[r][i]); return ans;&#125;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; memset(b,0,sizeof(b)); memset(p,0,sizeof(p)); int n,m; scanf("%d%d",&amp;n,&amp;m); for(int r=1;r&lt;=n;r++)&#123; int x;scanf("%d",&amp;x); add(x,r,r); &#125; int lastans=0; while(m--)&#123; int op,x,l,r; scanf("%d",&amp;op); if(op==1)&#123; scanf("%d",&amp;x); x^=lastans; ++n; add(x,n,n); &#125; else&#123; scanf("%d%d",&amp;l,&amp;r); l=(l^lastans)%n+1; r=(r^lastans)%n+1; if(l&gt;r) swap(l,r); int res=ask(l,r); printf("%d\n",res); lastans=res; &#125; &#125; &#125;&#125; SG1234567891011121314151617181920212223//f[]：可以取走的石子个数//sg[]:0~n的SG函数值//hash[]:mex&#123;&#125;int f[N],sg[N],hash[N]; void getSG(int n)&#123; int i,j; memset(sg,0,sizeof(sg)); for(i=1;i&lt;=n;i++) &#123; memset(hash,0,sizeof(hash)); for(j=1;f[j]&lt;=i;j++) hash[sg[i-f[j]]]=1; for(j=0;j&lt;=n;j++) //求mes&#123;&#125;中未出现的最小的非负整数 &#123; if(hash[j]==0) &#123; sg[i]=j; break; &#125; &#125; &#125;&#125; Crt/Excrt12345678910111213141516171819202122232425262728293031323334353637383940//n个方程：x=a[i](mod m[i]) (0&lt;=i&lt;n)LL china(int n, LL *a, LL *m)&#123; LL M = 1, ret = 0; for(int i = 0; i &lt; n; i ++) M *= m[i]; for(int i = 0; i &lt; n; i ++)&#123; LL w = M / m[i]; ret = (ret + w * inv(w, m[i]) * a[i]) % M; &#125; return (ret + M) % M;&#125;void ex_gcd(LL a, LL b, LL &amp;x, LL &amp;y, LL &amp;d)&#123; if (!b) &#123;d = a, x = 1, y = 0;&#125; else&#123; ex_gcd(b, a % b, y, x, d); y -= x * (a / b); &#125;&#125; LL inv(LL t, LL p)&#123;//如果不存在，返回-1 LL d, x, y; ex_gcd(t, p, x, y, d); return d == 1 ? (x % p + p) % p : -1; &#125;typedef pair&lt;LL, LL&gt; PLL;PLL linear(LL A[], LL B[], LL M[], int n) &#123;//求解A[i]x = B[i] (mod M[i]),总共n个线性方程组 LL x = 0, m = 1; for(int i = 0; i &lt; n; i ++) &#123; LL a = A[i] * m, b = B[i] - A[i]*x, d = __gcd(M[i], a); if(b % d != 0) return PLL(-1, -1);//答案不存在，返回-1 LL t = b/d * inv(a/d, M[i]/d)%(M[i]/d); x = x + m*t; m *= M[i]/d; &#125; x = (x % m + m ) % m; if(x==0) x = m; return PLL(x, m);//返回的x就是答案，m是最后的lcm值 //如果x==0，那么ans为m&#125; BSGS/ExBSGS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/*(感觉这东西还是要写一下)BSGS主要用于求解形如xk=y(modp)(注意这里p与x互质)这样的方程的最小正整数解的问题设m=?p–√?,k=am?b,a∈[1,m],b∈[0,m)那么上面的方程可以变形成xam=yxb(modp)枚举b,计算出右边的值存到map中,枚举a查表即可Q:可以枚举左边存表,右边查嘛?A:可以,但是左边查到表可以直接输出...顺便一说,map里要存最大值,这样你算出的答案是最小的,所以能更新就更新复杂度:O(p–√logp)模板题[TJOI2007]可爱的质数*/#include&lt;bits/stdc++.h&gt;using namespace std;int p;map&lt;int,int&gt;M;int ksm(int x,int y)&#123; int s=1; while(y)&#123;if(y&amp;1)s=1ll*s*x%p;x=1ll*x*x%p;y&gt;&gt;=1;&#125; return s;&#125;int main()&#123; int x,y; cin&gt;&gt;p&gt;&gt;x&gt;&gt;y; int m=sqrt(p)+1; int s=y; for(int i=0;i&lt;m;i++)&#123; M[s]=i;//能更新就更新 s=1ll*s*x%p; &#125; int t=ksm(x,m);s=1; for(int i=1;i&lt;=m;i++)&#123; s=1ll*s*t%p; if(M.count(s))&#123;printf("%d\n",i*m-M[s]);return 0;&#125; &#125; puts("no solution");return 0;&#125;/*扩展BSGS当p不是素数时(这时x,p不一定互质),设d=gcd(x,p),若d不整除y,那么只有y=1时,x=0,其他情况均无解若d整除y,当d=1时,直接BSGS否则有xk=y(modp)xk?1×xd=yd(modpd)继续分解到d=1为止.xk?t×xt∏di=y∏di(modp∏di)然后首先检验x=[0,t)是否为解,显然t是log级别的如果[0,t)都不是解,由于x,p∏di互质,BSGS求解即可最后记得答案加上t啊模板题[SPOJ3105]MOD*/#include&lt;bits/stdc++.h&gt;using namespace std;int re()&#123; int x=0,w=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')x=x*10+ch-'0',ch=getchar(); return x*w;&#125;int p;map&lt;int,int&gt;M;void mul(int&amp;x,int y)&#123;x=1ll*x*y%p;&#125;int ksm(int x,int y)&#123; int s=1; while(y)&#123;if(y&amp;1)mul(s,x);mul(x,x);y&gt;&gt;=1;&#125; return s;&#125;void exbsgs(int x,int y)&#123; if(y==1)&#123;puts("0");return;&#125; int d=__gcd(x,p),k=1,t=0; while(d^1)&#123; if(y%d)&#123;puts("No Solution");return;&#125; ++t;y/=d;p/=d;mul(k,x/d); if(y==k)&#123;printf("%d\n",t);return;&#125; d=__gcd(x,p); &#125; int s=y;M.clear();int m=sqrt(p)+1; for(int i=0;i&lt;m;i++)&#123; M[s]=i;mul(s,x); &#125; s=k;k=ksm(x,m); for(int i=1;i&lt;=m;i++)&#123; mul(s,k); if(M[s])&#123;printf("%d\n",i*m-M[s]+t);return;&#125; &#125; puts("No Solution");&#125;int main()&#123; int x,y; while(1)&#123; x=re(),p=re(),y=re(); if(!x&amp;&amp;!p&amp;&amp;!y)break; x%=p;y%=p; exbsgs(x,y); &#125; return 0;&#125; 求解特殊不定不等式12345678910111213141516//求解la/lb&lt; x/y &lt; ra/rb 的使得x,y最小的解void f(ll la,ll lb,ll ra,ll rb,ll&amp; x,ll&amp; y)&#123; ll minint=la/lb+1; if(minint&lt;=ra/rb) &#123; x=minint; y=1; return ; &#125; minint--;//意为floor(la/lb) la-=minint*lb; ra-=minint*rb; f(rb,ra,lb,la,y,x); x+=minint*y; return ;&#125; 二次剩余123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef long long ll;LL quick_mod(LL a, LL b, LL m)&#123; LL ans = 1; a %= m; while(b)&#123; if(b &amp; 1)&#123; ans = ans * a % m; b--; &#125; b &gt;&gt;= 1; a = a * a % m; &#125; return ans;&#125;struct T&#123; LL p, d;&#125;;LL w;//二次域乘法T multi_er(T a, T b, LL m)&#123; T ans; ans.p = (a.p * b.p % m + a.d * b.d % m * w % m) % m; ans.d = (a.p * b.d % m + a.d * b.p % m) % m; return ans;&#125;//二次域上快速幂T power(T a, LL b, LL m)&#123; T ans; ans.p = 1; ans.d = 0; while(b) &#123; if(b &amp; 1) &#123; ans = multi_er(ans, a, m); b--; &#125; b &gt;&gt;= 1; a = multi_er(a, a, m); &#125; return ans;&#125;//求勒让德符号LL Legendre(LL a, LL p)&#123; return quick_mod(a, (p-1)&gt;&gt;1, p);&#125; LL mod(LL a, LL m)&#123; a %= m; if(a &lt; 0) a += m; return a;&#125;//求解x^2=n mod p;//若返回-1，无解，否则返回一个解x1//一般有两个解，另一个解为x2 = p-x1；LL Solve(LL n,LL p)&#123; if(p == 2) return 1; ll czc = Legendre(n, p); if (czc + 1 == p) return -1; if(czc == 0) return 0; LL a = -1, t; while(true) &#123; a = rand() % p; t = a * a - n; w = mod(t, p); if(Legendre(w, p) + 1 == p) break; &#125; T tmp; tmp.p = a; tmp.d = 1; T ans = power(tmp, (p + 1)&gt;&gt;1, p); return ans.p;&#125;/*hdu 3930 题意： 给定newx, k, m, 方程 (x^k)%m=newx, 求在模m意义下的所有解x。 限制： 0 &lt;= newx, m, k &lt;= 1.5*10^15; m是素数。 思路： N次剩余 */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;#define LL __int64#define PB push_backLL mul(LL a,LL b,LL m)&#123; LL ret = 0; a %= m; while(b)&#123; if(b &amp; 1) ret = (ret + a) % m; a = (a + a) % m; b &gt;&gt;= 1; &#125; return ret;&#125;LL a_b_MOD_c(LL a,LL b,LL m)&#123; LL ret = 1; a %= m; while(b)&#123; if(b&amp;1) ret = mul(ret,a,m); a = mul(a,a,m); b &gt;&gt;= 1; &#125; return ret;&#125; LL ext_gcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if(b==0) &#123; x=1, y=0; return a; &#125; LL ret= ext_gcd(b,a%b,y,x); y-= a/b*x; return ret;&#125;vector&lt;LL&gt; a;bool g_test(LL g,LL p)&#123; for(LL i=0;i&lt;a.size();++i) if(a_b_MOD_c(g,(p-1)/a[i],p)==1) return 0; return 1;&#125;LL pri_root(LL p)&#123; a.clear(); LL tmp=p-1; for(LL i=2;i&lt;=tmp/i;++i) if(tmp%i==0)&#123; a.push_back(i); while(tmp%i==0) tmp/=i; &#125; if(tmp!=1) a.push_back(tmp); LL g=1; while(true)&#123; if(g_test(g,p)) return g; ++g; &#125;&#125;const int HASH_MOD=9876543;LL key[HASH_MOD], val[HASH_MOD];int head[HASH_MOD], next[HASH_MOD];struct Hash&#123; int tot; void init()&#123; memset(head, -1, sizeof(head)); tot = 0; &#125; LL insert(LL x, LL y)&#123; int k = x % HASH_MOD; key[tot] = x; val[tot] = y; next[tot] = head[k]; head[k] = tot++; &#125; LL find(LL x)&#123; int k = x % HASH_MOD; for(int i = head[k]; i != -1; i = next[i]) if(key[i] == x) return val[i]; return -1; &#125;&#125;hs;//求解模方程a^x=b(mod m),n为素数,无解返回-1 //注意：要求0 &lt; a &lt; m; 0 &lt;= b &lt; m; 否则按题意自己转化。//复杂度O(sqrt(m))LL log_mod(LL a, LL b, LL m)&#123; hs.init(); LL s = ceil(sqrt(m + 0.5)); LL cur = 1; for (int i = 0; i &lt; s; ++i)&#123; if(hs.find(cur)==-1) hs.insert(cur,i); //记得先判重，在插入 cur = cur * a % m; &#125; LL v = a_b_MOD_c(a, (m - s - 1 + m) % m, m); for(int i = 0; i &lt; s; ++i)&#123; LL tmp = hs.find(b); if(tmp!=-1) return s * i + tmp; b=b*v%m; &#125; return -1;&#125;/*n次剩余 任务： 给定N, a, p, 求出(x^N)%p=a 在模p意义下的所有解x。 说明： 令g为p的原根，因为p为素数，所以phi(p)=p-1。 由原根的性质得： 如果g为p的原根，则：g^i mod p != g^j mod p (p为素数), 其中i != j且i, j介於1至(p-1)之间 所以，可以设g^y=x, g^t=a，则有： g^(y*N)%p=g^t 又由原根的性质： g^(y*N)%p=g^t -&gt; (y*N)%(p-1)=t (此方程可以由拓展欧几里得解) 另外g^t=a可以由离散对数求出 */vector&lt;LL&gt; residue(LL p, LL N, LL a)&#123; LL g = pri_root(p); g %= p; LL m = log_mod(g, a, p); vector&lt;LL&gt; ret; if(a == 0)&#123; ret.PB(0); return ret; &#125; if(m == -1) return ret; LL A = N, B = p - 1, C = m, x, y; LL d = ext_gcd(A, B, x, y); if(C % d != 0) return ret; x = x * (C / d) % B; LL delta = B / d; for(int i = 0; i &lt; d; ++i)&#123; x = ((x + delta) % B + B) % B; ret.PB(a_b_MOD_c(g, x, p)); &#125; sort(ret.begin(), ret.end()); ret.erase(unique(ret.begin(), ret.end()), ret.end()); return ret;&#125;int main()&#123; int cas = 0; LL k,m,newx; while(scanf("%I64d%I64d%I64d",&amp;k, &amp;m, &amp;newx)!=EOF)&#123; vector&lt;LL&gt; ans; ans = residue(m,k,newx); printf("case%d:\n",++cas); if(ans.size()==0) puts("-1"); for(int i = 0; i &lt; ans.size(); ++i) printf("%I64d\n",ans[i]); &#125; return 0;&#125; 类欧几里得 f(a,b,c,n)=\sum_{i=0}^n \lfloor\frac{ai+b}{c}\rfloor g(a,b,c,n)=\sum_{i=0}^n i\lfloor\frac{ai+b}{c}\rfloor h(a,b,c,n)=\sum_{i=0}^n \lfloor\frac{ai+b}{c}\rfloor^2 m=\lfloor\frac{an+b}{c}\rfloor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//O(logn)求解f(a,b,c,n) = \sum floor(a*i+b/c) (0&lt;=i&lt;=n)LL S(LL k)&#123; return (k*(k+1)/2ll)%mod;&#125;LL f(LL a,LL b,LL c,LL n)&#123; if(!a)return 0; if(a&gt;=c || b&gt;=c) return ((a/c)*S(n)%mod+(n+1)*(b/c)%mod+f(a%c,b%c,c,n))%mod; LL m=(a*n+b)/c; return (m*n%mod-f(c,c-b-1,a,m-1)+mod)%mod;&#125;//以下为推广typedef long long LL;const LL mod=1e9+7,inv2=500000004,inv6=166666668; LL a,b,c,l,r;struct data&#123; LL f,g,h;&#125;;data calc(LL a,LL b,LL c,LL n)&#123; data tmp; if (!a) &#123; tmp.f=tmp.g=tmp.h=0; return tmp; &#125; if (a&gt;=c || b&gt;=c) &#123; tmp=calc(a%c,b%c,c,n); n%=mod; tmp.h=(tmp.h+ n*(n+1)%mod*(2*n+1)%mod*inv6%mod*(a/c)%mod*(a/c)%mod +(n+1)*(b/c)%mod*(b/c)%mod +(LL)2*(a/c)*tmp.g%mod +(LL)2*(b/c)*tmp.f%mod +n*(n+1)%mod*(a/c)%mod*(b/c))%mod; tmp.f=(tmp.f +n*(n+1)/2%mod*(a/c) +(n+1)*(b/c))%mod; tmp.g=(tmp.g +n*(n+1)%mod*(2*n+1)%mod*inv6%mod*(a/c) +n*(n+1)/2%mod*(b/c))%mod; return tmp; &#125; LL m=((LL)a*n+b)/c; data nxt=calc(c,c-b-1,a,m-1); n%=mod; m%=mod; tmp.f=((n*m-nxt.f)%mod+mod)%mod; tmp.g=(LL)((n*(n+1)%mod*m-nxt.f-nxt.h)%mod+mod)*inv2%mod; tmp.h=((m*(m+1)%mod*n-(LL)2*(nxt.g+nxt.f)%mod-tmp.f)%mod+mod)%mod; return tmp;&#125;int main()&#123; scanf("%d%d%d%d%d",&amp;a,&amp;c,&amp;b,&amp;l,&amp;r); printf("%d\n",(calc(a,b,c,r).g-calc(a,b,c,l-1).g+mod)%mod); return 0;&#125; 拓扑排序12345678910111213141516171819//求有向图顺序或判有环bool topu()&#123; queue&lt;int&gt;q; //要求字典序改优先队列 for(int i=1;i&lt;=n;i++)&#123; if(in[i]==0) q.push(i); &#125; int cnt=0; while(!q.empty())&#123; int x=q.front(); q.pop(); cnt++; for(int i=0;i&lt;V[x].size();i++)&#123; int next=V[x][i]; if(--in[next]==0) q.push(next); Rank[next]=Rank[x]+1; &#125; &#125; return cnt==n;&#125; Dijkstra1234567891011121314151617181920212223242526272829303132333435363738394041//求由form到图中其他点的最短路径struct node&#123; int val,id; node(int id,int val):id(id),val(val) &#123;&#125; bool operator &lt;(const node &amp;hs)const&#123; return val&gt;hs.val; &#125;&#125;;struct edge&#123; int next,to,w;&#125;e[maxm*2];int head[maxn],cnt;void addedge(int u,int v,int w)&#123; e[++cnt]=edge&#123;head[u],v,w&#125;; head[u]=cnt;&#125;int dis[maxn],vis[maxn];void dijkstra(int from)&#123; for(int i=1;i&lt;=n;i++)&#123; dis[i]=INF; vis[i]=0; &#125; priority_queue&lt;node&gt;q; q.push(node(from,0)); dis[from]=0; while(!q.empty())&#123; int cur=q.top().id; q.pop(); if(vis[cur])continue; vis[cur]=true; for(int i=head[cur]; i ; i=e[i].next)&#123; int v=e[i].to; if(dis[cur]+e[i].w &lt; dis[v])&#123; dis[v]=dis[cur]+e[i].w; q.push(node(v,dis[v])); &#125; &#125; &#125;&#125; Floyd12345678//dis[i][i]=0,dis[i][j]表示i到j的最短路径for(int k=1;k&lt;=n;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); &#125; &#125;&#125; Java大数开方1234567891011121314151617181920//判断是否为完全平方数public static boolean check(BigInteger now) &#123; if (now.compareTo(BigInteger.ZERO) == 0 || now.compareTo(BigInteger.ONE) == 0) return true; if (now.mod(BigInteger.valueOf(3)).compareTo(BigInteger.valueOf(2)) == 0) return false; String s = now.toString(); if (s.length() % 2 == 0) s = s.substring(0, s.length() / 2 + 1); else s = s.substring(0, (1 + s.length()) / 2); BigInteger res = BigInteger.ZERO; BigInteger m = new BigInteger(s); BigInteger two = new BigInteger("2"); if (s == "1") res = BigInteger.ONE; else &#123; while (now.compareTo(m.multiply(m)) &lt; 0) &#123; m = (m.add(now.divide(m))).divide(two); &#125; res = m; &#125; if (res.multiply(res).compareTo(now) == 0) return true; return false;&#125; 计算几何1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL ;const int N = 100000+7;#define abs(x) (((x)&gt;0)?(x):-(x))/***************************************/const double PI = acos(-1.0);const double eps = 1e-8;const double INF = 1e18;#define pb push_back#define mp make_pair///*************基础***********/double torad(double deg) &#123; return deg / 180 * PI; &#125;inline int dcmp(double x)&#123; if(fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125;struct Point&#123; double x, y; Point(double x=0, double y=0):x(x),y(y) &#123; &#125; inline void read() &#123; scanf("%lf%lf", &amp;x, &amp;y); &#125;&#125;;typedef vector&lt;Point&gt; Polygon;typedef Point Vector;inline Vector operator+ (Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y); &#125;inline Vector operator- (Point A, Point B) &#123; return Vector(A.x - B.x, A.y - B.y); &#125;inline Vector operator* (Vector A, double p) &#123; return Vector(A.x * p, A.y * p); &#125;inline Vector operator/ (Vector A, double p) &#123; return Vector(A.x / p, A.y / p); &#125;inline bool operator &lt; (Point a, Point b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y); &#125;inline bool operator == (Point a, Point b) &#123; return dcmp(a.x - b.x) == 0 &amp;&amp; dcmp(a.y - b.y) == 0; &#125;inline double Dot(Vector A, Vector B)&#123; return A.x * B.x + A.y * B.y;&#125;double msqrt(double x) &#123; if(x&lt;0) return 0; else return sqrt(x);&#125;double Length(Vector A) &#123; return msqrt(Dot(A, A)); &#125;double Length2(Vector A) &#123; return Dot(A, A); &#125;inline double Angle(Vector A, Vector B) &#123; return acos(Dot(A, B) / Length(A) / Length(B)); &#125;inline double angle(Vector v) &#123; return atan2(v.y, v.x); &#125;inline double Cross(Vector A, Vector B) &#123; return A.x * B.y - A.y * B.x; &#125;//A x B &gt; 0表示A在B的顺时针方向上inline Vector Unit(Vector x) &#123; return x / Length(x); &#125; //单位向量inline Vector Normal(Vector x) &#123; return Point(-x.y, x.x) / Length(x); &#125; //垂直法向量inline double Area2(Point A, Point B, Point C) &#123; return Cross(B - A, C - A); &#125;double Cross3(Point p0,Point p1,Point p2) &#123;return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125;///返回结果为正说明p0p1在p0p2的顺时针方向，正说明p2在向量p0p1的左边（三点构成逆时针方向） ///也可以说明p0在向量p1p2的左边（三点构成逆时针方向）,为负则相反,为0则三点共线(叉积的性质很重要)inline Vector Rotate(Vector A, double rad)&#123; return Vector(A.x * cos(rad) - A.y*sin(rad), A.x*sin(rad) + A.y * cos(rad));&#125;/****************直线与线段**************///求直线p+tv和q+tw的交点 Cross(v, w) == 0无交点Point GetLineIntersection(Point p, Vector v, Point q, Vector w)&#123; Vector u = p - q; double t = Cross(w, u) / Cross(v, w); return p + v * t;&#125;//线段到直线的方位int SegToLine(Point a,Point b,Point c,Point d) &#123;///Seg:ab Line:cd 已验证 int x = dcmp(Cross3(a,c,d)); int y = dcmp(Cross3(b,c,d)); if(x==y&amp;&amp;y==0) return 0;//线上 if(x+y==2) return 1;//同侧 左边 if(x+y==-2) return 2;//同侧 右边 if(x+y==0) return -1;//异侧 if(x+y==1) return -2;//一点在线上，另一点左边 return -3;//一点在线上，另一点右边&#125;//直线ab与直线cd的交点Point LineToLine(Point a,Point b,Point c,Point d) &#123; ///已验证 double x = Cross3(a,c,d),y = Cross3(b,c,d); int xx=dcmp(x),yy=dcmp(y); if(xx==yy&amp;&amp;xx==0) return &#123;-1e10,1e10&#125;;//重合 else if(dcmp(x-y)==0) return &#123;-1e10,-1e10&#125;;//平行 else &#123; Vector u = a-c; Vector v = (b-a)/Length((b-a)); Vector w = (d-c)/Length((d-c)); return a + (Point)(v*(Cross(w,u)/Cross(v,w))); &#125;&#125;//点p在直线ab的投影inline Point GetLineProjection(Point P, Point A, Point B) &#123; ///已验证 Vector v = B - A; return A + v * (Dot(v, P - A) / Dot(v, v));&#125;//点到直线距离inline double DistanceToLine(Point P, Point A, Point B) ///已验证&#123; Vector v1 = B - A, v2 = P - A; return fabs(Cross(v1, v2)) / Length(v1); // 如果不取绝对值，得到的是有向距离&#125;//点在p线段上(包括端点)inline bool OnSegment(Point p, Point a1, Point a2)&#123; return dcmp(Cross(a1-p, a2-p)) == 0 &amp;&amp; dcmp(Dot(a1-p, a2-p)) &lt;= 0;&#125;// 过两点p1, p2的直线一般方程ax+by+c=0// (x2-x1)(y-y1) = (y2-y1)(x-x1)inline void getLineGeneralEquation(Point p1, Point p2, double&amp; a, double&amp; b, double &amp;c) ///已验证&#123; a = p2.y - p1.y; b = p1.x - p2.x; c = -a * p1.x - b * p1.y;&#125;//点到线段距离double DistanceToSegment(Point p, Point a, Point b) ///已验证&#123; if(a == b) return Length(p - a); Vector v1 = b - a, v2 = p - a, v3 = p - b; if(dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if(dcmp(Dot(v1, v3)) &gt; 0) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1);&#125;//两线段最近距离inline double dis_pair_seg(Point p1, Point p2, Point p3, Point p4)&#123; return min(min(DistanceToSegment(p1, p3, p4), DistanceToSegment(p2, p3, p4)), min(DistanceToSegment(p3, p1, p2), DistanceToSegment(p4, p1, p2)));&#125;//线段相交判定inline bool SegmentProperIntersection(Point a, Point b, Point c, Point d)&#123; if(max(a.x , b.x) &lt; min(c.x , d.x)) return false; if(max(a.y , b.y) &lt; min(c.y , d.y)) return false; if(max(c.x , d.x) &lt; min(a.x , b.x)) return false; if(max(c.y , d.y) &lt; min(a.y , b.y)) return false; return dcmp(Cross(b-a,c-a))*dcmp(Cross(b-a,d-a))&lt;=0 &amp;&amp; dcmp(Cross(d-c,a-c))*dcmp(Cross(d-c,b-c))&lt;=0;&#125;// 有向直线。它的左边就是对应的半平面struct Line&#123; Point p, q; // 直线上任意一点,p作为起点 Vector v; // 方向向量 double ang; // 极角，即从x正半轴旋转到向量v所需要的角（弧度） Line() &#123;&#125;// Line(Point P, Vector v):p(P),v(v)// &#123;// ang = atan2(v.y, v.x);// &#125; Line(Point P, Point Q):p(P), q(Q) &#123; v = q - p; ang = atan2(v.y, v.x); &#125; inline bool operator &lt; (const Line&amp; L) const &#123; return ang &lt; L.ang; &#125; inline Point point(double t) &#123; return p + v * t; &#125; inline Line move(double d) &#123; return Line(p + Normal(v) * d, v); &#125; inline void read() &#123; Point q; p.read(), q.read(); v = q - p; ang = atan2(v.y, v.x); &#125;&#125;;//两直线交点inline Point GetLineIntersection(Line a, Line b) ///已验证&#123; return GetLineIntersection(a.p, a.v, b.p, b.v);&#125;// 点p在有向直线L的左边（线上不算）bool OnLeft(const Line&amp; L, const Point&amp; p) ///已验证&#123; return Cross(L.v, p - L.p) &gt; 0;&#125;int PointToLine(Point p,Point a,Point b) &#123;///1:左 -1:右 0:线上 已验证 return dcmp(Cross3(p, a, b));&#125;//// 二直线交点，假定交点惟一存在//Point GetLineIntersection(const Line&amp; a, const Line&amp; b) &#123;// Vector u = a.P-b.P;// double t = Cross(b.v, u) / Cross(a.v, b.v);// return a.P+a.v*t;//&#125;// 半平面交主过程vector&lt;Point&gt; HalfplaneIntersection(vector&lt;Line&gt; L) ///已验证&#123; int n = L.size(); sort(L.begin(), L.end()); // 按极角排序 int first, last; // 双端队列的第一个元素和最后一个元素的下标 vector&lt;Point&gt; p(n); // p[i]为q[i]和q[i+1]的交点 vector&lt;Line&gt; q(n); // 双端队列 vector&lt;Point&gt; ans; // 结果 q[first=last=0] = L[0]; // 双端队列初始化为只有一个半平面L[0] for(int i = 1; i &lt; n; i++) &#123; while(first &lt; last &amp;&amp; !OnLeft(L[i], p[last-1])) last--; while(first &lt; last &amp;&amp; !OnLeft(L[i], p[first])) first++; q[++last] = L[i]; if(fabs(Cross(q[last].v, q[last-1].v)) &lt; eps) // 两向量平行且同向，取内侧的一个 &#123; last--; if(OnLeft(q[last], L[i].p)) q[last] = L[i]; &#125; if(first &lt; last) p[last-1] = GetLineIntersection(q[last-1], q[last]); &#125; while(first &lt; last &amp;&amp; !OnLeft(q[first], p[last-1])) last--; // 删除无用平面 if(last - first &lt;= 1) return ans; // 空集 p[last] = GetLineIntersection(q[last], q[first]); // 计算首尾两个半平面的交点 // 从deque复制到输出中 for(int i = first; i &lt;= last; i++) ans.push_back(p[i]); return ans;&#125;/***********多边形**************///求多边形面积double PolygonArea(vector&lt;Point&gt; p) &#123; ///已验证 int n = p.size(); double area = 0; for(int i = 1; i &lt; n - 1; i++) area += Cross(p[i]-p[0], p[i+1]-p[0]); return area / 2;&#125;//判断点是否在多边形内int isPointInPolygon(Point p, Polygon poly) /// 已验证&#123; int wn = 0; int n = poly.size(); for (int i = 0; i &lt; n; i++) &#123; if (OnSegment(p, poly[i], poly[(i + 1) % n])) return -1; //边界 int k = dcmp(Cross(poly[(i + 1) % n] - poly[i], p - poly[i])); int d1 = dcmp(poly[i].y - p.y); int d2 = dcmp(poly[(i + 1) % n].y - p.y); if (k &gt; 0 &amp;&amp; d1 &lt;= 0 &amp;&amp; d2 &gt; 0) wn++; if (k &lt; 0 &amp;&amp; d2 &lt;= 0 &amp;&amp; d1 &gt; 0) wn--; &#125; if (wn != 0) return 1; //内部 return 0; //外部&#125;//多边形重心 点集逆时针给出Point PolyGravity(Point *p, int n) &#123; Point tmp, g = Point(0, 0); double sumArea = 0, area; for (int i=2; i&lt;n; ++i) &#123; area = Cross(p[i-1]-p[0], p[i]-p[0]); sumArea += area; tmp.x = p[0].x + p[i-1].x + p[i].x; tmp.y = p[0].y + p[i-1].y + p[i].y; g.x += tmp.x * area; g.y += tmp.y * area; &#125; g.x /= (sumArea * 3.0); g.y /= (sumArea * 3.0); return g;&#125;//多边形重心计算模板Point bcenter(vector&lt;Point&gt; pnt) ///已验证&#123; int n = pnt.size(); Point p, s; double tp, area = 0, tpx = 0, tpy = 0; p.x = pnt[0].x; p.y = pnt[0].y; //FE(i, 1, n) for(int i=1;i&lt;=n;i++) &#123; s.x = pnt[(i == n) ? 0 : i].x; s.y = pnt[(i == n) ? 0 : i].y; tp = (p.x * s.y - s.x * p.y); area += tp / 2; tpx += (p.x + s.x) * tp; tpy += (p.y + s.y) * tp; p.x = s.x; p.y = s.y; &#125; s.x = tpx / (6 * area); s.y = tpy / (6 * area); return s;&#125;// 点集凸包// 如果希望在凸包的边上有输入点，把两个 &lt;= 改成 &lt;// 注意：输入点集会被修改vector&lt;Point&gt; ConvexHull(vector&lt;Point&gt;&amp; p) /// 已验证&#123; // 预处理，删除重复点 sort(p.begin(), p.end()); p.erase(unique(p.begin(), p.end()), p.end()); int n = p.size(); int m = 0; vector&lt;Point&gt; ch(n+1); for(int i = 0; i &lt; n; i++) &#123; while(m &gt; 1 &amp;&amp; Cross(ch[m-1]-ch[m-2], p[i]-ch[m-2]) &lt;= 0) m--; ch[m++] = p[i]; &#125; int k = m; for(int i = n-2; i &gt;= 0; i--) &#123; while(m &gt; k &amp;&amp; Cross(ch[m-1]-ch[m-2], p[i]-ch[m-2]) &lt;= 0) m--; ch[m++] = p[i]; &#125; if(n &gt; 1) m--; ch.resize(m); return ch;&#125;inline double Dist2(Point a, Point b)&#123; return msqrt(a.x - b.x) + msqrt(a.y - b.y);&#125;// 返回点集直径的平方double diameter2(vector&lt;Point&gt;&amp; points)&#123; vector&lt;Point&gt; p = ConvexHull(points); int n = p.size(); if(n == 1) return 0; if(n == 2) return Dist2(p[0], p[1]); p.push_back(p[0]); // 免得取模 double ans = 0; for(int u = 0, v = 1; u &lt; n; u++) &#123; // 一条直线贴住边p[u]-p[u+1] for(;;) &#123; // 当Area(p[u], p[u+1], p[v+1]) &lt;= Area(p[u], p[u+1], p[v])时停止旋转 // 即Cross(p[u+1]-p[u], p[v+1]-p[u]) - Cross(p[u+1]-p[u], p[v]-p[u]) &lt;= 0 // 根据Cross(A,B) - Cross(A,C) = Cross(A,B-C) // 化简得Cross(p[u+1]-p[u], p[v+1]-p[v]) &lt;= 0 int diff = Cross(p[u+1]-p[u], p[v+1]-p[v]); if(diff &lt;= 0) &#123; ans = max(ans, Dist2(p[u], p[v])); // u和v是对踵点 if(diff == 0) ans = max(ans, Dist2(p[u], p[v+1])); // diff == 0时u和v+1也是对踵点 break; &#125; v = (v + 1) % n; &#125; &#125; return ans;&#125;//两凸包最近距离double RC_Distance(Point *ch1, Point *ch2, int n, int m)&#123; int q=0, p=0; //REP(i, n) for(int i=1;i&lt;=n;i++) if(ch1[i].y-ch1[p].y &lt; -eps) p=i; //REP(i, m) for(int i=1;i&lt;=m;i++) if(ch2[i].y-ch2[q].y &gt; eps) q=i; ch1[n]=ch1[0]; ch2[m]=ch2[0]; double tmp, ans=1e100; //REP(i, n) for(int i=1;i&lt;=n;i++) &#123; while((tmp = Cross(ch1[p+1]-ch1[p], ch2[q+1]-ch1[p]) - Cross(ch1[p+1]-ch1[p], ch2[q]- ch1[p])) &gt; eps) q=(q+1)%m; if(tmp &lt; -eps) ans = min(ans,DistanceToSegment(ch2[q],ch1[p],ch1[p+1])); else ans = min(ans,dis_pair_seg(ch1[p],ch1[p+1],ch2[q],ch2[q+1])); p=(p+1)%n; &#125; return ans;&#125;//两凸包最近距离//使用vectordouble RC_Distance(vector&lt;Point&gt; ch1, vector&lt;Point&gt; ch2)&#123; int q = 0, p = 0, n = ch1.size(), m = ch2.size(); //REP(i, n) for(int i=1;i&lt;=n;i++) if(ch1[i].y-ch1[p].y &lt; -eps) p=i; //REP(i, m) for(int i=1;i&lt;=m;i++) if(ch2[i].y-ch2[q].y &gt; eps) q=i; ch1.push_back(ch1[0]), ch2.push_back(ch2[0]); double tmp, ans=1e100; //REP(i, n) for(int i=1;i&lt;=n;i++) &#123; while((tmp = Cross(ch1[p+1]-ch1[p], ch2[q+1]-ch1[p]) - Cross(ch1[p+1]-ch1[p], ch2[q]- ch1[p])) &gt; eps) q=(q+1)%m; if(tmp &lt; -eps) ans = min(ans,DistanceToSegment(ch2[q],ch1[p],ch1[p+1])); else ans = min(ans,dis_pair_seg(ch1[p],ch1[p+1],ch2[q],ch2[q+1])); p=(p+1)%n; &#125; return ans;&#125;//凸包最大内接三角形double RC_Triangle(Point* res,int n)&#123; if(n &lt; 3) return 0; double ans = 0, tmp; res[n] = res[0]; int j, k; //REP(i, n) for(int i=1;i&lt;=n;i++) &#123; j = (i+1)%n; k = (j+1)%n; while((j != k) &amp;&amp; (k != i)) &#123; while(Cross(res[j] - res[i], res[k+1] - res[i]) &gt; Cross(res[j] - res[i], res[k] - res[i])) k= (k+1)%n; tmp = Cross(res[j] - res[i], res[k] - res[i]); if(tmp &gt; ans) ans = tmp; j = (j+1)%n; &#125; &#125; return ans;&#125;//凸包最大内接三角形double RC_Triangle(vector&lt;Point&gt; res, Point&amp; a, Point&amp; b, Point&amp; c)&#123; int n = res.size(); if(n &lt; 3) return 0; double ans=0, tmp; res.push_back(res[0]); int j, k; //REP(i, n) for(int i=1;i&lt;=n;i++) &#123; j = (i+1)%n; k = (j+1)%n; while((j != k) &amp;&amp; (k != i)) &#123; while(Cross(res[j] - res[i], res[k+1] - res[i]) &gt; Cross(res[j] - res[i], res[k] - res[i])) k= (k+1)%n; tmp = Cross(res[j] - res[i], res[k] - res[i]); if(tmp &gt; ans) &#123; a = res[i], b = res[j], c = res[k]; ans = tmp; &#125; j = (j+1)%n; &#125; &#125; return ans;&#125;//判断两凸包是否有交点bool ConvexPolygonDisjoint(const vector&lt;Point&gt; ch1, const vector&lt;Point&gt; ch2)&#123; int c1 = ch1.size(); int c2 = ch2.size(); for(int i = 0; i &lt; c1; i++) if(isPointInPolygon(ch1[i], ch2) != 0) return false; // 内部或边界上 for(int i = 0; i &lt; c2; i++) if(isPointInPolygon(ch2[i], ch1) != 0) return false; // 内部或边界上 for(int i = 0; i &lt; c1; i++) for(int j = 0; j &lt; c2; j++) if(SegmentProperIntersection(ch1[i], ch1[(i+1)%c1], ch2[j], ch2[(j+1)%c2])) return false; return true;&#125;inline double dist(Point a, Point b)&#123; return Length(a - b);&#125;////模拟退火求费马点 保存在ptres中//double fermat_point(Point *pt, int n, Point&amp; ptres)//&#123;// Point u, v;// double step = 0.0, curlen, explen, minlen;// int i, j, k;// bool flag;// u.x = u.y = v.x = v.y = 0.0;// //REP(i, n)// for(int i=1;i&lt;=n;i++)// &#123;// step += fabs(pt[i].x) + fabs(pt[i].y);// u.x += pt[i].x;// u.y += pt[i].y;// &#125;// u.x /= n;// u.y /= n;// flag = 0;// while(step &gt; eps)// &#123;// for(k = 0; k &lt; 10; step /= 2, ++k)// for(i = -1; i &lt;= 1; ++i)// for(j = -1; j &lt;= 1; ++j)// &#123;// v.x = u.x + step*i;// v.y = u.y + step*j;// curlen = explen = 0.0;// //REP(i, n)// for(int i=1;i&lt;=n;i++)// &#123;// curlen += dist(u, pt[idx]);// explen += dist(v, pt[idx]);// &#125;// if(curlen &gt; explen)// &#123;// u = v;// minlen = explen;// flag = 1;// &#125;// &#125;// &#125;// ptres = u;// return flag ? minlen : curlen;//&#125;//多边形费马点//到所有顶点的距离和最小Point Fermat(int np, Point* p)&#123; double nowx = 0, nowy = 0; double nextx = 0, nexty = 0; //REP(i, np) for(int i=1;i&lt;=np;i++) &#123; nowx += p[i].x; nowy += p[i].y; &#125; for (nowx /= np, nowy /= np;; nowx = nextx, nowy = nexty) &#123; double topx = 0, topy = 0, bot = 0; //REP(i, np) for(int i=1;i&lt;=np;i++) &#123; double d = msqrt(msqrt(nowx - p[i].x) + msqrt(nowy - p[i].y)); topx += p[i].x / d; topy += p[i].y / d; bot += 1 / d; &#125; nextx = topx / bot; nexty = topy / bot; if (dcmp(nextx - nowx) == 0 &amp;&amp; dcmp(nexty - nowy) == 0) break; &#125; Point fp; fp.x = nowx; fp.y = nowy; return fp;&#125;//最近点对//使用前先对输入的point进行排序,使用cmpxy函数Point point[N];int tmpt[N];inline double dist(int x, int y)&#123; Point&amp; a = point[x]; Point&amp; b = point[y]; return msqrt(msqrt(a.x - b.x) + msqrt(a.y - b.y));&#125;inline bool cmpxy(Point a, Point b)&#123; if(a.x != b.x) return a.x &lt; b.x; return a.y &lt; b.y;&#125;inline bool cmpy(int a, int b)&#123; return point[a].y &lt; point[b].y;&#125;double Closest_Pair(int left, int right)&#123; double d = INF; if(left==right) return d; if(left + 1 == right) return dist(left, right); int mid = (left+right)&gt;&gt;1; double d1 = Closest_Pair(left,mid); double d2 = Closest_Pair(mid+1,right); d = min(d1,d2); int k=0; //分离出宽度为d的区间 //FE(i, left, right) for(int i=left;i&lt;=right;i++) &#123; if(fabs(point[mid].x-point[i].x) &lt;= d) tmpt[k++] = i; &#125; sort(tmpt,tmpt+k,cmpy); //线性扫描 //REP(i, k) for(int i=0;i&lt;k;i++) &#123; for(int j = i+1; j &lt; k &amp;&amp; point[tmpt[j]].y-point[tmpt[i]].y&lt;d; j++) &#123; double d3 = dist(tmpt[i],tmpt[j]); if(d &gt; d3) d = d3; &#125; &#125; return d;&#125;/************圆************/struct Circle&#123; Point c; double r; Circle() &#123;&#125; Circle(Point c, double r):c(c), r(r) &#123;&#125; inline Point point(double a) //根据圆心角求点坐标 &#123; return Point(c.x+cos(a)*r, c.y+sin(a)*r); &#125; inline void read() &#123; scanf("%lf%lf%lf", &amp;c.x, &amp;c.y, &amp;r); &#125;&#125;;//求a点到b点(逆时针)在的圆上的圆弧长度double DisOnCircle(Point a, Point b, Circle C) ///已验证&#123; double ang1 = angle(a - C.c); double ang2 = angle(b - C.c); if (ang2 &lt; ang1) ang2 += 2 * PI; return C.r * (ang2 - ang1);&#125;//直线与圆交点 返回个数int LineCircle(Point p1,Point p2,Circle c ,vector&lt;Point&gt;&amp; p) &#123; /// 已验证 Point m = GetLineProjection(c.c, p1, p2); double h2 = Length2(c.c-m); int fg = dcmp(c.r*c.r-h2); double len = Length(p2-p1); if(!fg)&#123; p.push_back(m); return 1; &#125;else if(fg&gt;0) &#123; double rate = msqrt(c.r*c.r-h2)/len; p.push_back(m-(p2-p1)*rate); p.push_back(m+(p2-p1)*rate); return 2; &#125;else return 0;&#125;//两圆交点 返回个数int getCircleCircleIntersection(Circle C1, Circle C2, vector&lt;Point&gt;&amp; sol) &#123; ///已验证 double d = Length(C1.c - C2.c); if(dcmp(d) == 0) &#123; if(dcmp(C1.r - C2.r) == 0) return -1; // 重合，无穷多交点 return 0; &#125; if(dcmp(C1.r + C2.r - d) &lt; 0) return 0; if(dcmp(fabs(C1.r-C2.r) - d) &gt; 0) return 0; double a = angle(C2.c - C1.c); double da = acos((C1.r*C1.r + d*d - C2.r*C2.r) / (2*C1.r*d)); Point p1 = C1.point(a-da), p2 = C1.point(a+da); sol.push_back(p1); if(p1 == p2) return 1; sol.push_back(p2); return 2;&#125;//两圆的公切线, -1表示无穷条切线//返回切线的条数, -1表示无穷条切线//a[i]和b[i]分别是第i条切线在圆A和圆B上的切点int getTangents(Circle A, Circle B, Point* a, Point* b) ///已验证&#123; int cnt = 0; if (A.r &lt; B.r) swap(A, B), swap(a, b); ///**************************** long long d2 = (A.c.x - B.c.x) * (A.c.x - B.c.x) + (A.c.y - B.c.y) * (A.c.y - B.c.y); long long rdiff = A.r - B.r; long long rsum = A.r + B.r; if (d2 &lt; rdiff * rdiff) return 0; //内含 ///*************************************** double base = atan2(B.c.y - A.c.y, B.c.x - A.c.x); if (d2 == 0 &amp;&amp; A.r == B.r) return -1; //无线多条切线 if (d2 == rdiff * rdiff) //内切, 1条切线 &#123; ///********************** a[cnt] = A.point(base); b[cnt] = B.point(base); cnt++; return 1; &#125; //有外公切线 double ang = acos((A.r - B.r) / msqrt(d2 * 1.0)); a[cnt] = A.point(base + ang); b[cnt] = B.point(base + ang); cnt++; a[cnt] = A.point(base - ang); b[cnt] = B.point(base - ang); cnt++; if (d2 == rsum * rsum) //一条内公切线 &#123; a[cnt] = A.point(base); b[cnt] = B.point(PI + base); cnt++; &#125; else if (d2 &gt; rsum * rsum) //两条内公切线 &#123; double ang = acos((A.r + B.r) / msqrt(d2 * 1.0)); a[cnt] = A.point(base + ang); b[cnt] = B.point(PI + base + ang); cnt++; a[cnt] = A.point(base - ang); b[cnt] = B.point(PI + base - ang); cnt++; &#125; return cnt;&#125;// 过点p到圆C的切线。v[i]是第i条切线的向量。返回切线条数int getTangents(Point p,Circle c,vector&lt;Point&gt;&amp; v) &#123;//存入的向量 Vector u = c.c - p; double dist = Length(u); if(dist &lt; c.r) return 0; else if(dcmp(dist - c.r) == 0)&#123; // p在圆上，只有一条切线 v.push_back(Rotate(u, PI/2)); return 1; &#125;else&#123; double ang = asin(c.r / dist); v.push_back(Rotate(u, -ang)); v.push_back(Rotate(u, ang)); return 2; &#125;&#125;// 过点p到圆C的切点int getTangentPoints(Point p, Circle C, vector&lt;Point&gt;&amp; v) /// 已验证&#123; Vector u = C.c - p; double dist = Length(u); if(dist &lt; C.r) return 0; else if(dcmp(dist - C.r) == 0) // p在圆上，只有一条切线 &#123; v.push_back(p); return 1; &#125; else &#123; double ang = asin(C.r / dist); double d = msqrt(dist * dist - C.r * C.r); v.push_back(p + Unit(Rotate(u, -ang)) * d); v.push_back(p + Unit(Rotate(u, +ang)) * d); return 2; &#125;&#125;//圆A与圆B的切点void getTangentPoints(Circle A, Circle B, vector&lt;Point&gt;&amp; a)&#123; if (A.r &lt; B.r) swap(A, B); ///**************************** long long d2 = msqrt(A.c.x - B.c.x) + msqrt(A.c.y - B.c.y); long long rdiff = A.r - B.r, rsum = A.r + B.r; if (d2 &lt; rdiff * rdiff) return; //内含 ///*************************************** double base = atan2(B.c.y - A.c.y, B.c.x - A.c.x); if (d2 == 0 &amp;&amp; A.r == B.r) return; //无线多条切线 if (d2 == rdiff * rdiff) //内切, 1条切线 &#123; ///********************** a.push_back(A.point(base)); a.push_back(B.point(base)); return; &#125; //有外公切线 double ang = acos((A.r - B.r) / msqrt(d2 * 1.0)); a.push_back(A.point(base + ang)); a.push_back(B.point(base + ang)); a.push_back(A.point(base - ang)); a.push_back(B.point(base - ang)); if (d2 == rsum * rsum) //一条内公切线 &#123; a.push_back(A.point(base)); a.push_back(B.point(PI + base)); &#125; else if (d2 &gt; rsum * rsum) //两条内公切线 &#123; double ang = acos((A.r + B.r) / msqrt(d2 * 1.0)); a.push_back(A.point(base + ang)); a.push_back(B.point(PI + base + ang)); a.push_back(A.point(base - ang)); a.push_back(B.point(PI + base - ang)); &#125;&#125;//三角形外接圆Circle CircumscribedCircle(Point p1, Point p2, Point p3) /// 已验证&#123; double Bx = p2.x-p1.x, By = p2.y-p1.y; double Cx = p3.x-p1.x, Cy = p3.y-p1.y; double D = 2*(Bx*Cy-By*Cx); double cx = (Cy*(Bx*Bx+By*By) - By*(Cx*Cx+Cy*Cy))/D + p1.x; double cy = (Bx*(Cx*Cx+Cy*Cy) - Cx*(Bx*Bx+By*By))/D + p1.y; Point p = Point(cx, cy); return Circle(p, Length(p1-p));&#125;//三角形内切圆Circle InscribedCircle(Point p1, Point p2, Point p3) /// 已验证&#123; double a = Length(p2-p3); double b = Length(p3-p1); double c = Length(p1-p2); Point p = (p1*a+p2*b+p3*c)/(a+b+c); return Circle(p, DistanceToLine(p, p1, p2));&#125;//半径为r 与a b两直线相切的圆心vector&lt;Point&gt; CircleTangentToLinesGivenRadius(Line a, Line b, double r)&#123; vector&lt;Point&gt; ans; Line L1 = a.move(-r), L2 = a.move(r); Line L3 = b.move(-r), L4 = b.move(r); ans.push_back(GetLineIntersection(L1, L3)); ans.push_back(GetLineIntersection(L1, L4)); ans.push_back(GetLineIntersection(L2, L3)); ans.push_back(GetLineIntersection(L2, L4)); return ans;&#125;//与两圆相切 半径为r的所有圆心vector&lt;Point&gt; CircleTangentToTwoDisjointCirclesWithRadius(Circle c1, Circle c2, double r)&#123; vector&lt;Point&gt; ans; Vector v = c2.c - c1.c; double dist = Length(v); int d = dcmp(dist - c1.r -c2.r - r*2); if(d &gt; 0) return ans; getCircleCircleIntersection(Circle(c1.c, c1.r+r), Circle(c2.c, c2.r+r), ans); return ans;&#125;//多边形与圆相交面积Point GetIntersection(Line a, Line b) //线段交点&#123; Vector u = a.p-b.p; double t = Cross(b.v, u) / Cross(a.v, b.v); return a.p + a.v*t;&#125;inline bool InCircle(Point x, Circle c)&#123; return dcmp(c.r - Length(c.c - x)) &gt;= 0;&#125;inline bool OnCircle(Point x, Circle c)&#123; return dcmp(c.r - Length(c.c - x)) == 0;&#125;//线段与圆的交点int getSegCircleIntersection(Line L, Circle C, Point* sol)&#123; Vector nor = Normal(L.v); Line pl = Line(C.c, nor); Point ip = GetIntersection(pl, L); double dis = Length(ip - C.c); if (dcmp(dis - C.r) &gt; 0) return 0; Point dxy = Unit(L.v) * msqrt(msqrt(C.r) - msqrt(dis)); int ret = 0; sol[ret] = ip + dxy; if (OnSegment(sol[ret], L.p, L.point(1))) ret++; sol[ret] = ip - dxy; if (OnSegment(sol[ret], L.p, L.point(1))) ret++; return ret;&#125;//线段切割圆double SegCircleArea(Circle C, Point a, Point b)&#123; double a1 = angle(a - C.c); double a2 = angle(b - C.c); double da = fabs(a1 - a2); if (da &gt; PI) da = PI * 2.0 - da; return dcmp(Cross(b - C.c, a - C.c)) * da * msqrt(C.r) / 2.0;&#125;//多边形与圆相交面积double PolyCiclrArea(Circle C, Point *p, int n)&#123; double ret = 0.0; Point sol[2]; p[n] = p[0]; //REP(i, n) for(int i=1;i&lt;=n;i++) &#123; //double t1, t2; int cnt = getSegCircleIntersection(Line(p[i], p[i+1]-p[i]), C, sol); if (cnt == 0) &#123; if (!InCircle(p[i], C) || !InCircle(p[i+1], C)) ret += SegCircleArea(C, p[i], p[i+1]); else ret += Cross(p[i+1] - C.c, p[i] - C.c) / 2.0; &#125; if (cnt == 1) &#123; if (InCircle(p[i], C) &amp;&amp; !InCircle(p[i+1], C)) ret += Cross(sol[0] - C.c, p[i] - C.c) / 2.0, ret += SegCircleArea(C, sol[0], p[i+1]); else ret += SegCircleArea(C, p[i], sol[0]), ret += Cross(p[i+1] - C.c, sol[0] - C.c) / 2.0; &#125; if (cnt == 2) &#123; if ((p[i] &lt; p[i + 1]) ^ (sol[0] &lt; sol[1])) swap(sol[0], sol[1]); ret += SegCircleArea(C, p[i], sol[0]); ret += Cross(sol[1] - C.c, sol[0] - C.c) / 2.0; ret += SegCircleArea(C, sol[1], p[i+1]); &#125; &#125; return fabs(ret);&#125;double area(vector&lt;Point&gt;p) //计算凸包的面积&#123; double ans = 0; int sz = p.size(); for (int i = 1; i &lt; sz - 1; i++) ans += Cross(p[i] - p[0], p[i + 1] - p[0]); return ans / 2.0;&#125;double seg(Point o, Point a, Point b)&#123; if (dcmp(b.x - a.x) == 0) return (o.y - a.y) / (b.y - a.y); return (o.x - a.x) / (b.x - a.x);&#125;vector&lt;Point&gt; pp[110];pair&lt;double, int&gt; s[2200];double polyunion(vector&lt;Point&gt;*p, int n)//求n个多凸包的面积交&#123; double ret = 0; for (int i = 0; i &lt; n; i++) &#123; int sz = p[i].size(); for (int j = 0; j &lt; sz; j++) &#123; int m = 0; s[m++] = mp(0, 0); s[m++] = mp(1, 0); Point a = p[i][j], b = p[i][(j + 1) % sz]; for (int k = 0; k &lt; n; k++) &#123; if (i != k) &#123; int siz = p[k].size(); for (int ii = 0; ii &lt; siz; ii++) &#123; Point c = p[k][ii], d = p[k][(ii + 1) % siz]; int c1 = dcmp(Cross(b - a, c - a)); int c2 = dcmp(Cross(b - a, d - a)); if (c1 == 0 &amp;&amp; c2 == 0) &#123; if (dcmp(Dot(b - a, d - c)) &gt; 0 &amp;&amp; i &gt; k) &#123; s[m++] = mp(seg(c, a, b), 1); s[m++] = mp(seg(d, a, b), -1); &#125; &#125; else &#123; double s1 = Cross(d - c, a - c); double s2 = Cross(d - c, b - c); if (c1 &gt;= 0 &amp;&amp; c2 &lt; 0) s[m++] = mp(s1 / (s1 - s2), 1); else if (c1 &lt; 0 &amp;&amp; c2 &gt;= 0) s[m++] = mp(s1 / (s1 - s2), -1); &#125; &#125; &#125; &#125; sort(s, s + m); double pre = min(max(s[0].first, 0.0), 1.0), now; double sum = 0; int cov = s[0].second; for (int j = 1; j &lt; m; j++) &#123; now = min(max(s[j].first, 0.0), 1.0); if (!cov) sum += now - pre; cov += s[j].second; pre = now; &#125; ret += Cross(a, b)*sum; &#125; &#125; return ret / 2;&#125;int main()&#123; return 0;&#125; 其他 输出保留c位小数点 1printf("%.*f\n", c, (double)a/b); 平方和公式$1^2+2^2+3^2+…+n^2 = n(n+1)(2n+1)/6$ $2^2+4^2+6^2+…+(2n)^2=2n(n+1)(2n+1)/3$ 立方和公式$1^3+2^3+3^3+…+n^3=（n(n+1)/2)^2$ 等差数列求和公式$S_n=n(a_1+a_n)/2$ 等比数列求和公式:$S_n=a_1(1-q^n)/(1-q)$ 组合数性质 $C_n^0+C_n^1+…+C_n^n=2^n$ 错排公式：$D(1)=0,D(2)=1;D(n)=(n-1)[D(n-2)+D(n-1)]$ 斐波那契数列通项公式 \frac{1}{\sqrt{5}}[(\frac{1+\sqrt{5}}{2})^n-(\frac{1-\sqrt{5}}{2})^n](n>=1) 等价类划分 $S_0=1,S_n=C(n-1,0)*S_{n-1}+C(n-1,1)*S_{n-2}+…+C(n-1,n-1)*S_0$ 阶乘逼近函数 n!=\sqrt{2\pi n}(\frac{n}{e})^ne^{\frac{1}{12n}-\frac{\ln(9n)}{(9n)^{\pi}-(9n)^{-\pi}}} 三角形面积 $S = \frac{1}{2}absin(\theta )$ $p = \frac{1}{2}(a+b+c),S=\sqrt{p(p-a)(p-b)(p-c)}$ 基姆拉尔森公式 12345678910int m[15]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;if( (year%4==0&amp;&amp;year%100!=0) || year%400==0 ) m[2]=29; //闰年else m[2]=28; //平年int larson(int year,int month,int day)&#123; if(month == 1 || month == 2)&#123; year -= 1; month += 12; &#125; return (day+2*month+3*(month+1)/5+year+(year/4)-(year/100)+(year/400)+1)%7;&#125; 两矩形相交部分(a,c) - (b,d) 12345int a,b,c,d;a=max(min(x1,x2),min(x3,x4));b=min(max(x1,x2),max(x3,x4));c=max(min(y1,y2),min(y3,y4));d=min(max(y1,y2),max(y3,y4)); 浮点数判断大小 123int sgn(double a)&#123; return a &lt; -eps ? -1 : a &lt; eps ? 0 : 1;&#125; 勾股数 当a为大于1的奇数2n+1时，b=2n²+2n, c=2n²+2n+1 当a为大于4的偶数2n时，b=n²-1, c=n²+1 希尔伯特曲线坐标与编号相互转换 123456789101112131415161718192021222324252627282930313233343536void rot(int n, int* x, int* y, int rx, int ry)&#123; if (ry == 0)&#123; if (rx == 1)&#123; *x = n - 1 - *x; *y = n - 1 - *y; &#125; int t = *x; *x = *y; *y = t; &#125;&#125;//convert (x,y) to d // 1&lt;&lt;k==n,x,y从0开始,注意方向ll xy2d(int n, int x, int y)&#123; int rx, ry, s; ll d = 0; for (s = n / 2; s &gt; 0; s /= 2)&#123; rx = (x &amp; s) &gt; 0; ry = (y &amp; s) &gt; 0; d += s * s * ((3 * rx) ^ ry); rot(n, &amp;x, &amp;y, rx, ry); &#125; return d;&#125;//convert d to (x,y)void d2xy(int n, int d, int* x, int* y)&#123; int rx, ry, s, t = d; *x = *y = 0; for (s = 1; s &lt; n; s *= 2)&#123; rx = 1 &amp; (t / 2); ry = 1 &amp; (t ^ rx); rot(s, x, y, rx, ry); *x += s * rx; *y += s * ry; t /= 4; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARM嵌入式系统 学习笔记]]></title>
    <url>%2FARM%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[[TOC] 第1章 嵌入式系统概述 嵌入式系统定义：嵌入到对象体系中的专用计算机应用系统。 应用举例：手机、MP3、打印机、DV等。 嵌入式系统 分类 ①嵌入式微处理器（EMPU，基础是CPU，应用于专门设计的电路板上，满足嵌入式应用的特殊要求，在其工作温度、抗电磁干扰、可靠性等方面做了增强） ②微控制器（MCU，整个计算机系统集成到一块芯片中，适用于控制） ③DSP处理器（DSP，应用目标是大批量的消费类产品） ④片上系统（SOC，分通用和专用，专用芯片可用于互联网安全方面） 特点：嵌入性、专用性、计算机 嵌入式处理器：为了完成特殊的应用而设计的特殊目的处理器。 嵌入式最小系统：提供嵌入式处理器运行所必须的条件的电路与嵌入式处理器共同组成的系统。 嵌入式系统基本概念： 实时操作系统（RTOS）：一段在嵌入式系统启动后首先执行的背景程序，用户的应用程序是运行于RTOS之上的各个任务，RTOS根据各个任务的要求，进行资源管理、消息管理、任务调度及异常处理等工作。 资源：程序运行时可使用的软、硬件环境。 共享资源：被一个以上任务使用的资源。 任务：一个线程。 任务切换：保存当前运行任务的工作状态并入栈，把下一个要运行任务的当前状态从栈中装回CPU寄存器并开始运行。 内核：负责管理各个任务，提供任务切换的基本服务。 非占先式内核：中断后回到中断了的任务。 占先式内核：中断后让进入就绪态优先级最高的开始运行。 任务优先级：表示任务被调度的优先程度。 中断：一种硬件机制，用于通知CPU有个异步事件发生了。 常见嵌入式实时操作系统 μClinux：开源 Windows CE：开放 VxWorks：实时性卓越 μC/OS - ΙΙ：开源、抢占式 第2章 ARM7体系结构 ARM简介 ARM公司是一家知识产权(IP)供应商，它与一般的半导体公司最大的不同就是不制造芯片且不向终端用户出售芯片，而是通过转让设计方案，由合作伙伴生产出各具特色的芯片。 ARM架构是ARM公司面向市场设计的第一款低成本RISC微处理器。 ARM7后缀含义： 带M：64位乘法指令 带D：支持片上调试 带T：高密度16位Thumb指令集扩展 带I：Embedded ICE硬件仿真功能模块 ARM处理器使用冯·诺依曼结构，指令数据共用一条32位总线；直接支持8位字节(2^32)，16位半字(2^31)或者32位字(2^30)的数据类型。 如果一个数据是以字方式存储的，那么它就是字对齐的，否则就是非字对齐的；特征：bit0=bit1=0,其他任意。 如果一个数据是以半字方式存储的，那么它就是半字对齐的，否则就是非半字对齐的；特征：bit0=0,其他任意。 流水线 三级：①取指：从存储器装载一条指令 ②译码：识别将要执行的指令 ③执行：处理指令并将结果写回寄存器 ARM处理器状态 ARM指令集为32位长度，效率高，代码密度低，都是有条件执行，具有最完整的功能；Thumb指令集为16位长度，代码密度较高，只有一条具备有条件执行，能实现ARM指令集的大部分功能。在功能上可以认为Thumb是ARM的子集。 当前程序状态寄存器CPSR中的控制位T反映处理器正在操作的状态，T=0，处理器处于ARM状态，T=1，处理器处于Thumb状态。 从一个ARM例程调用另一个Thumb例程时，内核必须切换状态，反之亦然。BX分支将ARM内核的操作状态在ARM和Thumb之间进行切换。 &nbsp;&nbsp;&nbsp;&nbsp;7. ARM处理器模式 除了用户模式以外，其余所有6种模式称之为非用户模式 特权模式中除去系统模式外的5种模式称之为异常模式 用户(usr)、系统(sys)、管理(svc)、中止(abt)、未定义(und)、中断(irq)、快速中断(fiq) &nbsp;&nbsp;&nbsp;&nbsp;8. ARM内部寄存器 ARM处理器内部共有37个用户可访问的32位寄存器，其中有6个32位状态寄存器目前只使用了其中12位；31个通用寄存器+6个状态寄存器(1个CPSR+5个SPSR)；不可同时访问，对其访问取决于处理器状态和处理器模式。 堆栈指针R13(SP)，保存堆栈的出入口地址、待使用寄存器内容 链接寄存器R14(LR)，保存子程序和子程序的返回地址 程序计数器R15(PC)，总是指向“正在取指”的指令 所有模式共享一个程序状态寄存器CPSR，ARM通过此寄存器监视和控制内部操作的。SPSR为异常模式中保存CPSR当前值的备份程序寄存器。 程序状态寄存器格式 N Z C V … I F T M4 M3 M2 M1 M0 负 0 进位 溢出 保留 irq禁止 fiq禁止 状态位 模式位 . . . . &nbsp;&nbsp;&nbsp;&nbsp;9. 模式控制位 M[4:0] 模式 10000 用户 10001 快速中断 10010 中断 10011 管理 10111 中止 11011 未定义 11111 系统 &nbsp;&nbsp;&nbsp;&nbsp;10. 异常向量表 地址 异常 模式 0x0000 0000 复位 管理 0x0000 0004 未定义指令 未定义 0x0000 0008 软件中断 管理 0x0000 000C 中止（预取） 中止 0x0000 0010 中止（数据） 中止 0x0000 0014 保留 保留 0x0000 0018 IRQ 中断 0x0000 001C FIQ 快速中断 &nbsp;&nbsp;&nbsp;&nbsp;11. 中断优先级 优先级 异常 1 复位 2 数据中止 3 FIQ 4 IRQ 5 预取指中止 6 未定义指令 6 软件中断SWI &nbsp;&nbsp;&nbsp;&nbsp;12. ARM体系的储存系统 &nbsp;&nbsp;&nbsp;&nbsp;位于地址A的字包含的字节位于A、A+1、A+2、A+3； 小端格式：一个字中的最低地址被看作是最低位字节，最高地址的字节被看作是最高位字节，储存器系统字节0连接到数据线7~0； 大端格式：一个字中的最高位字节保存在最低地址，最低位字节保存在最高位地址，储存器系统字节0连接到数据线31~24； 第3章 ARM7TDMI（-S）指令系统 ARM处理器寻址方式 寄存器寻址： 寄存器编号 MOV R1,R2 ；将R2的值存入R1 SUB R0,R1,R2；将R1的值减R2的值结果存入R0 立即寻址： 操作数 SUBS R0,R0,#1；R0-1存入R0 MOV R0,#0xFF000；将立即数0xFF000装入R0 寄存器移位寻址： ASR(1-32)、LSL(1-31)、LSR(1-32)、ROR(1-31)、RRX(1) MOV R0,R2,LSL #3 ；R2的值左移3位结果存入R0 ANDS R1,R1,R2,LSL R3 ；R2的值左移R3位，结果与R1相与后存入R1 寄存器间接寻址： [] LDR R1,[R2] ；将R2指向的储存单元的数据读出存入R1 //加载字数据 SWP R1,R1,[R2]；将R2指向的储存单元的数据与R1的值交换 基址寻址 STR R1,[R0,#-4]！；将R1的值存入R0-4指定的储存单元 //存储字数据 多寄存器寻址：！，{ } LDMIA R1!,{R2-R7,R12}；将R1指向的单元中的数据读出到R2-R7,R12中，R1++；//多寄存器加载 STMIA R0!,{R2-R7,R12}；将R2-R7,R12的值保存到R0指向的存储单元中，R0++; //多寄存器存储 堆栈寻址 满堆栈：指向最后压入栈的有效数据项，向移动指针再写数据； 空堆栈：指向下一个待压入数据的空位置，先写入数据在移动指针； X递增：增大地址向上增长；X递减：减小地址向下增长。 相对寻址 程序计数器PC提供基准地址，地址码字段作为偏移量 第4章 LPC2000系列ARM硬件结构 为存储器分配地址的过程称为存储器映射；但为了增加系统的灵活性，系统中有部分存储单元（主要包括引导块(Boot Block)和用于保存向量表的少量存储单元）可以同时出现在不同地址上，则称为存储器重映射。 存储器重映射并不是对映射单元的内容进行了复制，只是将多个地址指向了同一个存储单元，通过“存储器管理部件”实现。即一个物理地址对应多个逻辑地址。 Boot Block是芯片设计厂家在LPC2000系列ARM内部固化的一段代码，用户无法对其修改或删除。这段代码在芯片复位后被首先运行，其功能主要是判断运行哪个存储器上的程序，检查用户代码是否有效，判断芯片是否被加密，芯片的在应用编程(IAP)以及在系统编程功能(ISP)。 系统启动代码(Boot Loader)：大部分由汇编指令构成，可以实现向量表定义、堆栈初始化、系统变量初始化、中断系统初始化、I/O初始化、外围初始化、地址重映射等操作。启动顺序：Boot Block-&gt;Boot Loader-&gt;操作系统 时钟系统概述：时钟是计算机系统的脉搏，处理器核在一拍接一拍的时钟驱动下完成指令执行、状态变换等动作。外设部件在时钟的驱动下进行着各种工作，比如串口数据的收发、A/D转换、定时器计数等。因此时钟对于一个计算机系统是至关重要的，通常时钟系统出现问题也是最致命的，比如振荡器不起振、振荡不稳、停振等。组成：晶体振荡器、唤醒定时器、锁相环（PLL）和VPB分频器。 晶体振荡器的两个模式：使用外部时钟源时，称为“从属模式”；使用外部晶体时，称为“振荡模式”。 LPC2000系列ARM两个复位源： 外部复位：通过把芯片的$\overline{RESET}$引脚拉为低电平使芯片复位。$\overline{RESET}$引脚为施密特触发输入引脚，带有一个额外的干扰滤波器，可以滤除非常短促的脉冲信号，使处理器不会被干扰脉冲意外复位，或者被不稳定的复位信号复位多次。 $\overline{RESET}$需要保持一段时间的低电平，必须在晶振稳定运行之后才能撤除。 在系统编程(ISP)：是一种非常实用的片内Flash烧写方式。ISP工作时，通过UART0使用约定协议与计算机上的ISP软件进行通信，并按用户的操作要求，调用内部的IAP代码实现各种功能。 看门狗复位：内置看门狗部件，可以利用此部件来复位处理器。 锁相环PLL 作用：将振荡器产生的时钟频率$F_{OSC}$进行升频。 LPC2000系列ARM是基于ARM7内核的，该内核的工作频率基本在100Mhz以下，所以LPC2000系列ARM大部分支持最高60MHz的内核时钟，少部分支持70MHz的内核时钟。 PLL频率计算：$F_{OSC}$经流控振荡器CCO得到$F_{CCO}$，$F_{CCO}$经过2P分频后得$F_{CCLK}=F_{CCO}/(2*P)$，$F_{CCO}/(2*P)$经M分频后得到$F_{CCO}/(2*P*M) = F_{OSC}$ PLL设置 参考链接 $F_{CCO}$取值必须在156～320MHz内 M取值1-32，将M-1放在PLLCFG[4:0] P取值1,2,4,8，将$log_2P$放在PLLCFG[6:5] PLLCON寄存器:包涵使能连接PLL的位,也就是控制PLL是否进行连接,这个连接需要在向PLLFEED发送正确的信息(馈送序列)的时候才生效,否则及时将使能位置位,PLL也不会连接到电路中。PLLCON必须在PLL开始连接之前就设置好,否则会造成系统不可预知的错误,先设置1后设置3。 PLLSTAT寄存器:从里面可以读出PLLCON,PLLCFG的值,但必须是在PLLFEED的馈送序列被发送,PLLCON,PLLCFG生效以后才可以读到正确的值(while(PLLSTAT &amp; (1&lt;&lt;10) == 0) ;) PLLFEED寄存器:向此寄存器以连续的VPB总线周期写入0xaa,0x55,即馈送序列，在正确的序列被写入PLLFEED之后,PLLCON,PLLCFG才生效,PLL电路才能正确的连接到电路中 12345678PLLCON = 1;PLLCFG = (M-1)|（log2(P)&lt;&lt;5）;PLLFEED = 0xaa;PLLFEED = 0x55;while(PLLSTAT &amp; (1&lt;&lt;10) == 0);PLLCON = 3;PLLFEED = 0xaa;PLLFEED = 0x55; &nbsp;&nbsp;9. VPB分频器 作用：将$F_{CCLK}$分频，方便外设工作、降低系统功耗 &nbsp;&nbsp;10. 两种节电模式： 空闲模式：处理器停止执行指令，使功耗最低降至1～2mA电流 掉电模式：振荡器关闭，芯片没有任何内部时钟，功耗降低到几乎为零 &nbsp;&nbsp;11. bank0~bank3的片选信号分别是CS0~CS3。 &nbsp;&nbsp;12. 外部存储器接口 LPC2200的外部存储器宽度可设定为8位，16位和32位 宽度为8位时，有效数据线D7~D0，只有BLS0有效 宽度为16位时，有效数据线D15~D0，BLS0、BLS1都有效 操作16位存储器时，需将LPC2200的地址线A1连接到存储器地址A0处 &nbsp;&nbsp;13. PSRAM读写数据 写入16位 123456789int main(void)&#123; uint16 *point16; uint16 data16 = 0x00; point16 = (uint16 *)0x80001020; while(1)&#123; *point16 = data16++; //循环向地址0x80001020处写入数据 &#125; return 0;&#125; 写入低8位 123456789int main(void)&#123; uint8 *point8; uint8 data8 = 0x00; point8 = (uint8 *)0x80001010; while(1)&#123; *point8 = data8++;//循环向地址0x80001010处写入数据 &#125; return 0;&#125; 写入高8位 123456789int main(void)&#123; uint8 *point8; uint8 data8 = 0x00; point8 = (uint8 *)0x80001011; while(1)&#123; *point8 = data8++;//循环向地址0x80001011处写入数据 &#125; return 0;&#125; 读取8位 1234567891011121314uint8 RcvDate8;int main(void)&#123; uint8 *point8; point8 = (uint*)0x80001010; while(1)&#123; RcvDate8 = *point8++;//读取0x80001010处的数据 RcvDate8 = *point8++;//读取0x80001011处的数据 RcvDate8 = *point8++;//读取0x80001012处的数据 RcvDate8 = *point8--;//读取0x80001013处的数据 point8--; point8--; &#125; return 0;&#125; &nbsp;&nbsp;14. ARM的大部分引脚都具有多种功能，即引脚复用。但是一个引脚在同一时刻只能使用其中一个功能，通过配置相关寄存器控制多路开关与片内外设。 &nbsp;&nbsp;15. GPIO的特性 可以独立控制每个GPIO口的方向（输入/输出模式） 可以独立设置每个GPIO口的输出状态（高/低电平） 所有GPIO口在复位后默认为输入状态 &nbsp;&nbsp;16. GPIO应用示例 ​ 设置P0.0为输出高电平 123PINSEL0 &amp;= 0xFFFFFFFC; //设置引脚连接模块，将P0.0设置为GPIO功能IO0DIR |= 0x00000001; //将P0.0设置为输出IOSET = 0x00000001; //设置P0.0输出高电平 使用GPIO控制蜂鸣器 123456789101112#define BEEPCON 0x00000080 //P0.7控制B1，低电平蜂鸣int main(void)&#123; PINSEL0 = 0x00000000; //设置引脚连接GPIO IO0DIR = BEEPCON; //设置I/O为输出 while(1)&#123; IO0SET = BEEPCON; //BEEPCON=1 Delay(10); IO0CLR = BEEPCON; //BEEPCON=0 Delay(10); &#125; reuturn 0;&#125; 读取P0.0引脚的电平状态 1234uint32 PinStat; //定义存放I/O状态的变量PINSEL0 &amp;= 0xFFFFFFFC; //设置引脚连接模块，将P0.0设置为GPIO功能IO0DIR &amp;= 0xFFFFFFFE; //将P0.0设置为输入PinStat = IO0PIN&amp;0x01; //通过IP0PIN寄存器获取P0.0当前电平状态 读取按键状态 12345678910111213#define BEEPCON 0x00000080#define PIN_P014 0x00004000 //定义P0.14屏蔽字int main(void)&#123; uint32 i; PINSEL0 = 0x00000000; //设置引脚连接GPIO IO0DIR = BEEPCON; //设置B1控制口为输出，其他I/O为输入 while(1)&#123; if((IO0DIR&amp;PIN_P014)!=0) IO0SET = BEEPCON; else IO0CLR = BEEPCON; Delay(10); &#125; return 0;&#125; 在多个I/O口线上输出数据 12345#define DataBus 0xFFPINSEL0 &amp;= 0xFFFF0000；//设置引脚连接模块，将P0.0~P0.7设置为GPIO功能IO0DIR |= DataBus; //将所有I/O口设置为输出IO0CLR = DataBus; //将所有I/O口设置为低电平输出IO0SET = Data; //将输出的数据从I/O口输出 &nbsp;&nbsp;17. 中断分类 快速中断请求（FIQ）：优先级最高 向量IRQ：中等优先级，16个优先级，每个中断源分别设置服务程序入口 非向量IRQ：优先级最低，支持一个非向量中断，所有中断共用一个服务程序入口 &nbsp;&nbsp;18. VIC可以管理32路中断请求。 &nbsp;&nbsp;19. 中断触发方式 边沿触发：上升沿触发、下降沿触发 电平触发：高电平触发、低电平触发 &nbsp;&nbsp;20. 外部中断应用示例 EINT0低电平中断初始化 12345678PINSEL1 = (PINSEL1&amp;0xFFFFFFFC)|0x01; //选择P0.16为EINT0EXTMODE = EXTMODE&amp;0x0E; //电平触发EXTPOLAR = EXTPOLAR&amp;0x0E; //低电平中断/*设置向量中断控制器*/VICIntSelect = VICIntSelect&amp;(~(1&lt;&lt;14)); //EINT0分配为IRQ中断VICVectCntl0 = 0x20|14; //EINT分配为向量IRQ通道0VICVectAddr0 = (uint32)EINT0_ISR; //向量IRQ通道0的中断服务程序地址为EINT0_ISRVICIntEnable = (1&lt;&lt;14); //EINT0中断使能 EINT0下降沿中断初始化 123PINSEL1 = (PINSEL1&amp;0xFFFFFFFC)|0x01;EXTMODE = EXTMODE|0x01;EXTPOLAR = EXTPOLAR&amp;0x0E; &nbsp;&nbsp;21. SPI总线系统是一种同步串行外设接口，允许MCU与各种外围设备一串行方式进行通信、数据交换。 &nbsp;&nbsp;22. $I^2C$BUS是NXP半导体公司推出的芯片间串行传输总线，它以2根连线实现了完善的双向数据传送，可以极方便的构成多机系统和外围器件拓展系统。 &nbsp;&nbsp;23. LPC2000系列ARM7微控制器包含有2个符合16C550工业标准的异步串行口（UART）：UART0和UART1。其中UART0只提供TXD（发送）和RXD（接受）信号引脚，而UART1增加了一个调制解调器（Modem）接口。 &nbsp;&nbsp;24. UART应用示例 UART0初始化 12345678910#define UART_BPS 115200void UART0_Ini(void)&#123; uint16 Fdiv; U0LCR = 0x83; //DLAB=1,可设置波特率 Fdiv = (Fpclk/16)/UART_BPS; //设置波特率 U0DLM = Fdiv/256; //除数锁存高位寄存器 U0DLL = Fdiv%256; //除数锁存低位寄存器 U0LCR = 0x03;&#125; UART0查询方式接受数据 123456uint8 UART0_RcvByte(void)&#123; uint8 rcv_data; while((U0LSR&amp;0x01)==0); //状态 rcv_data = U0RBR; //接受缓存 return rcv_data;&#125; UART0中断方式接受数据 12345678910111213141516171819void __irq UART_Exception(void)&#123; ... switch(U0IIR&amp;0x0f)&#123; case 0x04: //发生RDA中断 //从接受FIFO中读取数据 break; case 0x0c: //发生字符超时中断——CTI while((U0LSR&amp;0x01)==1)&#123; //如果接受FIFO中含有的有效数据，就读取UnRBR寄存器 RcvData[i++]=U0RBR; &#125; break; ... default: break; &#125; VICVectAddr = 0;&#125; &nbsp;&nbsp;25. 看门狗 带内部预分频器的可编程32位定时器]]></content>
      <categories>
        <category>嵌入式系统</category>
      </categories>
      <tags>
        <tag>嵌入式系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法设计与分析 学习笔记]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[第一章 算法概述算法的定义：是对特定问题求解步骤的一种描述，包含操作的有限规则和操作的有限序列 算法的性质：确定性（指令无歧义）、有限性（无死循环）、输入、输出 程序的定义：是算法用某种程序设计语言的具体实现 程序和算法的区别：程序不一定满足有限性，比如操作系统 算法复杂性决定于：(1)求解问题的规模；(2)具体的输入数据；(3)算法本身的设计 O(1)&lt;O(logn)&lt;O(n)&lt;O($n^c$)&lt;O($c^n$)&lt;O(n!) 如果存在正的常数c和自然数n0，使得n&gt;=n0时有f(n)&lt;=cg(n)，则称f(n)当n充分大时有上界，且g(n)是它的一个上界，记为f(n)=O(g(n))，还说f(n)的阶不高于f(n)的阶。 求上下界函数： \lim_{n\rightarrow\infty} \frac{f(n)}{g(n)} = \begin{cases}0, & \text{f(n)=O(g(n))}\\\infty, & \text{f(n)= $\Omega$(g(n))}\\c,& \text{f(n)=$\Theta$(g(n))} \end{cases}第二章 递归与分治一般递归方程时间复杂度分析 T(n)1} \end{cases}其中，a是子问题的个数，b是递减的步长，|表示递减方式，D(n)是合成子问题的开销 当|为减法： T(n)1}\\ O(n),&\text{a=1} \end{cases}当|为除法： $p=log_ba$ ①D(n)为常数 T(n)1}\\ O(log_bn),&\text{a=1} \end{cases}②D(n)为线性函数cn T(n)]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>算法设计与分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物联网概论 学习笔记]]></title>
    <url>%2F%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%AE%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[物联网（IoT）：Internet of Things 物联网是具有自我标示、感知和智能的物理实体基于通信技术相互连接形成的网络，这些物理设备可以在无需人工干预的条件下实现协同和互动，为人们提供智慧和集约的服务，传感网是物联网的基础，是物联网的组成部分 物联网三层体系结构：感知层、网络层和应用层 感知层是物联网的皮肤和五官——识别物体，采集信息； 网络层是物联网的神经中枢和大脑——信息传递和处理； 应用层是物联网的“社会分工”——与行业需求结合，实现广泛智能化 RFID全称：Radio Frequency Identification 射频识别 RFID系统的基本组成： ①硬件组成：RFID标签、识读器、天线和主机 ②软件组成：RFID系统软件、中间件和应用软件 RFID系统结构通过空中接口将电子标签与读写器连接 RFID系统的原理： ①耦合(Coupling)：根据需求和成本可利用电磁波和磁感应 ②磁耦合 ③电磁波耦合(反向散射原理) RFID频段分布 低频：125.124KHz 恶劣环境下使用 高频：13.56MHz 门禁卡、公交卡等 （ISO/IEC 14443标准 非接触集成电路接近卡） 超高频：433.92Mhz / 868-960Mhz 微波：2.45GHz 一般传感器的定义：测量装置、输入与输出有对应关系、有一定的精确度 一般传感器的组成： ①敏感元件：直接感受被测量、并输出与被测量成确定关系的某一物理量的元件 ②转换元件：敏感元件的输出就是它的输入，将感受到的非电量直接转换为电量的元件 ③测量电路：将转换元件输出的电量变换为便于显示、记录、控制、处理的有用电信号 传感器的静态特性： ①线性度：指其输出量与输入量之间的实际关系曲线(即静态特征曲线)偏离直线的程度，又称为非线性误差 ②灵敏度：指传感器在稳态下的输出变化量△y与引起变化的输入变化△x之比 ③迟滞：传感器在正(输入量增大)和反(输入量减小)行程期间，其输出-输入特性曲线不重合的现象 ④重复性：在输入按同一方向连续多次变动时得到特性曲线不一致的程度 ⑤分辨率：在测量方向内所能测量输入量的最小变化量△x ⑥漂移：在外界的干扰下，输出量发生与输入量无关的变化 应变效应：金属导体或者半导体在受外力作用时，会产生相应的应变，其阻值也随之发生变化 。 应变片式传感器——电桥 ①直流电桥（单臂电桥、惠斯通电桥）：$K_{u} = U/4$ ②半差动电桥(双臂电桥)：$K_{u} = U/2$ ③全桥电路（全臂电桥）：$K_{u} = U$ 变磁阻式(自感)传感器： 电感：在电路中电流发生变化时能产生电动势的性质成为电感，分为自感和互感 自感：当线圈中有电流通过时，线圈的周围就会产生磁场。当线圈中电流发生变化时，其周围的磁场也产生相应的变化，此变化的磁场可使线圈自身产生感应电动势。 互感：两个电感线圈相互靠近时，一个电感线圈的磁场变化将影响另一个电感线圈，这种影响就是互感。互感的大小取决于电感线圈的自感与两个电感线圈耦合的程度 。 应用范畴：微位移 分类： 变气隙式 &nbsp;&nbsp;工作原理：气隙厚度的改变，使得磁路中磁阻值变化，从而导致电路电感值变化 变截面式 螺管式 电容式传感器：$c_0 = \frac{\epsilon_0\epsilon_rS}{d_0}$ 分类：①变极距型②变面积型③变介质型（油箱测油位） 应用：手机指纹识别 ps:实验箱指纹识别模块使用的是光电式传感器 磁电式传感器-霍尔传感器 霍尔效应：置于磁场中的静止载流导体, 当它的电流方向与磁场方向不一致时, 载流导体上垂直于电流和磁场方向产生电动势。该电势称霍尔电势。 霍尔电势与控制电流和磁感应强度成正比 霍尔电势的灵敏度与霍尔常数RH正比而与霍尔片厚度成反比 应用：微位移、测转速(汽车轮胎)、测电流、计数、开关等 压电式传感器 压电效应：某些电介质,当沿着一定方向对其施力而使它变形时,其内部就产生极化现象,同时在它的两个表面上便产生符号相反的电荷,当外力去掉后,其又重新恢复到不带电状态。 Z为光轴，X为电轴，Y为机械轴 压电效应称为纵向压电效应，沿Y方向产生的为横向压电效应，沿Z轴不产生 侧压力时线性度不好，需要在力传递系统中加入预加力，称预载 光电式传感器 光电效应：光的频率越高，其光子能量就越大。当具有一定能量的光子作用到某些物体上转化为该物体中一些电子的能量而产生电效应。 分类： 外光电效应（光线照到某些物体上造成表面电子逸出的现象） 光电导效应、光生伏特效应(内光电效应) （物体受光照后，内部原子释放出电子不能逸出表面，使物体电阻率发生变化或产生光电动势的现象） 光电倍增管：对光电流放大以提高灵敏度,阳极最后收集到的电子数是阴极发射的$10^5～10^6$倍 应用：亮度传感器、烟雾报警器、光电鼠标等 无线传感器 定义：是大量的静止或移动的传感器以自组织和多跳的方式构成的无线网络，目的是协作地采集、处理、传输网络覆盖地域内感知对象的检测信息，并报告用户。 传感器节点 -&gt; 汇聚节点 -&gt; 管理节点 网络节点组成：传感模块—计算模块—通信模块——存储模块 无线传感网：WSN(Wireless sensor network) 电池供电，能量有限（耗能排序：发送&gt;接受&gt;空闲&gt;睡眠 短距离通讯（距离增加一倍，功耗增加三倍 节点生命周期 自适应网络 路由的性质： 路由策略分析：最大PA、最小能量消耗、最少跳转、最大最小PA节点 定向扩散路由：①兴趣扩散（洪泛方式）②梯度建立③加强路径 GPSR绕过路由空洞的步骤： 构造全网连接平面图 通过删边处理，变成可平面图（GG、RNG算法 通过右手法则，绕过路由空洞（每经过一个面，顺时针到的第一条边 MAC协议： 分类：时分复用无竞争接入方式(分配型）、随机竞争接入方式（竞争型）、竞争与固定分配相结合的接入方式（混合型） S-MAC协议： 优点： 周期性的侦听/睡眠的低占空比方式 虚拟簇的调度方式 自适应流量的侦听机制：通信结束继续侦听一段时间 串音避免：RTS/CTS/DATA/ACK 缺点：延迟受限于帧长度，不适合实时业务 分配性MAC协议： “隐藏终端”（Hidden Stations）：在通信领域，基站A向基站B发送信息，基站C未侦测到A也向B发送，故A和C同时将信号发送至B，引起信号冲突，最终导致发送至B的信号都丢失了。 暴露终端是指在发送节点的覆盖范围内而在接收节点的覆盖范围外的节点，暴露终端因听到发送节点的发送而可能延迟发送。但是，它其实是在接收节点的通信范围之外，它的发送不会造成冲突。这就引入了不必要的延时。 ZigBee 功能节点：协调者（COORDINATOR）、路由器（ROUTER）、终端设备（END DEVICE） 协调者（老大）功能：发送网络信标、建立一个PAN、管理网络节点、存储网络节点信息、寻找节点对路由信息 路由器功能：允许其它设备加入网络、跳跃路由、辅助子设备供电 终端设备功能：传感节点的载体、轻载化程序设计 网络拓扑结构：星型、网型、树形 模式：非信标模式（CSMA/CA）、信标模式（竞争和分配的混合性信道接入） CSMA/CA方式下通过三个参数的调节来实现冲突避免：退避次数（NB)、竞争窗口长度（CW)、退避指数（BE） 信标、超帧及其结构： 超帧包含活动部分和非活动部分，超帧以一个信标的开始为开始，信标定义超帧结构 CAP为自由竞争阶段、CFP为非竞争阶段、CFP内可以保证GTS（保证时隙）的传送 信标是子设备同步父设备的标记 耗能：传感模块的功耗远高于射频模块的功耗，这是因为传感模块大多采用模拟电路进行感测，需要一直恒定的加载电流。]]></content>
      <categories>
        <category>物联网概论</category>
      </categories>
      <tags>
        <tag>物联网概论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率论与数理统计 学习笔记]]></title>
    <url>%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[第一章 随机事件及其概率第一节 随机事件及其频率、概率的统计定义随机事件(偶然事件)：在试验的结果中，可能发生、也可能不发生的事件 随机事件的频率具有一定的稳定性 随机事件的概率为频率的近似值 $P(A) \approx f(A) = \frac{m}{n}$ 必然事件 P(U)=1；不可能事件 P(V)=0 第二节 样本空间样本点：随机试验的每一个可能出现的且是最简单的不可再分的结果 样本空间：所有的样本点构成的集合（分为可列个和不可列个(如误差范围)） 任一随机事件A都是样本空间Ω的一个子集 第三节 事件的关系及运算包含/包含于：$A \subset B$ 和(并)：$A∪B$ 积(交)：$A∩B 或 AB$ 互不相容(互斥)：两个互不相容事件的和 $A+B$ 对立(逆)：$\overline{A}=B$ 完备事件组：n个事件至少有一个事件一定发生 A发生但B不发生：$A-B=A\overline{B}=A-AB$ 运算性质：交换律、结合律、分配律、德摩根律（$\overline{A∪B}=\overline{A}&ensp;\overline{B},\overline{AB}=\overline{A}∪\overline{B}$） 第四节 概率的古典定义乘法定理：完成一件事需r步，第i步有$ m_ i $种方法，完成这件事总方法数 $ m_ 1m_ 2…m_ r $ 加法定理：完成一件事有r类方法，第i类有$ m_ i $种方法，完成这件事总方法数 $ m_ 1+m_ 2+…+m_ r $ 排列：$ A _ n ^m = \frac{n!}{(n-m)!} $ 组合：$ C _ n ^m = \frac{A _ n ^m}{P_ m} = \frac{n!}{(n-m)!m!}$ 概率的古典定义：试验样本总共有$ n_Ω$ 个等可能的基本事件，其中随机事件A包含$ n_A$个基本事件，($ n_A$&lt;=$ n_Ω$)，则 $P(A) = \frac{n_A}{n_Ω}$ 不放回依次抽样与一次抽样的一致性、抽签次序无关性 第五节 概率加法定理若随机事件A与B互斥，即$AB = \emptyset，则P(A+B)= P(A)+P(B) \Rightarrow P(A)+P(\overline{A})=1$ 若A、B是任意的两个随机事件，则二者和事件的概率为 $P(A∪B)=P(A)+P(B)-P(AB)$ $\Rightarrow P(A∪B∪C)=P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC) $ 第六节 条件概率与乘法定理已知事件A发生的条件下，事件B发生的概率：$P(B|A)=\frac{P(AB)}{P(A)}$ 若$P(A_1A_2…A_{n-1})&gt;0,则 P(A_1A_2…A_{n})=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1A_2…A_n-1)$ 第七节 全概率公式与贝叶斯公式&ensp;&ensp;先验，由因溯果 P(A) = \sum_{i=1}^nP(B_i)P(A|B_i) &ensp;&ensp;后验，由果溯因 P(B_i|A) = \frac{P(AB_i)}{P(A)} = \frac{P(B_i)P(A|B_i)}{\sum_{i=1}^nP(B_i)P(A|B_i)},i=1,2,...,n第八节 随机事件的独立性若两事件A与B满足$P(AB) = P(A)P(B)$，则称事件A与B相互独立 &ensp;&ensp;性质1：不可能事件及必然事件与任意的随机事件相互独立 &ensp;&ensp;性质2：A与B相互独立，则A与$\overline{B},\overline{A}与B,\overline{A}与\overline{B}$也相互独立&ensp;&ensp;（相互对称性） 第九节 贝努力概型事件A恰好发生k次的概率：$P_n(k) = C_n^kp^kq^{n-k},k=0,1,2,…,n$ $\sum_{k=0}^nP_n(k) = \sum_{k=0}^nC_n^kp^kq^{n-k} = (p+q)^n = 1$ 事件A发生次数介于$m_1$与$m_2$之间：$P_n(m_1 \leq k \leq m_2) = \sum_{k=m1}^{m2}P_n(k)$ 事件A至少发生r次：$P(k \geq r) = \sum_{k=r}^nP_n(k) = 1 - \sum_{k=0}^{r-1}P_n(k)$ 第十节 概率论的公理化体系非负性：P(A) $\leq$ 0; 规范性：P(Ω)=1; 可列可加性(可数可加性)：$A_1,A_2,…$ 两两互不相容，则$P(\sum_{i=1}^\infty A_i) = \sum_{i=1}^\infty P(A_i)$ 第二章 随机变量及其分布第一节 随机变量的概念设Ω为随机变量的样本空间，如果对每一个样本点$\omega \in Ω$，均有唯一确定的实数X($\omega$)与之对应，即存在一个定义于Ω的单值实函数X=X($\omega$)，则称X=X($\omega$)为样本空间Ω上的随机变量 第二节 离散型随机变量的概率分布性质： ①$p_k \geq 0 (k=1,2,..) $ ②$\sum_{k=1}^{\infty}p_k = 1$ 第三节 几种常用的离散型随机变量的分布 0-1分布：$P(X=1) = p，P(X=0) = q（0&lt;p&lt;1，p+q=1）$ 超几何分布：$P(X=m) = \frac{C_M^mC_{N-M}^{n-m}}{C_N^n} （n \leq N,M \leq N），记作X～H(n,M,N)$，N趋向无穷大时近似服从二项分布 二项分布：$P(X=k) = C_n^kp^kq^{n-k} （k=0,1,2,…,n） ，记作X ～B(n,p)$ ，n很大，p很小时，可用泊松分布近似替代二项分布 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;二项式分布的最可能取值( P(X=k)取得最大值的k )： &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;①若(n+1)p不是整数，则其整数部分[(n+1)p]即为所求； &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;②若(n+1)p=m是整数，则m和m-1即为所求 泊松分布：$P(X=k) = P_{\lambda}(k) = \frac{\lambda^k}{k!}e^{-\lambda} （k=0,1,2,…），记作X～P(\lambda)$ 几何分布：$P(X=k)=q^{k-1}p（k=1,2,…）， 记作X～G(p)$ 第四节 随机变量的分布函数$F(x) = P(X \leq x)$ 性质： $F(x) 单调不减，若x_1&lt;x_2,则F(x_1) \leq F(x_2)$ 对于任意x，P(x)=F(x)-F(x-0),即当前值-左极限值 $P(x_1&lt;X \leq x_2) = F(x_2)-F(x_1)$离散型随机变量只能用 $P(x_1 \leq X \leq x_2) =P(x_1&lt;X \leq x_2)=P(x_1 \leq X&lt;x_2)=P(x_1&lt;X&lt;x_2) =F(x_2)-F(x_1)$连续性随机变量都适用 离散型随机变量的F(x)含跳跃间断点；连续性随机变量F(x)连续且位于y=0与y=1之间 第五节 连续性随机变量的概率密度 分布函数F(x)与概率密度函数f(x)的关系： $f(x) = F^{′}(x) $ $F(x)=\int_{-\infty}^xf(t)dt$ 性质： $因为F(-\infty)=0,F(+\infty)=1,所以有\int_{-\infty}^{+\infty}f(x)dx = 1$ $P(x_1&lt;X \leq x_2)=F(x_2)-F(x_1)=\int_{x_1}^{x_2}f(x)dx$ 第六节 几种常用的连续随机变量的分布均匀分布 X~U(a,b) f(x)=\begin{cases} \frac{1}{b-a},&\text{a]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>概率论与数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛-41]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-41.html</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/contest/373#question A 翻硬币问题 题意：A和B玩游戏，A先手，要将n个正面硬币翻转为反面且每次只能翻转m个，B有一次可以在A翻转后将一枚硬币翻转的机会，给出n,m问A是否能将所有硬币翻转 思路： 简单签到题，容易想到： ​ 当n&lt;m时，A翻不了 ​ 当n==m时，A可以一下就翻完 ​ 当n&gt;m时，无论A是否刚好翻完，B都可以打乱 代码： 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); if(n==m) puts("Yes"); else puts("No"); &#125; return 0;&#125; B 666RGP 题意：给出n个数(n&lt;=300,-666&lt;=ai&lt;=666)，分数开始初值为0，对于第i个数有两种操作，一是分数+a[i],二是分数*(-1)，问经过n个数后有多少种方法分数变为-666，且中间分数不能出现666，答案对1e8+7取模 思路：简单计数dp 设dp[i] [j]表示，经过第i个数后分数为j的答案，那么有dp[i] [j] = dp[i-1] [j - a[i]] + dp[i-1] [-j] 注意过滤掉j==666的情况 因为j最大会有2*300*666 这么大，如果开dp[300] [2*300*666] 肯定空间不够 考虑转移方程只和i 和 i-1有关，可以用滚动数组形式优化 代码： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxv = 700*300;const int P = 1e8+7;int dp[2][maxv*2];int a[305]; int main() &#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); dp[0][maxv]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=-666*n;j&lt;=666*n;j++)&#123; if(j==666) continue; dp[i&amp;1][j+maxv]=(dp[(i-1)&amp;1][-j+maxv]+dp[(i-1)&amp;1][j-a[i]+maxv])%P; &#125; &#125; printf("%d\n",dp[n&amp;1][-666+maxv]); return 0;&#125; C 抓捕盗窃犯 题意：在n点中，第i个点有ai个人，再给出下一时刻第i个点的所有人转移到vi点，问在m个地方建立哨卡（可以一直监控当地经过的人），最多可以监视到多少人 思路： n个点，每个点有一条有向出边 容易想到这些点将组成一些块 且每个块内都有一个环 这样，一个块的所有地点的人都会经过环 那么用并查集整合n个地点人口，再取前m大就行 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;int f[maxn];ll a[maxn],b[maxn]; int get(int x)&#123; return f[x]==x?x:f[x]=get(f[x]);&#125; int main() &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; f[i]=i; scanf("%lld",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; int to; scanf("%d",&amp;to); int x=get(i),y=get(to); if(x!=y)&#123; f[x]=y; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; int f=get(i); b[f]+=a[i]; &#125; sort(b+1,b+1+n); ll ans=0; for(int i=n;i&gt;n-m;i--)&#123; ans+=b[i]; &#125; printf("%lld\n",ans); return 0;&#125; D 最小相似度 题意：给出n个m长的二进制01串，问构造一个m长的01串使得这个串和这n个串对应位相同的数量最大的最小值 思路：将n个串都作为起点进行bfs，搜索完所有2^m内的数，dp[i]表示从某个起点到i需要翻转的位数，既有多少位与原先某个串不相同，m-max(dp[i]) 即为最小相同的位数 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn =3e5+5;int n,m;int dp[1&lt;&lt;20]; void bfs()&#123; queue&lt;int&gt;q; char s[25]; memset(dp,-1,sizeof(int)*((1&lt;&lt;m)+5)); for(int i=0;i&lt;n;i++)&#123; scanf("%s",s); int tmp=0; for(int j=0;j&lt;m;j++)&#123; tmp+=(1&lt;&lt;j)*(s[j]-'0'); &#125; dp[tmp]=0; q.push(tmp); &#125; while(!q.empty())&#123; int u=q.front(); q.pop(); for(int j=0;j&lt;m;j++)&#123; if(dp[u^(1&lt;&lt;j)]!=-1) continue; dp[u^(1&lt;&lt;j)]=dp[u]+1; q.push(u^(1&lt;&lt;j)); &#125; &#125;&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;m); bfs(); int ans=-1; for(int i=0;i&lt;(1&lt;&lt;m);i++) ans=max(ans,dp[i]); printf("%d\n",m-ans);&#125; E 球的体积并 题意：给出两个球的球心坐标和半径，求两球相交体积 思路：球冠体积公式(h为球冠高，r为球半径,d为球心距) V=PI*h(3a^2+h^2)/6=PI*h^2(3r-h)/3 h=r-(ra^2-rb^2+d^2)/2d注意外离、外切、内含的几种情况需特判 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const double PI = acos(-1);typedef struct point &#123; double x,y,z; point() &#123; &#125; point(double a, double b,double c) &#123; x = a; y = b; z = c; &#125; point operator -(const point &amp;b)const &#123; //返回减去后的新点 return point(x - b.x, y - b.y,z-b.z); &#125; point operator +(const point &amp;b)const &#123; //返回加上后的新点 return point(x + b.x, y + b.y,z+b.z); &#125; point operator *(const double &amp;k)const &#123; //返回相乘后的新点 return point(x * k, y * k,z*k); &#125; point operator /(const double &amp;k)const &#123; //返回相除后的新点 return point(x / k, y / k,z/k); &#125; double operator *(const point &amp;b)const &#123; //点乘 return x*b.x + y*b.y+z*b.z; &#125;&#125; point;double dist(point p1, point p2) &#123; //返回平面上两点距离 return sqrt((p1 - p2)*(p1 - p2));&#125;typedef struct sphere &#123;//球 double r; point centre; double v()&#123; return 4.0/3*PI*r*r*r; &#125;&#125; sphere;void Solve(sphere a, sphere b) &#123; double d = dist(a.centre, b.centre);//球心距 //double t = (d*d + a.r*a.r - b.r*b.r) / (2.0 * d);// //double h = sqrt((a.r*a.r) - (t*t)) * 2;//h1=h2，球冠的高 //double angle_a = 2 * acos((a.r*a.r + d*d - b.r*b.r) / (2.0 * a.r*d)); //余弦公式计算r1对应圆心角，弧度 //double angle_b = 2 * acos((b.r*b.r + d*d - a.r*a.r) / (2.0 * b.r*d)); //余弦公式计算r2对应圆心角，弧度 if(d-a.r-b.r&gt;=0)&#123; printf("%.10f\n",a.v()+b.v()); return; &#125; if(d+a.r&lt;b.r||d+b.r&lt;a.r)&#123; printf("%.10f\n",max(a.v(),b.v())); return; &#125; double l1 = (a.r*a.r - b.r*b.r + d*d) / (2*d); double l2 = (b.r*b.r - a.r*a.r + d*d) / (2*d); double h1 = a.r - l1, h2 = b.r - l2;//分别为两个球缺的高度 double v1 = PI*h1*h1*(a.r - h1 / 3);//相交部分r1圆所对应的球缺部分体积 double v2 = PI*h2*h2*(b.r - h2 / 3);//相交部分r2圆所对应的球缺部分体积 double v = v1 + v2;//相交部分体积 printf("%.10f\n",a.v()+b.v()-v); //double s1 = PI*a.r*x1; //r1对应球冠表面积 //double s2 = PI*a.r*x2; //r2对应球冠表面积 //double s = 4 * PI*(a.r*a.r + b.r*b.r) - s1 - s2;//剩余部分表面积&#125; int main() &#123; sphere a,b; scanf("%lf%lf%lf%lf",&amp;a.centre.x,&amp;a.centre.y,&amp;a.centre.z,&amp;a.r); scanf("%lf%lf%lf%lf",&amp;b.centre.x,&amp;b.centre.y,&amp;b.centre.z,&amp;b.r); Solve(a,b); return 0;&#125; F 简单数学题 数学弃… 岑巨出的题，难度适中，B题dp因为没注意要从dp[0] [maxv]开始初始化debug了很久 C题想到了并查集竟然不想写 E题内含的条件写错了，一直以为公式错了QAQ 还是大意了啊]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>dp</tag>
        <tag>bfs</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客OI周赛7-普及组]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2OI%E5%91%A8%E8%B5%9B7-%E6%99%AE%E5%8F%8A%E7%BB%84.html</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/contest/372#question A 救救猫咪 暴力 B 救救兔子 题意：给出n长数组，m个询问，每次询问给出一个x，要求数组中与x差距最小的数(如果差距相等，输出较小的那个) 思路： 二分，原数组排序后用upper_lowbound() 找出第一个比x大元素的位置，在分别比较当前位置和当前位置-1的数与x的差距，注意比第一个数小和最后一个数大的时候需特判 代码： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;int a[maxn]; int main()&#123; int n,q,x; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); sort(a,a+n); scanf("%d",&amp;q); while(q--)&#123; scanf("%d",&amp;x); if(x&gt;=a[n-1]) printf("%d\n",a[n-1]); else if(x&lt;=a[0]) printf("%d\n",a[0]); else&#123; int pos=upper_bound(a,a+n,x)-a; if(abs(a[pos-1]-x) &lt;= abs(a[pos]-x)) printf("%d\n",a[pos-1]); else printf("%d\n",a[pos]); &#125; &#125;&#125; C 救救企鹅 题意: 给出字符串s,a,b(长度&lt;=1e6),要求输出将s中所有a替换为b后的字符串 思路: kmp或hash求出s中与a匹配的位置,再替换一下即可 比赛的时候没有注意到a,b串的长度可以不相等 只过了50%qwq 赛后发现用Java或Python都可以直接秒这题tql 代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int maxn = 1e6+5;char s[maxn],a[maxn],b[maxn];int lens,lena,lenb;ull base=131;ull p[maxn],hs[maxn];ull geth(int l,int r)&#123; return (ull)hs[r]-hs[l-1]*p[r-l+1];&#125; vector&lt;int&gt;pos;int main()&#123; p[0]=1; for(int i=1;i&lt;maxn;i++) p[i]=p[i-1]*base; scanf("%s%s%s",s+1,a+1,b+1); lens=strlen(s+1); lena=lenb=strlen(a+1); ull tt=0; for(int i=1;i&lt;=lena;i++) tt=tt*base+(ull)a[i]; for(int i=1;i&lt;=lens;i++) hs[i]=hs[i-1]*base+(ull)s[i]; for(int i=1;i&lt;=lens-lena+1;i++)&#123; ull ss=geth(i,i+lena-1); if(ss==tt)&#123; pos.push_back(i); i+=lena-1; &#125; &#125; int k=1; for(int i=0;i&lt;pos.size();i++)&#123; while(k!=pos[i])&#123; putchar(s[k]); k++; &#125; printf("%s",b+1); k+=lena; &#125; while(k&lt;=lens)&#123; putchar(s[k]); k++; &#125; puts("");&#125; D 数糖纸 题意: 给出长度为n的数组(maxn=1e6),要求不含相同元素的最长连续区间长度 思路: 双指针(l,r)移动表示[l,r]内没有重复的元素,用个set记录当前区间已经出现了的数,如果枚举到一个没有出现的数,则加入set,++r,否则一直删除左端已经出现过的元素直到重复元素被删除 上面可以稍微优化一下,因为 Ai 最大1e9,我们先将原数组离散化,再用一个vis[] 记录Ai 是否出现过 代码1: 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;int a[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int ans=-1,l=1,r=1; set&lt;int&gt;s; while(r&lt;=n)&#123; if(s.find(a[r])==s.end())&#123; s.insert(a[r]); ans=max(ans,r-l+1); r++; &#125; else&#123; s.erase(a[l]); l++; &#125; &#125; printf("%d\n",ans);&#125; 代码2: 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;int a[maxn],b[maxn],pre[maxn],vis[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); b[i]=a[i]; &#125; sort(b+1,b+1+n); int m=unique(b+1,b+1+n)-b-1; for(int i=1;i&lt;=n;i++)&#123; a[i]=lower_bound(b+1,b+1+n,a[i])-b-1; &#125; int ans=-1,l=1; for(int i=1;i&lt;=n;i++)&#123; if(!vis[a[i]])&#123; vis[a[i]]=1; &#125; else&#123; while(a[l]!=a[i])&#123; vis[a[l]]=0; l++; &#125; l++; vis[a[i]]=1; &#125; ans=max(ans,i-l+1); &#125; printf("%d\n",ans);&#125; 一场比较简单的比赛,一点小粗心kmp就挂了 第一次在高铁上写博客,刺激~]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>二分</tag>
        <tag>字符串hash</tag>
        <tag>暴力</tag>
        <tag>kmp</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EOJ Monthly 2019.2]]></title>
    <url>%2FEOJ-Monthly-2019-2.html</url>
    <content type="text"><![CDATA[原题链接：https://acm.ecnu.edu.cn/contest/140/ A,B,C,E To be continue… D 进制转换 题意：求[l,r]中所有数的k进制末尾恰好有m个零的数有多少个 思路： x在k进制下末尾恰好有m个零说明x%(k^m)恒等于0，而x%(k^(m+1))不恒等于0，而x%(k^m)==0的情况包含了x%(k^(m+1))==0的情况，所以由容斥定理有[1,x]中满足题意的数有 x/(k^m) - x/(k^(m+1)) 个 代码： 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;ll calc(ll k,ll m,ll x)&#123; for(int i=1;i&lt;=m;i++)&#123; x/=k; &#125; return x;&#125;int main()&#123; ll l,r,k,m; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%lld%lld%lld%lld",&amp;l,&amp;r,&amp;k,&amp;m); printf("%lld\n",calc(k,m,r)-calc(k,m+1,r)-calc(k,m,l-1)+calc(k,m+1,l-1)); &#125;&#125; F 方差 题意： 在n个数中选m个数，使得这m个数的方差*(m^2)最小 思路： 首先想到要使方差越小，则要这m个数与平均数的差距越小，所以我们可以先排序再尺取m长; 不难发现将方差公式乘以m^2后可以化简得到 m(a_1^2+a_2^2+⋯+a_m^2) − (a_1+a_2+⋯+a_m)^2（MathJax真好用，小声哔哔 然后维护一个前缀和与一个前缀平方和即可 代码： 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;int a[maxn];ll sum1[maxn],sum2[maxn];int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; sort(a+1,a+1+n); for(int i=1;i&lt;=n;i++)&#123; sum1[i]=sum1[i-1]+a[i]; sum2[i]=sum2[i-1]+a[i]*a[i]; &#125; ll ans=-1; for(int i=m;i&lt;=n;i++)&#123; ll tmp=m*(sum2[i]-sum2[i-m])-(sum1[i]-sum1[i-m])*(sum1[i]-sum1[i-m]); if(ans==-1||ans&gt;tmp) ans=tmp; &#125; printf("%lld\n",ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客OI周赛7-提高组]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2OI%E5%91%A8%E8%B5%9B7-%E6%8F%90%E9%AB%98%E7%BB%84.html</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/contest/371#question A 小睿睿的等式 题意：有n根火柴棒，能摆成形如“A+B=n”的等式且使用的火柴棒数也恰好等于n/k的等式有多少种(B+A=n与A+B=n看作一种,“=”与“+”分别需要使用2根火柴棒,maxn=5e7) 思路：直接暴力拆分每组A+B写的挫会超时，比赛时没注意给出的空间很大(512MB)，先将所有5e7以内数所需火柴数打表即可 代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =5e7+5;int num[maxn];int main() &#123; num[0]=6; num[1]=2; num[2]=5; num[3]=5; num[4]=4; num[5]=5; num[6]=6; num[7]=3; num[8]=7; num[9]=6; int n; int k; scanf("%d%d",&amp;n,&amp;k); for(int i=10;i&lt;=n;i++)&#123; num[i]=num[i/10]+num[i%10]; &#125; int kk=n/k; int ans=0,x,y,z=num[n]; for(int a=0; a&lt;=n/2; a++) &#123; int b=n-a; x=num[a]; y=num[b]; if(x+y+z+4==kk) ans++; &#125; printf("%d\n",ans); return 0;&#125; B 小睿睿的询问 题意：给出随机生成一个n长数组的函数和生成区间查询L，R的函数，要求所有L，R区间生成数组中val[i]最大且较小下标异或值（maxn=1e5，maxm=5e7) 思路：最开始写的线段树（O(mlogn)），因为是随机数据没想到过了时间是全场最久的(4632/5000 ms),后来知道可以用ST表写，但自己写的挫，加了个二分查对应下标也用了2900+ms(O(nlognlogn))，再后来可以在ST表处直接用个pair，val[i]和i对应,每次查询O(1)，总体复杂度O(nlogn+m) 代码： 线段树版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =1e5+5;int n,m;int val[maxn],Max[maxn&lt;&lt;2],idx[maxn&lt;&lt;2]; void push_up(int l,int r,int o)&#123; Max[o]=max(Max[o&lt;&lt;1],Max[o&lt;&lt;1|1]); if(Max[o&lt;&lt;1] &gt;= Max[o&lt;&lt;1|1]) idx[o]=idx[o&lt;&lt;1]; else idx[o]=idx[o&lt;&lt;1|1];&#125; void build(int l,int r,int o)&#123; if(l==r)&#123; Max[o]=val[l]; idx[o]=l; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(l,r,o);&#125; int query(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return idx[o]; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid&amp;&amp;R&gt;mid)&#123; int i=query(L,R,lson); int j=query(L,R,rson); if(val[i]&gt;=val[j]) return i; else return j; &#125; else if(L&lt;=mid)&#123; return query(L,R,lson); &#125; else if(R&gt;mid)&#123; return query(L,R,rson); &#125; return 0;&#125; void generate_array(int n,int seed) &#123; unsigned x = seed; for (int i=1; i&lt;=n; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; val[i]=x%100; &#125;&#125; int lastans=0,ans=0;void generate_ask(int n,int m,int seedx,int seedy) &#123; unsigned x=seedx,y=seedy; for (int i=1; i&lt;=m; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; y ^= y &lt;&lt; 13; y ^= y &gt;&gt; 17; y ^= y &lt;&lt; 5; int L=(x^lastans)%n+1,R=(y^lastans)%n+1; if (L&gt;R) swap(L,R); lastans=query(L,R,1,n,1); ans^=lastans; &#125; printf("%d\n",ans);&#125; int main() &#123; int seed,seedx,seedy; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;seed,&amp;seedx,&amp;seedy); //double ss=clock(); generate_array(n,seed); build(1,n,1); generate_ask(n,m,seedx,seedy); //printf("%.0fms\n",clock()-ss); return 0;&#125; 二分+ST版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =1e5+5;int n,m;int val[maxn];vector&lt;int&gt;idx[105];int f[maxn][20];void ST_pre()&#123; for(int i=1;i&lt;=n;i++)&#123; f[i][0]=val[i]; &#125; int t=log(n)/log(2)+1; for(int j=1;j&lt;t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]); &#125; &#125;&#125;int ST_query(int l,int r)&#123; int k=log(r-l+1)/log(2); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125; void generate_array(int n,int seed) &#123; unsigned x = seed; for (int i=1; i&lt;=n; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; val[i]=x%100; idx[val[i]].push_back(i); &#125;&#125; int lastans=0,ans=0;void generate_ask(int n,int m,int seedx,int seedy) &#123; unsigned x=seedx,y=seedy; for (int i=1; i&lt;=m; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; y ^= y &lt;&lt; 13; y ^= y &gt;&gt; 17; y ^= y &lt;&lt; 5; int L=(x^lastans)%n+1,R=(y^lastans)%n+1; if (L&gt;R) swap(L,R); int pos,Max=ST_query(L,R); int s=lower_bound(idx[Max].begin(),idx[Max].end(),L)-idx[Max].begin(); for(int k=s;k&lt;=idx[Max].size();k++)&#123; if(idx[Max][k]&gt;=L&amp;&amp;idx[Max][k]&lt;=R)&#123; pos=idx[Max][k]; break; &#125; &#125; lastans=pos; ans^=lastans; &#125; printf("%d\n",ans);&#125; int main() &#123; int seed,seedx,seedy; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;seed,&amp;seedx,&amp;seedy); //double ss=clock(); generate_array(n,seed); ST_pre(); generate_ask(n,m,seedx,seedy); //printf("%.0fms\n",clock()-ss); return 0;&#125; 优化ST版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =1e5+5;int n,m;int val[maxn];pair&lt;int,int&gt; f[maxn][20]; void ST_pre()&#123; for(int i=1;i&lt;=n;i++)&#123; f[i][0].first=i; f[i][0].second=val[i]; &#125; int t=log(n)/log(2)+1; for(int j=1;j&lt;t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; //f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]); f[i][j] = f[i][j-1].second &gt;= f[i+(1&lt;&lt;j-1)][j-1].second ? f[i][j-1]:f[i+(1&lt;&lt;j-1)][j-1]; &#125; &#125;&#125;int ST_query(int l,int r)&#123; int k=log(r-l+1)/log(2); return f[l][k].second &gt;= f[r-(1&lt;&lt;k)+1][k].second ? f[l][k].first : f[r-(1&lt;&lt;k)+1][k].first;&#125; void generate_array(int n,int seed) &#123; unsigned x = seed; for (int i=1; i&lt;=n; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; val[i]=x%100; &#125;&#125; int lastans=0,ans=0;void generate_ask(int n,int m,int seedx,int seedy) &#123; unsigned x=seedx,y=seedy; for (int i=1; i&lt;=m; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; y ^= y &lt;&lt; 13; y ^= y &gt;&gt; 17; y ^= y &lt;&lt; 5; int L=(x^lastans)%n+1,R=(y^lastans)%n+1; if (L&gt;R) swap(L,R); int pos=ST_query(L,R); lastans=pos; ans^=lastans; &#125; printf("%d\n",ans);&#125; int main() &#123; int seed,seedx,seedy; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;seed,&amp;seedx,&amp;seedy); //double ss=clock(); generate_array(n,seed); ST_pre(); generate_ask(n,m,seedx,seedy); //printf("%.0fms\n",clock()-ss); return 0;&#125; C 小睿睿的方案 To be continue… 这场Rating赛打得还是还算比较开心吧，学了一下ST表空间复杂度O(nlogn),区间查询O(1)很不错的算法，程序运算时间的计算和数组所占大概空间的计算，虽然理论课学了但一直没去实践QWQ另外牛客题目还不错~不说了EOJ的题还没补呢！]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>OI</tag>
        <tag>ST</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛 40A--小D的剧场]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-40A--%E5%B0%8FD%E7%9A%84%E5%89%A7%E5%9C%BA.html</url>
    <content type="text"><![CDATA[题意： 给出自然数1-49的49个数要求拼接成长度为n的序列，且要求任意相邻的三个不能为给出q个条件中任意一个条件的全排列，求所有合法序列数对 1e9+7 取模。 原题链接：https://ac.nowcoder.com/acm/contest/369/A Input: 123456789101110 10 //n q18 3 343 28 2242 28 348 48 429 9 3147 9 221 22 4915 48 292 8 274 24 34 Output: 1382785822 思路： 设dp[i] [j] [k]为放到第i位时，a[i-1]=j, a[i]==k的状态，提前将不合法字段标记，转移方程： dp_{i,k,l} = \sum_{i=1}^{49} (!ban_{j,k,l})*dp_{i-1,j,k}表示j,k,l可行时，可在 a[i-2]==j,a[i-1]==k的状态转移到 a[i-1]==k,a[i]==l的状态。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int P = 1e9+7;int dp[505][50][50];bool ban[50][50][50];int main()&#123; int n,q; scanf("%d%d",&amp;n,&amp;q); while(q--)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ban[a][b][c]=ban[a][c][b]=true; ban[b][a][c]=ban[b][c][a]=true; ban[c][a][b]=ban[c][b][a]=true; &#125; for(int i=1;i&lt;=49;i++)&#123; for(int j=1;j&lt;=49;j++)&#123; dp[2][i][j]=1; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=49;j++)&#123; for(int k=1;k&lt;=49;k++)&#123; for(int l=1;l&lt;=49;l++)&#123; if(!ban[j][k][l])&#123; dp[i][k][l]=(dp[i][k][l]+dp[i-1][j][k])%P; &#125; &#125; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=49;i++)&#123; for(int j=1;j&lt;=49;j++)&#123; ans=(ans+dp[n][i][j])%P; &#125; &#125; printf("%d\n",ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛 40C--小A与欧拉路]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-40C--%E5%B0%8FA%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%B7%AF.html</url>
    <content type="text"><![CDATA[题意： 小A给你了一棵树，对于这棵树上的每一条边，你都可以将它复制任意（可以为0）次（即在这条边连接的两个点之间再加一条边权相同的边），求所有可能新形成的图中欧拉路的最短长度 欧拉路：从图中任意一个点开始到图中任意一个点结束的路径，并且图中每条边只通过恰好一次。 原题链接：https://ac.nowcoder.com/acm/contest/369/C Input： 12344 //n 树的点数1 2 1 //u v w1 3 11 4 2 Output： 15 思路： 先考虑回路的情况。由于是一棵树，任两点间路径只有一条，从一条边走到深度更大的点，一定还会从同一条边返回以回到起点或者遍历其他子树，所以每条边需要复制一次，此时答案是边权和的两倍。 不是回路的情况可以减掉从终点回到起点的路径，要让这条路径尽量长，所以长度一定是直径的长度。 答案就是边权和的两倍减去直径长度。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2e5+5;struct EDGE&#123; int next,w,to;&#125;edge[maxn*2];int head[maxn];int cnt; void add(int u,int v,int w)&#123; edge[++cnt].next=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125; int pos,ans;int d[maxn];void dfs(int x,int pre)&#123; for(int i=head[x];i;i=edge[i].next)&#123; int to=edge[i].to; if(to==pre) continue; d[to]=d[x]+edge[i].w; dfs(to,x); &#125; if(d[x]&gt;ans)&#123; ans=d[x]; pos=x; &#125;&#125; int main()&#123; int n; scanf("%d",&amp;n); ll sum=0; for(int i=0;i&lt;n-1;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); sum+=2*w; &#125; dfs(1,-1); memset(d,0,sizeof(d)); dfs(pos,-1); printf("%lld\n",sum-ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>欧拉路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSU 1803--2016]]></title>
    <url>%2FCSU%201803--2016.html</url>
    <content type="text"><![CDATA[题意： 求[l,r]之间有多少种a*b=2016的组合。 思路： 首先2016的1倍情况下有1*2016 , 2*1008 , 3*637… 等情况，2倍情况就是把a或b扩大2倍就行，那么我们可以把a看做[1,2016]的数，a’ 看做[2017,4032]的数，这样每次跨2016个数就知道有多少倍数了。最后两层for循环找出i*j==2016的时候把对应的倍数种类乘起来加到答案就行了。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; int main()&#123; ll n,m; ll a[3000],b[3000]; //a[i]储存n有多少个i*2016&lt;=n，b[i]....m while(~scanf("%lld%lld",&amp;n,&amp;m)) &#123; ll k=n/2016; //有k个2016跨度 ll mm=n%2016; //余下的等下都要+1 for(int i=1;i&lt;=mm;i++) a[i]=k+1; for(int i=mm+1;i&lt;=2016;i++) a[i]=k; k=m/2016; mm=m%2016; for(int i=1;i&lt;=mm;i++) b[i]=k+1; for(int i=mm+1;i&lt;=2016;i++) b[i]=k; ll ans=0; for(int i=1;i&lt;=2016;i++) &#123; for(int j=1;j&lt;=2016;j++) &#123; if((i*j)%2016==0) &#123; ans+=(a[i]*b[j]); &#125; &#125; &#125; printf("%lld\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 4011--Happy-Sequence]]></title>
    <url>%2FZOJ%204011--Happy-Sequence.html</url>
    <content type="text"><![CDATA[题意： 给一个n和m，求所有组成m长且值在1-n内且满足 a[i]%a[i-1]==0 的序列方案数。 思路： dp[i] [j] 表示长度为 i 的序列的最后一位为 j ,转移方程：dp[i] [j]=0 , dp[i] [j]+=dp[i-1] [ j的因子 ] 。因子可以通过埃氏筛打表得到，dp[m] [i]累加和即为答案，预处理2000*2000以内所有答案即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std; #define N 2005#define mod 1000000007int dp[N][N];vector&lt;int&gt;y[N]; //储存因子int main()&#123; for(int i=1; i&lt;=N; i++) &#123; for(int j=i; j&lt;=N; j+=i) &#123; y[j].push_back(i); &#125; &#125; for(int i=1; i&lt;=N; i++) dp[1][i]=1; for(int i=2; i&lt;=N; i++) &#123; for(int j=1; j&lt;=N; j++) &#123; for(int k=0; k&lt;y[j].size(); k++) &#123; dp[i][j]=(dp[i][j]+dp[i-1][y[j][k]])%mod; &#125; &#125; &#125; int t; scanf("%d",&amp;t); while(t--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); int ans=0; for(int i=1; i&lt;=n; i++) ans=(ans+dp[m][i])%mod; printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 2594--Driving-Straight]]></title>
    <url>%2FZOJ%202594--Driving-Straight.html</url>
    <content type="text"><![CDATA[题意： 给出一个(2*m-1)*(2*n-1)的图，要求输出从左下角走到右上角最短距离走法的路径，只能在 ‘-’ 或 ‘|’ 上移动，答案保证有解，有多解输出任一，n,m&lt;=400。 思路： 因为题目要求输出路径，而bfs中如果每个状态都记录到当前状态的路径，可能会TLE或者MLE。 所以考虑先从终点开始bfs出每个点到终点的最短距离，然后再从起点出发bfs一直找 当前点的最短距离-1==下一步的最短距离 的位置就可以回到终点，注意方向的变换。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;using namespace std;char mp[1005][1005];int dis[1005][1005];int m,n;int dx[10]=&#123;-1,0,1,0&#125;; //反向由北到西顺时针 依次为0123int dy[10]=&#123;0,1,0,-1&#125;;int dd[10][10] = &#123;&#123;0, 1, 2, 3&#125;, // F&#123;3, 0, 1, 2&#125;, // L&#123;1, 2, 3, 0&#125; // R&#125;;char dir[10]=&#123;'F','L','R'&#125;; struct node&#123; int x,y; node()&#123;&#125; node(int x,int y):x(x),y(y)&#123;&#125;&#125;; void bfs()&#123; queue&lt;node&gt;q; memset(dis,-1,sizeof(dis)); dis[1][2*n-1]=0; q.push(node(1,2*n-1)); node now; int x,y,px,py; while(!q.empty()) &#123; now=q.front(); q.pop(); px=now.x,py=now.y; //printf("%d %d\n",px,py); for(int i=0;i&lt;4;i++) &#123; x=px+dx[i]; y=py+dy[i]; if(mp[x][y]=='-' || mp[x][y]=='|') &#123; x+=dx[i]; y+=dy[i]; if(dis[x][y]==-1) &#123; dis[x][y]=dis[px][py]+1; q.push(node(x,y)); &#125; &#125; &#125; &#125;&#125; void print()&#123; int statu,x,y,px,py; if(mp[2*m-1][2]=='-' &amp;&amp; dis[2*m-1][1]-1==dis[2*m-1][3]) &#123; puts("E"); px=2*m-1,py=3; statu=1; &#125; else if(mp[2*m-2][1]=='|' &amp;&amp; dis[2*m-1][1]-1==dis[2*m-3][1]) &#123; puts("N"); px=2*m-3,py=1; statu=0; &#125; while(1) &#123; if(dis[px][py]==0) &#123; puts(""); break; &#125; for(int i=0;i&lt;3;i++) &#123; x=px+dx[dd[i][statu]]; y=py+dy[dd[i][statu]]; if(mp[x][y]=='-' || mp[x][y]=='|') &#123; x+=dx[dd[i][statu]]; y+=dy[dd[i][statu]]; if(dis[x][y]==dis[px][py]-1) &#123; printf("%c",dir[i]); statu=dd[i][statu]; px=x,py=y; break; &#125; &#125; &#125; &#125;&#125; int main()&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;m,&amp;n); memset(mp,' ',sizeof(mp)); getchar(); for(int i=1; i&lt;=2*m-1; i++) &#123; gets(mp[i]+1); &#125; bfs(); /*for(int i=1;i&lt;=2*m-1;i+=2) &#123; for(int j=1;j&lt;=2*n-1;j+=2) &#123; printf("%3d",dis[i][j]); &#125;puts(""); &#125;*/ print(); if(T) puts(""); &#125;&#125; /*24 4+-+-+-+|+-+-+-+ |+-+-+-+|+-+-+-+NRFFLLFFRRFF4 4+-+ +-+| | |+ +-+-+| | |+-+-+-+| |+-+-+-+EFFLFF*/]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 110D--Lucky Probability]]></title>
    <url>%2FCodeforces%20110D--Lucky%20Probability.html</url>
    <content type="text"><![CDATA[题意： 出个两个（P,V）范围在1e9的正整数区间，分别从其中随机选出一个数，选出的两个数作为一个新区间的左右端点。要求新区间内的幸运数刚好为k个的概率（幸运数指一个数的数位只有4或7）。 思路： 首先可以dfs找出所有在数据范围内的幸运数，记为L数组，因为数目不多，便可成k段遍历 L数组，每次分别计算【 L[i-1]+1，L[i]】与【Pl，Pr】的线段交集，和【 L[i+k-1]，L[i+k]-1】与【Vl，Vr】的线段交集，将两个结果相乘即是符合[i,i+k-1]区间幸运数的可能情况，同样的还要对P,V两个区间交换后在计算一遍，概率=所有可能情况/(Pr-Pl+1)/(Vr-Vl+1);然后还要注意k==1的情况会重复计算，需特判。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll L[1050];int num=0;void dfs(int len,int p,int v)&#123; if(p==len) &#123; L[++num]=v; return; &#125; dfs(len,p+1,v*10+4); dfs(len,p+1,v*10+7);&#125; ll contain(ll x1,ll y1,ll x2,ll y2)&#123; ll l=max(x1,x2); ll r=min(y1,y2); return r-l+1&gt;0?r-l+1:0;&#125; int main()&#123; for(int len=1;len&lt;=9;len++) dfs(len,0,0); L[0]=0; L[++num]=1000000000; //for(int i=1;i&lt;=num;i++) printf("%d %lld\n",i,L[i]); ll Pl,Pr,Vl,Vr; int k; scanf("%lld%lld%lld%lld%d",&amp;Pl,&amp;Pr,&amp;Vl,&amp;Vr,&amp;k); ll sum=0; for(int i=1;i&lt;=1022-k+1;i++) &#123; int j=i+k-1; sum+=contain(L[i-1]+1,L[i],Pl,Pr)*contain(L[j],L[j+1]-1,Vl,Vr); if(L[i]&gt;Pr) break; &#125; for(int i=1;i&lt;=1022-k+1;i++) &#123; int j=i+k-1; sum+=contain(L[i-1]+1,L[i],Vl,Vr)*contain(L[j],L[j+1]-1,Pl,Pr); if(L[i]&gt;Vr) break; &#125; if(k==1) &#123; for(int i=1;i&lt;=1022;i++) &#123; if(contain(L[i],L[i],Pl,Pr)&amp;&amp;contain(L[i],L[i],Vl,Vr)) sum--; &#125; &#125; printf("%.10f\n",sum*1.0/(Vr-Vl+1)/(Pr-Pl+1));&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2774--Long Long Message]]></title>
    <url>%2FPOJ%202774--Long%20Long%20Message.html</url>
    <content type="text"><![CDATA[题意：给出两个最长长为1e5的字符串，求他们的最长公共子串长度。 思路： 分别将两个字符串预处理出hash值，二分【1-min（lens，lent）】的长度，check函数中每次将长度为mid的hash值记录并检查是否符合条件，是则下边界右移，否则上边界左移。复杂度O(nlogn) 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int N =100000+5; char s[N],t[N];int lens,lent;ull base=233;ull p[N],hs[N],ht[N];ull geths(int l,int r)&#123; return hs[r]-p[r-l+1]*hs[l-1];&#125;ull getht(int l,int r)&#123; return ht[r]-p[r-l+1]*ht[l-1];&#125; int check(int len)&#123; vector&lt;ull&gt;mp; for(int i=1; i&lt;=lens-len+1; i++) &#123; ull tmp=geths(i,i+len-1); mp.push_back(tmp); &#125; sort(mp.begin(),mp.end()); for(int i=1; i&lt;=lent-len+1; i++) &#123; ull tmp=getht(i,i+len-1); if(binary_search(mp.begin(),mp.end(),tmp)) return 1; &#125; return 0;&#125; int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); p[0]=1; for(int i=1; i&lt;N; i++) p[i]=p[i-1]*base; while(~scanf("%s%s",s+1,t+1)) &#123; lens=strlen(s+1); lent=strlen(t+1); for(int i=1; i&lt;=lens; i++) &#123; hs[i]=hs[i-1]*base+s[i]-'a'; &#125; for(int i=1; i&lt;=lent; i++) &#123; ht[i]=ht[i-1]*base+t[i]-'a'; &#125; int l=1,r=min(lens,lent),mid; while(l&lt;=r) &#123; mid=(l+r)/2; if(check(mid)) l=mid+1; else r=mid-1; &#125; printf("%d\n",r); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>字符串hash</tag>
      </tags>
  </entry>
</search>
