<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python模拟键盘快速输入]]></title>
    <url>%2Fposts%2Fe94f9bd0.html</url>
    <content type="text"><![CDATA[最近做网络安全实验需要登录到远程主机并在上面写代码，考虑到有点延迟和远程主机挂了就代码白写等情况，就想到了这法子之前想过按键精灵或者js来实现，看了教程感觉挺麻烦，问了凯神得知有简单方法，多谢凯神@Kausal 准备python 3.6pyuserinput 模块，这个模块现在集成了pykeyboard和pymouse，安装不上的看这个教程，主要是pyhook需要单独装一下time模块，设置一点点时差一份在本机写好的代码(无中文文本)，这方法对中文只能模拟ctrl+c/v模拟复制粘贴，不能敲出来，反正有中文字符的也几乎用不上 实操以下面代码为例，先获取电脑屏幕尺寸得到要输入的大概位置，然后打开读出要输入的文本文件，再模拟鼠标点击要输入的位置，最后开始输入。需要注意用IDLE第一次运行弹出来的python shell可能会遮挡要输入的位置，第二次调整一下python shell位置即可。 12345678910111213141516171819from pykeyboard import *from pymouse import *import timem = PyMouse() # 鼠标对象k = PyKeyboard() # 键盘对象x_dim, y_dim = m.screen_size() # 获得屏幕尺寸#print('屏幕尺寸为: ', x_dim, y_dim) # 1536 864with open('../A.cpp','r') as f: #选择文件 编码格式 content = f.read()time.sleep(0.1) m.click(200, 200, 1, 1) #点击移动到开始输入的区域time.sleep(0.1)k.type_string(content) #将指定内容敲击出来 运行结果如下，上面坐标(200，200)是左边能看到的txt文档的空白区域]]></content>
      <categories>
        <category>教程总结</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>PyUserInput</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十大经典排序算法实现]]></title>
    <url>%2Fposts%2Fb4167cd9.html</url>
    <content type="text"><![CDATA[平时用的最多的为快排std::sort，了解过其他排序算法的思想但大都没去实现一遍，刚好复习这块来做个小总结以下代码实现均为C/C++版本，默认升序排序，代码都经过对拍无误 冒泡排序从左到右不断交换相邻逆序的元素，在一轮循环之后，可以让未排序的最大元素上浮到右侧。如果在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以退出排序。 123456789101112void BubbleSort(int a[],int n)&#123; for(int i=n-1;i&gt;0;i--)&#123; bool flag=false; for(int j=0;j&lt;i;j++)&#123; if(a[j]&gt;a[j+1])&#123; swap(a[j],a[j+1]); flag=true; &#125; &#125; if(!flag) break; &#125;&#125; 选择排序从数组中选取最小元素和第一个元素交换，从剩余数组中选取最小元素和第二个元素交换……直到数组有序。 123456789void SelectSort(int a[],int n)&#123; for(int i=0;i&lt;n;i++)&#123; int mn=i; for(int j=i+1;j&lt;n;j++)&#123; if(a[j]&lt;a[mn]) mn=j; &#125; swap(a[i],a[mn]); &#125;&#125; 插入排序每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。 1234567void InsertSort(int a[],int n)&#123; for(int i=1;i&lt;n;i++)&#123; for(int j=i;j&gt;0&amp;&amp;a[j-1]&gt;a[j];j--)&#123; swap(a[j-1],a[j]); &#125; &#125;&#125; 希尔排序插入排序的改进版本，对数组进行分组，每间隔h的元素组成一组，组内使用插入排序。通过不断减小 h，最后令 h=1，就可以使得整个数组有序。 123456789void ShellSort(int a[],int n)&#123; for(int h=n/2;h&gt;=1;h/=2)&#123; for (int i=h;i&lt;n;i++) &#123; for (int j=i;j&gt;=h&amp;&amp;a[j]&lt;a[j-h];j-=h) &#123; swap(a[j],a[j-h]); &#125; &#125; &#125;&#125; 归并排序将数组分成两部分，分别进行排序，然后归并起来。 123456789101112131415void MergeSort(int a[],int l,int r)&#123; if(l&gt;=r) return; int mid=(l+r)&gt;&gt;1; MergeSort(a,l,mid); MergeSort(a,mid+1,r); int i=l,j=mid+1,k=0; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(a[i]&lt;=a[j]) b[k++]=a[i++]; else b[k++]=a[j++]; &#125; while(i&lt;=mid) b[k++]=a[i++]; while(j&lt;=r) b[k++]=a[j++]; for(int i=0;i&lt;k;i++) a[l+i]=b[i];&#125; 快速排序一个基准元素将数组分为两个子数组，左子数组小于等于基准元素，右子数组大于等于基准元素，将这两个子数组排序也就将整个数组排序了。 123456789101112131415161718int partition(int a[],int l,int r)&#123; int pivot = a[l]; while(l&lt;r)&#123; while(l&lt;r&amp;&amp;a[r]&gt;=pivot) r--; a[l]=a[r]; while(l&lt;r&amp;&amp;a[l]&lt;=pivot) l++; a[r]=a[l]; &#125; a[l]=pivot; return l;&#125;void QuickSort(int a[],int l,int r)&#123; if(l&gt;=r) return; int mid = partition(a,l,r); QuickSort(a,l,mid-1); QuickSort(a,mid+1,r);&#125; 堆排序先从下到上不断上浮较大值（即下沉较小值）维护大根堆，把堆顶元素与最后一个元素交换，交换之后破坏了堆的特性，我们再把堆中剩余的元素再次构成一个大顶堆，然后再把堆顶元素与最后第二个元素交换….如此往复下去，等到剩余的元素只有一个的时候，此时的数组就是有序的了。 1234567891011121314151617void sink(int i,int n)&#123; while(2*i&lt;=n)&#123; int j=2*i; if(j+1&lt;=n&amp;&amp;a[j+1]&gt;a[j]) j++; if(a[i]&gt;=a[j]) break; swap(a[i],a[j]); i=j; &#125;&#125;void HeapSort(int a[],int n)&#123; //数组下标从1开始 for(int i=n/2;i&gt;=1;i--) sink(i,n); while(n&gt;1)&#123; swap(a[1],a[n]); n--; sink(1,n); &#125;&#125; 桶排序适用于输入均匀的情况，这样一般不会有很多元素同时落在同一个桶。先将数组按值域分块放在不同的桶内，桶内元素采用其他排序算法完成排序，最后按序合并起来。 1234567891011121314void BucketSort(int a[],int n)&#123; int mx = *max_element(a,a+n); vector&lt;int&gt; bucket[n]; for(int i=0;i&lt;n;i++)&#123; int x = a[i]/(mx+1)*n; bucket[x].push_back(a[i]); &#125; int j=0; for(int i=0;i&lt;n;i++)&#123; sort(bucket[i].begin(),bucket[i].end()); for(auto v:bucket[i]) a[j++]=v; &#125;&#125; 计数排序适合于最大值和最小值的差值不是不是很大的数组。把数组元素（或者与数组最小值的偏移量）作为数组的下标，然后用一个临时数组统计该元素出现的次数，再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。 12345678910111213void CountSort(int a[],int n)&#123; int mn = *min_element(a,a+n),mx = *max_element(a,a+n); int cnt[mx-mn+1]; for(int i=0;i&lt;mx-mn+1;i++) cnt[i]=0; for(int i=0;i&lt;n;i++) cnt[a[i]-mn]++; int k=0; for(int i=0;i&lt;mx-mn+1;i++)&#123; for(int j=0;j&lt;cnt[i];j++)&#123; a[k++]=i+mn; &#125; &#125; &#125; 基数排序先以个位数的大小来对数据进行排序，接着以十位数的大小来多数进行排序，接着以百位数的大小……排到最后，就是一组有序的元素了。不过，他在以某位数进行排序的时候，是用“桶”来排序的。 123456789101112131415161718void RadixSort(int a[],int n)&#123; int mx = *max_element(a,a+n),k = 0; while(mx) mx/=10,k++; list&lt;int&gt;bucket[10]; for(int d=0;d&lt;k;d++)&#123; for(int i=0;i&lt;10;i++) bucket[i].clear(); for(int i=0;i&lt;n;i++)&#123; int x = (a[i]/(int)(pow(10,d)+0.5))%10; bucket[x].push_back(a[i]); &#125; int j=0; for(int i=0;i&lt;10;i++)&#123; for(auto v:bucket[i]) a[j++]=v; &#125; &#125;&#125; 总结 排序算法 时间复杂度 空间复杂度 稳定性 冒泡排序 $O(n^2)$ $O(1)$ 稳定 选择排序 $O(n^2)$ $O(1)$ 不稳定 插入排序 $O(n^2)$ $O(1)$ 稳定 希尔排序 $O(n^{1.3-2})$ $O(1)$ 不稳定 归并排序 $O(nlogn)$ $O(n)$ 稳定 快速排序 $O(nlogn)$ $O(logn)$ 不稳定 堆排序 $O(nlogn)$ $O(1)$ 不稳定 桶排序 $O(n+k)$ $O(n+k)$ 稳定 计数排序 $O(n+k)$ $O(k)$ 稳定 基数排序 $O(d(n+k))$ $O(n+k)$ 稳定 参考资料：https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.htmlhttps://cyc2018.github.io/CS-Notes/#/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8Fhttps://www.cnblogs.com/itsharehome/p/11058010.html]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[湘大校园-健康信息填报自动打卡]]></title>
    <url>%2Fposts%2F3800ab52.html</url>
    <content type="text"><![CDATA[前言学校明确了非毕业班学生不返校，却还要我们每天上app打卡一次，偶尔还会忘了导致给负责该工作的学工办老师和班委带来麻烦，所以花了点时间拯救下自己的双手。另外此教程只适用每天上报信息不会变的同学，切勿滥用！ 实现原理：因为对于上报信息不变的同学来讲，每天提交的http报文都是一样的（除了cookie可能会失效需要更新一下，6.12更新：实测半个月失效一次，需要重新抓包修改部分请求头内容），所以就可以抓到提交的完整报文然后交给py的requests库封装一下再重新提交，再将写好的py代码部署在腾讯云函数（每月的流量免费额度基本用不完）上就可以每天定时帮你运行代码提交报文也将相当于打卡了。 准备手机端：湘大校园app电脑端：Fiddler[官网下载],[配置教程]；python3.6（需requests库、json库）腾讯云函数：[官网注册并激活] 为什么要用电脑来抓包呢？是因为实际操作直接用手机抓包app会提示没网或者提示定位未开启（玄学问题无解，可能需要root权限或者加入根证书解决）。 实操 手机开数据流量开定位正常进入到健康信息上报界面，这里先不提交 根据上面教程配置好Fiddler后（注意证书安装和代理地址等关键设置），将手机关流量并连接到和电脑同一局域网下的wifi 手机到健康信息上报界面点提交，这时候根据host过滤Fiddler会抓到以下三个报文 我们只需第一个报文，双击查看报文切换Raw格式，下方data部分里面就是我们要提交的数据，注意“locationAddr”字段是定位的位置必须不为空且合法 将报文的所有内容改一改格式写进py 123456789101112131415161718192021222324import requestsimport json def sender(): url = 'https://app.xiaoyuan.ccb.com/channelManage/outbreak/addOutbreak' headers = &#123; 'Host': 'app.xiaoyuan.ccb.com', 'Connection': 'keep-alive', 'Content-Length': '1208', 'Accept': 'application/json, text/plain, */*', //...... 后面同理填 &#125; null='' data = &#123;'stuClass':'9999','schoolId':'10530',//...... 后面同理填&#125; data = json.dumps(data) res = requests.post(url=url,data=data,headers=headers) return res.textdef main_handler(event, context): return sender()if __name__ == '__main__': sender() 来到腾讯云新建云函数，名称随便，运行环境python3.6，创建方式空白函数 将写好的py代码复制进index.py，点击完成 在函数管理-函数代码中点测试，因为上面代码会return res.text，出现下图结果说明ok，还可以去健康信息上报界面验证一下最近一次提交时间 在触发管理点创建触发器，触发周期改为自定义触发周期，名称随意，Cron表达式 0 0 6 * * * *表示每天的六点定时执行一次，以此类推，另外不建议将时间设为凌晨时间因为可能不算 祝大家玩的开心！有空一起炖橘子哦~]]></content>
      <categories>
        <category>教程总结</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020年牛客算法入门课练习赛1]]></title>
    <url>%2Fposts%2F4f4bb9b1.html</url>
    <content type="text"><![CDATA[邓老师的题目质量还不错，好些日子没刷题了，拿来复习算法练练手并记下一些总结 题集链接点我 A-第K小数给你一个长度为n（10*5e6）的序列，求序列中第k小数的多少。一个很经典的题了，做法很多：1.序列全部排序后取第k个，时间复杂度O(nlogn)2.维护一个大小为k的大根堆，先填满堆，然后后面的a[i]与堆顶元素比较更新堆，时间复杂度O(nlogk)3.利用快排基准分割+二分的思想，不断调整答案区间，时间复杂度O(n) 这里数据量较大，只有方法3能过，当然c++里的nth_element()函数也是基于方法3实现的，但加了一些优化，比手写的快了3倍左右 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e6+5;typedef long long ll;inline int read()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123; if (ch == '-') f = -1; ch = getchar(); &#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123; x = (x&lt;&lt;1) + (x&lt;&lt;3) + (ch^48); ch = getchar(); &#125; return x * f;&#125; int partition(int a[],int l,int h)&#123; int pivot = a[l]; while (l&lt;h) &#123; while(l&lt;h &amp;&amp; a[h]&gt;=pivot) h--; a[l]=a[h]; while(l&lt;h &amp;&amp; a[l]&lt;=pivot) l++; a[h]=a[l]; &#125; a[l]=pivot; return l;&#125; int a[maxn]; int main()&#123; int T=read(); while(T--)&#123; int n=read(),k=read(); for(int i=0;i&lt;n;i++) a[i]=read(); int l=0,r=n-1; while(l&lt;r)&#123; int mid = partition(a,l,r); if(mid&gt;=k) r=mid; else l=mid+1; &#125; printf("%d\n",a[l-1]); &#125; return 0;&#125; B-不平行的直线在坐标纸上有N（200）个不重合的点，两两可以连一个线段并延伸成直线，请问在这些直线里最多能选出多少条使得他们两两不平行也不重合。只要求不平行和不重合，那只要枚举所有直线将斜率相同的直线去重后统计有多少不同的斜率直接用double小数记录斜率可能有误差，用pair记录分数形式，注意要化为最简形式和分子分母符号的统一 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3+5;typedef long long ll;set&lt;pair&lt;int,int&gt;&gt;st;int x[maxn],y[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d%d",&amp;x[i],&amp;y[i]); for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; int fz=y[j]-y[i],fm=x[j]-x[i]; int d = __gcd(fz,fm); fz/=d,fm/=d; if(fz&lt;0) fz*=-1,fm*=-1; st.insert(make_pair(fz,fm)); &#125; &#125; printf("%d\n",st.size()); return 0;&#125; C-丢手绢一个圆上有N（1e5）个点，给出相邻两个点的距离，求任意两个点最小距离的最大值。因为是圆，可以想到枚举点x的时候，最远的点y是可以通过三分得到的，check的话将圆展开一条线统计前缀和就可以计算x到y的最小距离 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+5;typedef long long ll;int n;int a[maxn],sum[maxn];int calc(int x,int y)&#123; int x1 = sum[x]+sum[n+1]-sum[y]; int x2 = sum[y]-sum[x]; return min(x1,x2);&#125;int main()&#123; scanf("%d",&amp;n); sum[1]=0; for(int i=2;i&lt;=n+1;i++)&#123; scanf("%d",&amp;a[i]); sum[i]=sum[i-1]+a[i]; &#125; int ans=0; for(int i=1;i&lt;=n;i++)&#123; int l=1,r=n; while(l&lt;r)&#123; int lmid=l+(r-l)/3; int rmid=r-(r-l)/3; if(calc(i,lmid)&lt;calc(i,rmid)) l=lmid+1; else r=rmid-1; &#125; ans = max(ans,calc(i,l)); &#125; printf("%d\n",ans); return 0;&#125; D-二分二分猜数字，给出一些猜数字的结猜测果，符号如果是“+”说明猜的数比答案大，“-”说明比答案小，“.”说明猜到了答案。问最多能有多少次是符合猜测结果的。1e5条记录，每条记录中猜的数都小于int类型最大值，考虑离散化，假如离散化后的区间为[1,m]，猜的数是x，对于“+”，那么在[1,x-1]区间上+1，对于“-”，那么在[x+1,m]区间上+1，对于“.”，那么在[x,x]区间上+1，最后找到[1,m]上的最大值就是符合最多猜测结果的次数。 1.离散化后线段树单点更新+区间更新 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1const int maxn = 3e5+5;typedef long long ll;int sum[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2];void pushdown(int o)&#123; if(lazy[o])&#123; int v = lazy[o]; lazy[o&lt;&lt;1] += v; lazy[o&lt;&lt;1|1] += v; sum[o&lt;&lt;1] += v; sum[o&lt;&lt;1|1] += v; lazy[o] = 0; &#125;&#125;void update(int L,int R,int v,int l,int r,int o)&#123; if(L&gt;R) return; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; sum[o]+=v; lazy[o]+=v; return; &#125; pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) update(L,R,v,lson); if(R&gt;mid) update(L,R,v,rson);&#125;int mx=0;void down(int l,int r,int o)&#123; if(l==r)&#123; mx=max(mx,sum[o]); return; &#125; pushdown(o); int mid=(l+r)&gt;&gt;1; down(lson); down(rson);&#125;int a[maxn],b[maxn];vector&lt;int&gt;vc;int main()&#123; int n; scanf("%d",&amp;n); char op[2]; for(int i=0;i&lt;n;i++)&#123; scanf("%d %s",&amp;a[i],op); vc.push_back(a[i]); //这里因为所有x不一定是连续的，所以将前后两个数也加进来 vc.push_back(a[i]-1); vc.push_back(a[i]+1); if(op[0]=='.') b[i]=0; else if(op[0]=='-') b[i]=-1; else if(op[0]=='+') b[i]=1; &#125; sort(vc.begin(),vc.end()); vc.erase(unique(vc.begin(),vc.end()),vc.end()); int m = vc.size(); for(int i=0;i&lt;n;i++)&#123; a[i]=lower_bound(vc.begin(),vc.end(),a[i])-vc.begin()+1; if(b[i]==0) update(a[i],a[i],1,1,m,1); else if(b[i]==-1) update(a[i]+1,m,1,1,m,1); else if(b[i]==1) update(1,a[i]-1,1,1,m,1); &#125; down(1,m,1); printf("%d\n",mx); return 0;&#125; 2.还有一种巧妙的做法，利用map直接记录差分值，然后求前缀和的最大值 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+5;typedef long long ll;map&lt;int,int&gt;mp;ll inf = 1LL&lt;&lt;40;int main()&#123; int n; scanf("%d",&amp;n); char op[2]; int x; for(int i=0;i&lt;n;i++)&#123; scanf("%d %s",&amp;x,op); if(op[0]=='.')&#123; mp[x]++; mp[x+1]--; &#125; else if(op[0]=='+')&#123; mp[-inf]++; mp[x]--; &#125; else if(op[0]=='-')&#123; mp[x+1]++; &#125; &#125; int mx=0,sum=0; for(auto it:mp)&#123; sum += it.second; mx = max(mx,sum); &#125; printf("%d\n",mx); return 0;&#125; E-交换求交换一个序列中任意两个元素的最少次数使得序列从小到大排序。序列长度1e5，所有元素不相同。 将原序列排好序的作为对比，如果a[i]不在排好序的对应位置上的话，直接交换到对应位置上去，然后更新记录位置的信息，这样交换次数是最少的。 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+5;typedef long long ll;int a[maxn],b[maxn];map&lt;int,int&gt;pos;int main()&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); b[i]=a[i]; pos[a[i]]=i; &#125; sort(b,b+n); int ans=0; for(int i=0;i&lt;n;i++)&#123; if(a[i]==b[i]) continue; int p=pos[b[i]]; pos[a[p]]=i; pos[a[i]]=p; swap(a[i],a[p]); ans++; &#125; printf("%d\n",ans);&#125; 注意：如果是限制交换相邻的元素，那就是和插入排序一样了，最少需要交换原序列的逆序数次。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>牛客、算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动通信基础 复习笔记]]></title>
    <url>%2Fposts%2Fd92fb13.html</url>
    <content type="text"><![CDATA[整理来自老师的《移动通信基础》课程复习参考资料 第一章 移动通信概论 移动通信的定义移动用户之间，或移动用户与固定用户之间进行的通信。这里所说的通信，不仅指双方的通话，还包括数据、传真、图像等通信业务。 移动通信的分类 频率复用的概念频率复用也称频率再用，就是重复使用频率，在GSM网络中频率复用就是使同一频率覆盖不同的小区，这些使用同一频率的小区彼此需要相隔一定的距离，以满足将同频干扰抑制到允许的指标以内。区群个数：i,j确定方法：①沿着任意一条六边形链移动i个小区②逆时针旋转60度再移动j个小区相邻小区距离：相邻同频道小区距离： 蜂窝系统的组成一个基本的或者说最简单的蜂窝系统由移动台（MS）、基站（BS）和移动交换中心（MSC）3部分组成。 移动通信标准化组织，知道对应英文缩写的含义，比如，ITU，CCSA等ITU（International Telecommunication Union）——国际电信联盟 ITU-R——无线电通信部门 ITU-T——电信标准化部门 3GPP（3rd Generation Partnership Project）——第三代合作伙伴计划（WCDMA、TD-SCDMA） 3GPP2（3rd Generation Partnership Project2）——第三代合作伙伴计划2（CDMA2000） IEEE-SA（Institute of Electrical and Electronics Engineers-Standards Association）——电气和电子工程师协会的标准化协会OMA（Open Mobile Alliance）——开放移动联盟TR45——美国公众移动委员会ETSI（European Telecommunications Standards Institute）——欧洲电信标准化协会（GSM）CCSA（China Communications Standards Association）——中国通信标准化协会 第二章 移动通信基本技术及原理 移动通信的工作方式：时分双工和频分双工的优缺点频分双工具有以下优缺点：优点： ①收发频率分开可大大减小干扰； ②用户使用方便。缺点： ①移动台在通话过程中总是处于发射状态，因此功耗大； ②移动台之间通话需占用两个信道； ③设备较复杂，价格较贵。 时分双工具有以下优缺点：优点： ①能高效灵活地利用所有可用带宽； ②可动态分配上下行链路的容量，实现资源分配的灵活性； ③上下行链路的一致性较好； ④在对移动台的发射功率进行控制时，可以用开环功率控制来取代较为复杂的闭环功率控制。缺点： ①TDD系统所提供的移动性和覆盖有限。 无线电波传播的主要方式，各有什么特点直射波传播 ：在自由空间中，电波沿直线传播而不被吸收，也不发生反射、折射和散射等现象而直接到达接收点的传播方式。反射波传播：电波在传输过程中，遇到两种不同介质的光滑界面时，就会发生反射现象。绕射波传播：电磁波经过较大的建筑物与饶射后到达接收天线。 移动信道的主要特征有哪些①传播的开放性。无线信道都是基于电磁波在空间的传播来实现开放式信息传输的。它不同于固定的有线通信，是基于全封闭式的传输线来实现信息传输的。②接收环境的复杂性。接收点地理环境的复杂多样，一般可将接收点地理环境分为高楼林立的城市繁华区、一般楼宇的、一般城区以一般性建筑为主的近郊区、以山区和湖泊等为主的农村及远郊区。③通信用户的随机移动性。用户通信一般有3种状态：准静态的室内用户通信、慢速步行用户通信、高速车载用户通信。 无线电波传播距离的计算发射天线和接收天线高度分别为hT和hR(单位m)，则视距传播的极限距离为： 考虑空气的不均匀性对电波传播轨迹的影响修正后的视距传播的极限距离为： 移动信道的3种损耗①路径损耗：即电波在空间中传播产生的损耗。它反映出电波在宏观范围内的空间距离上接收信号电平平均值的变化趋势。②慢衰落损耗：主要是指电波在传播路径上受到建筑物等阻挡所产生阴影效应时的损耗。它反映出电波在中等范围内的接收信号电平平均值起伏变化趋势。③快衰落损耗：它是反映微观小范围接收电平平均值的起伏变化趋势。其电平幅度分布一般遵从瑞利分布、莱斯分布和纳卡伽米分布，变化速度比慢衰落快，因此称为快衰落。快衰落还可分为：空间选择性衰落、频率选择性衰落和时间选择性衰落。 移动信道的4种效应①阴影效应：由于大型建筑物和其他物体遮挡，在电波传播的接收区域产生传播半盲区。②远近效应：由于接收用户的随机移动性，移动用户与基站之间的距离也在随机的变化，若各种移动用户发射信号的功率一样，那么到达基站时信号的强弱将不同，离基站近的信号强，反之则弱。③多径效应：由于接收者所处地理环境复杂性，使得接收到的信号不仅有直射波的主径信号，还有从不同建筑物反射及绕射过来的多条不同路径信号，而且它们到达时的信号强度、到达时间及到达时的载波相位都不一样。所接收到的信号实际上是各路径信号的矢量和。多径效应是移动信道中较主要干扰。④多普勒效应：它是由于接收用户处于高速移动中，比如车载通信时传播频率的扩散而引起的，其扩散程度与用户运动速度成正比。这一现象只在高速车载通信时出现。 3种类型的快衰落①空间选择性衰落：在不同的地点与空间位置衰落特性不一样。②频率选择性衰落：在不同的频段上衰落特性不一样。③时间选择性衰落：不同的时间，衰落特性不一样。 移动信道建模方法几何模型概率模型经验模型 常用的3种多址方式：FDMA、TDMA、CDMAb站学习视频 FDMA：将可使用的频段按一定的频率间隔（如25kHz或30kHz）分割成多个频道。众多的移动台共享整个频段，根据按需分配的原则，不同的移动用户占用不同的频道。各个移动台的信号在频谱上互不重叠，其宽度能传输一路话音信息，而相邻频道之间无明显干扰。为了实现双工通信，信号的发射与接收就使用不同的频率（称之为频分双工）。 TDMA：多个用户在不同的时间片（时隙）来使用相同的频率。 CDMA：各基站使用同一频率并在同一时间进行信息传输的技术。由于发送信号时叠加了伪随机码，使信号的频谱大大加宽。采用这种技术的通信系统也称为扩频通信系统。 扩频通信的基本原理，主要优缺点在发端输入的信息先经信息调制形成数字信号，然后由扩频码发生器产生的扩频码序列去调制数字信号以展宽信号的频谱。展宽后的信号再调制到射频发送出去。（使得传输信息所用的带宽远大于信息本身带宽）在接收端收到的宽带射频信号，变频至中频，然后由本地产生的与发端相同的扩频码序列去相关解扩。再经信息解调、恢复成原始信息输出。优点：①抗干扰性能好，它具有极强的抗人为宽带干扰、窄带瞄准式干扰、中继转发式干扰的能力，有利于电子反对抗。如果再采用自适应对消、自适应天线、自适应滤波，可以使多径干扰消除，这对军用和民用移动通信是很有利的。②隐蔽性强、干扰小，因信号在很宽的频带上被扩展，单位带宽上的功率很小，即信号功率谱密度很低。信号淹没在白噪声之中，难以发现信号的存在，再加上扩频编码，就更难拾取有用信号。扩频通信技术把被传送的信号带宽展宽，从而降低了系统在单位频宽内的电波“通量密度”，这对空间通信大有好处。③易于实现码分多址，扩频通信占用宽带频谱资源，改善了抗干扰能力，提高了频带的利用率。 缺点：①系统用频带宽。②相对于FDMA、TDMA多址方式，采用扩频技术的CDMA多址方式在移动通信的系统实现更为复杂。 移动通信对调制技术的要求①调制频谱的旁瓣应该尽量小，避免对邻近信道的干扰。②调制频谱效率高，即要求单位带宽传送的比特速率高。③能适应瑞利衰落信道，抗衰落性能好。即在瑞利衰落环境中，达到规定的误码率要求，解调时所需的信噪比低。④调制和解调的电路容易实现 。 OFDM调制 OFDM技术提供了让数据以较高的速率在较大延迟的信道上传输的另一种途径。其基本原理是将高速的数据路分接为多路并行的低速数据流，在多个正交载波上同时进行传输，对于低速并行的子载波而言，由于符号周期展宽，多径效应造成时延扩展变小。当每个OFDM符号中插入一定的保护时间后，其码间串扰就可以忽略了。 保护间隔的作用是为了避免多径信道上产生的码间串扰。只要保护时间大于多径时延扩展，则一个符号的多径分量不会干扰相邻符号。 抗衰落、抗干扰技术，分集、合并，均衡分集：将接收到的多径信号分离成不相干（独立）的多路信号，然后将这些多路信号的能量按照一定规则合并起来，使接收的有用信号能量最大，从而提高接收端的信噪功率比 合并：在接收端取得N条相互独立的支路信号以后，可以通过合并技术来得到分集增益。根据在接收端使用合并技术的位置不同，可以分为检测前合并技术和检测后合并技术。分类：最大比值合并（MRC）、等增益合并（EGC）、选择式合并（SC）平均信噪比的改善程度：MRC &gt; EGC &gt; SC 均衡：①频域均衡，它主要从频域角度来满足无失真传输条件，它是通过分别校正系统的幅频特性和群时延特性来实现的。主要用于早期的固定式有线传输网络中。②时域均衡，它主要从时间响应考虑以使包含均衡器在内的整个系统的冲击响应满足理想的无码间串扰的条件。目前广泛利用横向滤波器来实现，它可以根据信道的特性的变化而不断的进行调整，实现比频域方便，性能一般也比频域好，故得到广泛的应用。 移动通信中，信道编码的主要功能，分为哪些类型①只有检错功能的检错码，如循环冗余校验CRC码、自动请求重传ARQ。②具有自动纠错功能的纠错码，如循环码中的BCH码、RS码及卷积码、级联码、Turbo码等。③既能检错又能纠错的信道编码，最典型是HARQ（混合ARQ） 语音编码技术有哪些类型，各具有什么样的特点①波形编码：在一定程度上降低语音编码数码率的同时，保持相对好的语音质量。一般可使数码率低到16kbit/s尚能有较高的语音质量。②参量编码：语音编码速率较低，语音质量较差。③混合编码：数字语音信号中即包括若干语音特征参量又包括部分波形编码信息，因而综合了波形编码和参量编码各自的优点。 第三章 数字移动通信系统（2G） GSM系统的结构：网络各部分的主要功能，GSM的区域和识别号码 MS（移动台）它包括ME（移动设备）和SIM（用户识别模块）卡，移动台可分为车载台、便携台和手机3类，其主要作用是通过无线接口接入网络系统，也提供人机接口。BSS由BTS（基站收发台）和BSC（基站控制器）组成，主要的功能是负责无线发射和管理无线资源。BTS是用户终端的接口设备，BSC可以控制一个或多个BTS，可以控制信道分配，通过BTS对信号强度的检测来控制移动台和BTS的发射功率，也可作出执行切换的决定。NSS（网络子系统）由MSC（移动交换中心，GSM的核心部分，主要是对位于它所管辖区域中的移动台进行控制、交换）和OMC（操作维护中心，对GSM网络系统进行管理和监控）以及HLR（归属位置寄存器，静态数据库，用来存储有关用户的参数和有关用户目前所处位置的信息）、VLR（访问位置寄存器，动态数据库，用于存储进入其控制区用户的数据信息）、AUC（鉴权中心，专用于GSM系统的安全性管理）和EIR（设备标志寄存，用来存储有关移动台设备参数的数据库，对移动设备进行识别、监视和闭锁等）等组成。NSS主要负责完成GSM系统内移动台的交换功能和移动性管理、安全性管理等。SMSC（短消息业务中心）与NSS连接可实现点对点短消息业务，与BSS连接完成小区广播短消息业务 GSM区域划分 GSM服务区：是指移动台可获得服务的区域PLMN区（公用陆地移动通信网） 识别码①MSISDN（移动台国际身份号码） ②IMSI（国际移动用户识别码）③MSRN（移动台漫游号码）④TMSI（临时移动用户识别码）⑤IMEI（国际移动台设备识别码）⑥LAI（位置区识别码）⑦CGI（小区全球识别码）⑧BSIC（基站识别码） GSM采用了哪些抗衰落技术①信道编码：在源数据码流中加入监督码元，接收端解码时利用这些监督码元检错并纠错，可提高传输可靠性；②交织编码：把一个较长突发差错离散成随机差错，再用纠正随机差错的编码技术消除随机差错；③均衡和分集接收：接收端的均衡器产生与信道相反的特性，可抵消信道的时变多径传播特性引起的码间干扰。分集接收则是接受多个信道的多个副本的信息，可比较并恢复出原发送信号；④跳频技术：把一个宽频段分成若干个频率间隔，由一个伪随机序列控制发射机在某一特定的驻留时间发送信号的载波频率；⑤语音激活和功率控制：语音激活在有话音信号时才打开发射机，其余时间都关闭，可减少干扰。功率控制是基站根据移动台的距离调整发射功率来降低干扰和补偿路径损耗。 越区切换的概念，主要分为哪几类越区切换：指移动用户在通话期间从一小区移动到另外一个小区，网络能实时控制将移动台从原来的信道切换到新小区的某个信道，并且保持通话不间断。 分类： ① 同一BSC控制区内不同小区之间的切换 ② 同一MSC/VLR内不同BSC控制小区间的切换 ③ 不同MSC/VLR控制的小区间的切换 GSM系统采用的安全措施①鉴权：移动台的主叫和被叫过程需要与VLR验证合法性；②加密：在MS和BTS都会采取A5算法加密发送数据和解密接受数据；③移动设备识别；④国际用户识别码（IMSI）保密。 CDMA系统的软切换和软容量软切换指移动台开始与新的基站通信但不立即中断它和原来基站通信的一种切换方式。软切换只能在同一频率的CDMA信道中进行。软切换是CDMA蜂窝系统独有的切换方式，可有效地提高切换的可靠性，而且若移动台处于小区的边缘上，软切换能提供正向业务信道分集，也能提供反向业务信道的分集，从而保证通信质量。导频分类：①激活组：和分配给移动台的正向业务信道结合的导频。②候补组：未列入激活组，但具有足够的强度表明它与正向业务信道结合并能成功地被解调。③邻近组：未列入激活组和候补组，但可作为切换的备用导频。④剩余组：未列入上述⑴、⑵、⑶组的导频。切换过程： ⑴ 导频强度超过门限（上），移动台向基站发送一导频强度测量消息，并把导频转换到候补组；⑵ 基站向移动台发送一切换引导消息；⑶ 移动台把导频转换到激活组，并向基站发送一切换完成消息；⑷ 导频强度降低到门限（下）之下，移动台启动切换下降计时器；⑸ 切换下降计时器终止；移动台向基站发送一导频测量消息；⑹ 基站向移动台发送一切换消息；⑺ 移动台把导频从激活组转移到邻近组，并向基站发送一切换完成消息。 软容量在CDMA系统中，用户数目和服务质量之间可以相互折中，灵活确定。例如系统经营者可以在话务量高峰期将误帧率稍微提高，从而增加可用信道数。同时，当相邻小区的负荷较轻时，本小区受到的干扰减少，容量就可适当增加。体现软容量的另一种形式是小区呼吸功能。所谓小区呼吸功能就是指各个小区的覆盖大小是动态的，当相邻两个小区负荷一轻—重时，负荷重的小区通过减小导频发射功率，使本小区的边缘用户由于导频强度不够，切换到相邻小区，使负荷分担，即相当于增加了容量。这项功能对切换也特别有用，可避免信道紧缺而导致呼叫中断。在模拟系统和数字TDMA系统中，如果一条信道不可用，呼叫必须重新被分配到另—条信道，或者在切换时中断。但是在CDMA系统中，在一个呼叫结束前，可以接纳另一个呼叫。 功率控制(1) 功率控制功能 CDMA系统中所有的移动台在相同的频段工作，所以系统内部的干扰在决定系统容量和通信方面起到关键作用。为了获得大容量、高质量的通信，CDMA系统移动通信系统必须具有功率控制功能。(2) 反向功率控制方法（控制移动台发射功率，分开环闭环）(3) 正向功率控制方法（控制基站发射功率，分开环闭环） 第四章 B2G移动通信系统 GPRS的特点资源共享，频率利用率高。数据传输速率高。实行动态链路适配。用户一直处于在线连接状态，接入速度快。向用户提供4种QoS类别的服务，并且用户QoS的配置是可以协商的。支持IP协议和X.25协议。采用数据流量计费。 GPRS的移动性管理GPRS移动性管理（GMM）的功能是实现对移动终端的位置管理，将MS的当前位置报告给网络。其管理流程主要有附着（attach）、分离（detach）、位置管理等处理流程，每个处理流程中通常会加入登记、鉴权、IMSI校验、加密等接入控制与安全管理功能。GPRS移动台有3种移动性管理状态：Idle（空闲）、Standby（待命）、Ready（就绪）。某个时刻的MS总是处在其中某一状态下。由下图可以看出MS的3种MM（移动性管理）状态之间相互转换的关系和条件。管理过程：(1) GPRS附着过程当GPRS用户开机时，GPRS手机将监听无线信道，接收系统信息，然后在系统信息指出的控制信道上发送接入请求，系统将分配无线信道给GPRS手机，之后，GPRS手机将在系统分配的无线信道上向SGSN发送注册连接请求，移动台注册成功后，要想访问外部数据网，还需发起PDP（分组数据协议）场景激活过程。 (2) PDP场景激活过程第1步，移动终端向SGSN发送激活PDP场景请求消息，消息中带有如下信息：访问点名=WWW.sina.com.cn；PDP地址为空，表示请求动态地址分配；服务质量和其他选项。第2步，SGSN请求DNS对APN进行解析，得到该APN对应的GGSN的IP地址。第3步，SGSN向GGSN发送建立PDP场景的请求消息，消息中带有如下信息：访问点名=WWW.sina.com.cn；PDP地址为空，表示请求动态地址分配；服务质量和其他选项。第4步，GGSN对该用户进行认证，认证通过以后使用RADIUS（远程用户拨号认证服务器）服务器、DHCP（动态主机配置协议）服务器或直接由GGSN为该用户分配动态IP地址。GGSN向SGSN返回建立PDP场景响应消息。第5步，SGSN向移动终端发送激活PDP场景接受消息。 (3) GPRS分离过程分离过程允许移动台通知网络，它需要GPRS和/或IMSI分离；同时也允许网络通知移动台，网络已经分离GPRS或IMSI。这就是说，分离过程可以由移动台发起，也可以由网络发起。共有3种类型的分离：IMSI分离、GPRS分离、GPRS/IMSI联合分离（只能由移动台发起）。当移动台不可到达定时器超时以后，或者不可恢复的无线错误引起逻辑链路被拆除，此时发生隐式分离，网络分离移动台而不用通知移动台。 SGSN和MSC/VLR间的交互通过SGSN的IMSI连接和分离，允许组合GPRS/IMSI连接，以及组合GPRS/IMSI分离，这样节省无线资源；统一协调位置区和路由区（RA）更新，包括周期更新，节省无线资源，从移动台至SGSN，发送一次组合路由区/位置区更新，SGSN将位置区更新往前送给VLR。通过SGSN寻呼，建立CS连接；非GPRS业务告警过程；识别过程；移动性管理信息过程。 EDGE系统的关键技术(1) 增强的调制技术 在GSM/GPRS网络中，使用的是GMSK调制方式。在EDGE中，为了提高数据传输速率，引入了8PSK调制方式。由8种不同相位表示3个比特的信息量（000－111），传输速率提高到GSM/GPRS系统采用的GMSK（高斯最小移频键控，为两相键控）的3倍，其符号速率保持在270kb/s，每个时隙可以得到最大59.2kb/s的有效载荷速率。(2) 自适应调制编码技术 2种调制方案和9种编码方案组合的9种不同传输模式，根据信道等条件自适应选择。(3) 增量冗余技术 EDGE中另外一种对付链路质量变化的方式是逐步增加冗余度。在这种方式中，信息刚开始传输时，采用纠错能力较低的编码方式，如果接收端解码正确，则能得到比较高的信息码率。反之，如果解码失败，则需要增加编码冗余量，直到解码正确为止。显然，编码冗余度的增加将导致有效数据速率的降低和延时的增加。 第五章 第三代移动通信系统（3G） 全球四大3G标准WCDMA（联通），CDMA2000（电信），TD-SCDMA（移动），WiMAX WCDMA系统的网络结构UE（用户终端设备）通过Uu接口与网络设备进行数据交互，为用户提供电路域和分组域内的各种业务功能。UE包括两部分：ME和USIM NodeBWCDMA系统的基站，通过lub接口与RNC互连，完成Uu接口物理层协议的处理。主要功能是扩频调制信道编码及解扩解调信道编码，还包括基带信号和射频信号的相互转换等功能。 RNC（Radio Network Controller）切换系统信息广播与系统接入控制功能切换和RNC迁移等移动性管理功能宏分集合并功率控制无线承载等无线资源管理和控制功能 CN（Core NEtwork）负责与其他网络的连接和对UE的通通信和管理 3G的主流多址技术CDMA因为TDMA并不是现代蜂窝移动通信的最佳无线接入，而CDMA多址技术完全适合现代移动通信网大容量、高质量、高速率、综合业务、软切换、国际漫游、向下兼容等要求。 ARQ、FEC反馈重发(ARQ) 这种方式在是发信端采用某种能发现一定程度传输差错的简单编码方法对所传信息进行编码 ，加入少量监督码元，在接收端则根据编码规则收到的编码信号进行检查，一量检测出(发现)有错码时，即向发信端发出询问的信号，要求重发。发信端收到询问信号时，立即重发 已发生传输差错的那部分发信息，直到正确收到为止。 反馈纠错可用于双向数据通信，前向纠错则用于单向数字信号的传输，例如广播数字电视系统，因为这种系统没有反馈通道。前向纠错(FEC) 这种方式是发信端采用某种在解码时能纠正一定程度传输差错的较复杂的编码方法，使接收端在收到信码中不仅能发现错码，还能够纠正错码。采用前向纠错方式时，不需要反馈信道，也无需反复重发而延误传输 时间，对实时传输有利，但是纠错设备比较复杂。 高速分组下行技术（HSDPA）HSDPA是3GPP在R5协议中为了满足上/下行数据业务不对称的需求提出的一种调制解调算法。它可以在不改变已经建设的WCDMA网络结构的情况下，把下行数据业务速率提高到10Mb/s。该技术是WCDMA网络建设后期提高下行容量和数据业务速率的一种重要技术。在具体实现中，采用了自适应调制和编码（AMC）、混合自动重传请求（HARQ）、快速调度等技术。 我国采用的三种主流3G标准的方案性能比较①在CDMA技术利用程度方面:TD-SCDMA在充分利用CDMA方面较差。原因是：一方面，TD-CDMA要和GSM兼容：另一方面，由于不能充分利用多径，降低了系统的效率，而且软切换和软容量能力实现起来相对较困难。但联合检测容易。 ②在同步方式，功率控制和支持高速能力方面:目前的IS-95采用64位的Walsh正交扩频码序列，反向链路采用非相关接收方式，成为限制容量的主要问题，所以在第三代系统中反向链路普遍采用相关接收方式。TD-SCDMA继承了GSM900／DCS1800正反向信道同步的特点，从而克服了反向信道的容量瓶颈效应。而同步意味着帧反向信道均可使用正交码，从而克服了远近效应，降低了对功率控制的要求。WCDMA支持异步传输，其它两个需同步 ③在频谱利用率方面:TD-SCDMA具有明显的优势，被认为是目前频谱利用率最高的技术。其原因一方面是TDD方式能够更好地利用频率资源，另一方面在于，TD-SCDMA的设计目标是要做到设计的所有码道都能同时工作。此外，不对称的移动因特网将是IMT-2000的主要业务。TD-SCDMA因为能很好地支持不对称业务，而成为最适合移动因特网业务的技术，也被认为是TD-SCDMA的一个重要优势，而FDD系统在支持不对称业务时，频谱利用率会降低，并且目前尚未找到更为理想的解决方案。 ④在市场前景方面:WCDMA产业链最完善，在全球拥有最多的市场支持CDMA2000技术本身优秀，但产业链被高通独占，前景不乐观TD-SCDMA中国拥有自主知识产权，政府大力支持 第六章 第四代移动通信系统（4G） 4G移动通信系统的标准，这些标准之间的主要技术差异①LTE-Advanced：LTE技术的升级版，核心技术新增载波聚合技术、中继技术、协同多点传输技术。②WirelessMAN-Advanced：WiMax的升级版，即IEEE802.16m。两者主要技术差不多，区别在于演进方向不一样。 LTE采用的多址方式上行：SC-FDMA下行：OFDMA LTE系统的关键技术和LTE-A系统的关键技术，这些技术分别解决什么问题。 LTE系统的关键技术有：① OFDMA多址技术：解决宽带移动通信系统中的频率选择性衰落和符号间干扰问题；② MIMO技术：为了增大信道容量和提高频谱利用效率；③ HARQ技术：为了补偿由于采用链路适配所带来的误码，提高数据传输速率，减小数据传输时延；④ 多维动态资源分配与链路适配技术：为了实现上下行链路无线资源调度；⑤ 自适应调制编码技术：根据信道条件调整调制和解码方式，从而提高信道利用率；⑥ 功率控制技术：保证小区内的所有用户既能正确接收下行控制信令，又能保证下行数据的传输质量。 LTE-A系统的关键技术有：①载波聚合技术：为了满足单用户峰值速率和系统容量提升的要求；②增强的MIMO技术：提高单用户上下行的峰值速率；③协作多点传输技术：将多个接入点信号的发送与接收进行紧密协调，可以有效降低干扰、提高系统容量、改善小区边界的覆盖和用户数据速率；④中继技术：为了改变系统容量和改善网络覆盖；⑤异构网络与增强型小区干扰协调技术：为了减轻宏蜂窝负载、提高特定区域的覆盖质量、改善边缘用户性能、降低网络开销、减少能量消耗、降低运营商网络部署成本。 LTE/LTE-A的最小资源和最小调度资源LTE/LTE-A的最小资源是RE(Resource Element)，频域上占用一个子载波(15KHz)，时域上占用一个symbol。最小调度资源是RB(Resource Block)，频域上占连续12个子载波(180KHz)，时域上占一个slot(0.5ms)。1RB = 84RE LTE/LTE-A的语音解决方案有哪几种？各自的优缺点①CSFB语音方案：优点是能够在4G建网初期没有4G信号覆盖的时候能够回落到2G/3G信号上保证语音通话。缺点是需要升级2G/3G网络，数据和语音不能同时并发，即通话时不能利用LTE进行上网，同时反复切换信号还会导致掉话。②SVLTE语音方案：优点是无需升级2G/3G网络就能能够实现单卡双待，同时处在LTE和2G/3G网络中，数据和语音可以同时并发，并不会相互干扰，通话时也可以利用LTE上网。缺点是需要终端支持，终端开发难度高。③VoLTE语音方案：优点是采用全IP的端到端语音方案和高分辨率编解码技术，使通话有更高质量的效果和更低的时延，掉话率几乎为零，同时还能提高无线频谱利用率、降低网络成本。缺点是需要在核心网部署完善的IMS核心网网元设备来控制语音业务的发起和呼叫。 第七章 第五代移动通信系统（5G） 5G的应用场景 5G的8项关键能力指标&emsp;&emsp;峰值速率达到20Gbps、频谱效率比IMT-A提升3倍、移动性达500公里/小时、时延低至1毫秒，用户体验数据率达到100Mbps、连接密度每平方公里达到1e6个、能效比IMT-A提升100倍、流量密度每平方米达到10Mbps。其中前四个是传统指标，后四个为新增指标。 5G的频谱 5G网络逻辑分为哪3大模块？各自完成什么功能接入平面、控制平面、转发平面控制平面主要负责生成信令控制、网管指令和业务编排逻辑，接入平面和转发平面主要负责执行控制命令。 5G承载网络架构 — 5G智能终端个人信息中心通信能力：多连接、离散频谱资源、更强大的可重配置能力可穿戴设备通信能力：近距离低功耗通信、高速云存取、预警信息通知智能机器设备通信能力：高可靠连接、低时延连接、分布式自组织网络微型传感器通信能力：自组织网络、低功耗传输、预警广播 第八章 移动通信与计算机网络通信的融合 TCP/IP协议 移动通信和计算机网络通信的三种融合方式 技术融合业务融合网络融合 第九章 移动通信网络的规划、设计与优化 无线传播Okumura-Hata模型 $d$为收发天线之间的距离（km）；$f$为工作频率（MHz）；$h_b$为基站天线有效高度（m）；$h_m$为移动台天线高度（m）；$\alpha(h_m)$为移动台天线高度校正因子。 适用范围为：150MHz≤$f$≤1500MHz，30m≤$h_b$≤200m，1m≤$h_m$≤10m，1km≤$d$≤20km，准平滑地形。]]></content>
      <categories>
        <category>专业课程</category>
      </categories>
      <tags>
        <tag>移动通信基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面经]]></title>
    <url>%2Fposts%2F98e6f621.html</url>
    <content type="text"><![CDATA[记录一下找工作的小颠簸~~ 基本情况：蚂蚁金服：笔试+1面挂+1面挂字节跳动：提前批3面挂+正式批3面（接受实习offer）update：2021/2/19 收到转正offer快手：简历挂美团：笔试+2面挂哔哩哔哩：笔试挂（风评不好已拉黑）拼多多：流程太慢笔试拒网易：流程太慢笔试拒 面试总结：开头自我介绍和最后问面试官的问题比较重要，做好充分准备；回答问题后不要询问回答是否正确；问题不会就说不会，不要给自己挖坑；压力面沉着冷静；多看面经查漏补缺；最重要的还是专业知识的review以及算法和数据结构的练习；“我们并不指望你掌握所有知识，当今社会这也是不现实的，我们更加希望你对你会的东西有自己的理解，能作一些合理的推断” 蚂蚁金服——JAVA研发工程师笔试（4.3） A. 给一个长度n(1e5)的数字序列，对每个数定义f[i]为i左边第一个大于a[i]的数，g[i]为i右边第一个小于a[i]的数，问有多少个a[i]的f[i]和g[i]是倍数关系？思路：set+二分B. 给一个n*m(1e3)的矩阵，每个位置有个权值，问从第一行任意起点到第n行任意终点的最小路径权值和是多少？思路：bfs+优先队列 一面（4.11） 自我介绍询问ACM训练情况，队内分工，印象最深的一道题，大学影响最大的一件事问题：1、两幅扑克牌(108张)，四个人玩(每人27张)，问一个人同时拿到一对大王的概率？2、所知道的排序算法的思想及比较3、百度搜索引擎返回结果1e6条，只显示前十条，这个case下哪个排序算法最好？4、所知道的树结构及其定义5、数据库的索引和B+树的特点6、TCP三次握手和四次挥手7、健康码实现需要的东西？（开放题）8、简历中课程项目的实现、效率以及是否可以优化（C语言大作业——IP地址查询系统）9、算法题给定一个字符串S和有效单词的字典D，请确定可以插入到S中的最小空格数，使得最终的字符串完全由D中的有效单词组成，并输出解。如果没有解则应该输出n/aS = “ilikealibaba”D = [“i”, “like”, “ali”, “liba”, “baba”, “alibaba”]输出“i like alibaba”思路：trie+dfs，代码点这原题：leetcode 单词拆分 一面（4.19） 1、Java线程池2、synchronized锁3、Student类需要什么条件才能作为HashMap或者HashSet的Key？4、HashMap的内部实现5、关键词final finally finalize区别6、JVM7、怎么找到一个Class？8、弱引用、强引用9、数据库三大范式10、索引可能的带来的坏处11、左连接、右连接、全连接12、SQL注入的定义和防止方法13、问了下高等数学的成绩14、进程和线程的区别15、进程间的通信方式16、OSI七层协议17、TCP、UDP的区别18、TCP的三次握手、四次挥手19、大学遇到比较有成就感or有困难的事情？20、除了算法方面主动学习还有其他的吗？21、问了下移动终端编程小项目22、Java是上课教的还是自学的？23、学习过程中给我帮助最大的人或者最佩服或者最想学习的人是谁？（当然是斯巨啦）24、有关注互联网领域前沿的知识吗？25、说说职业规划26、确认工作地点 字节跳动——客户端开发工程师一面（7.1） 1、是否毕业前可以去实习2、保研了吗3、C++虚函数4、vector5、sizeof()6、结构体占字节数计算7、写了两道简单sql8、数据库索引的作用、实现方式9、缺页异常10、分页大小，太大太小会怎样11、操作系统的读写锁12、IP报文头部有啥13、IPv4和IPv6的区别14、https中间人攻击15、https传输过程、利用到的加密16、聊项目（在线写h5不会了）17、最近有去实习过吗18、算法题：返回数组中含最大连续子数组和的子数组 二面（7.3） 1、TCP三次握手、为什么不是四次和两次2、TCP拥塞控制3、TCP协议和HTTP协议的关系4、域名解析过程5、DNS劫持定义、怎么做到的6、https中间人攻击7、二叉树、栈、队列插入查找的效率8、智力题：将[1,1000]映射到[1,100]，要使得数字出现概率和数字大小成正相关，映射尽可能平均（映射最后1的期望出现次数为1，2的期望出现次数为2，…，100的期望出现次数为100）9、算法题（1）cf原题，https://codeforces.ml/contest/1313/problem/A（2）leetcode415 字符串相加 三面（7.9） 1、算法题：计算从一棵多叉树的根节点走N步，能走到节点x的概率，任何一个走过的节点不能走第二次，如果没路可以走可以原地走，如果有路可走，但是步数没用完需要接着走 ​ 1 2 3 45 6 7 8 9N = 2，x = 6ans = 1/6struct Node { int val; vector subNodes}; float func(Node *root, int N, int x){ } 2、Java和C++的区别3、C++的内存管理4、下面obj的空间会被回收吗？delete p会发生什么？p指向的是堆内存还是栈内存？classA obj;classA *p = &obj;p = NULL;5、指针和引用的区别，引用所占字节大小6、读代码，分析输出结果class Base { virtual void f(){ printf(“base”); }}class Sub : public Base{ vitrual void f(){ printf(“sub”); }}Base *p = new Sub();p-&gt;f(); //subBase obj = *p;obj.f(); //basep = &obj;p-&gt;f(); //base7、系统设计设计一个oj功能包括：题库、排名、代码提交运行、运行结果返回给用户(其中各种操作系统、数据库和高并发相关子问题…) 一面（8.12） 1、如果让我学Android，从哪些方向入手2、进程调度算法3、什么是抢占式调度？执行完当前调度的进程后是恢复之前的还是调度别的进程？4、进程通信方式5、共享内存在进程A中还是进程B中？6、信号量的基本操作7、http和https的区别8、https连接过程9、为什么用非对称加密传输对称加密的密钥，对称密钥加密数据传输？10、equals和==的区别11、四种引用12、数据库的连接13、算法题：一个二叉树，m次查询，每次查询p,q两点的最近公共祖先（写了个时间复杂度O(nm)的暴力只过了75%，正解倍增或树剖） 二面（8.12） 1、QUIC协议2、http2.03、C++运算符重载定义和应用场景4、内联函数定义和开销5、内存对齐6、main函数的参数7、C++异常处理8、extern C9、std::move()10、动态链接库的原理11、b+树12、创建索引的sql语句13、什么时候用到索引14、事务15、什么情况下会用到事务16、对客户端的看法17、算法题：leetcode200 岛屿数量leetcode662 二叉树最大宽度 三面（8.14） 1、java引用2、hashmap原理为什么设置链表元素超过8个变为红黑树结构如果是红黑树结构，删除了树上的结点会怎么变化new HashMap(1000)的对象，当放了多少不同元素进去会发生扩容3、synchronized原理，使用方法4、Java中的volatile关键字作用，原理5、GC相关6、浏览器输入url之后的过程7、OSI七层模型和TCP/IP四层模型8、聊项目（说实话没啥聊的，课程项目比较水）项目实现，遇到的问题，怎么解决的，学到了什么9、算法题：由二叉树前序中序遍历结果求后序遍历结果单链表中删除倒数第K个节点 美团——数据开发工程师笔试（8.8） 1、求平均数输出保留一位小数，不四舍五入进位思路：显然%.1f输出就挂了，手动模拟除法就好了2、一个关于优惠券的简单贪心题3、求一个数从根节点到所有节点路径和的和，还有带往返情况的最小的路径和思路：第一个直接dfs记录路径和即可，第二个dfs求出从根节点出发的最长路径，然后用所有边权*2再减掉这个最长路径即为答案，也就是在最长的路径上不回头走4、相邻两个相同的数可以合并，两个x合并后变x+1并放在原位置，问最多可以合并多少次思路：很经典的一个题了，考查栈的应用，用栈模拟即可5、一颗树的每个结点要么黑色要么黄色，求以每个结点为根节点的子树中，所有和根结点不同颜色结点到该结点路径的和思路：直接dfs，对于每个结点先返回当前子树下的黑结点个数、所有黑结点到当前结点路径和、黄结点个数和所有黄结点到当前结点路径和，父结点更新的时候将所有子结点的这四个信息汇总即可，其中结点数直接求和，路径和需要将结点数和路径和一起更新，比如father.cnt0 += sub.cnt0;father.sum0 += sub.sum0+tmp.cnt0; 一面（8.13） 1、对后台、系统开发的看法2、怎么权衡竞赛和专业成绩的3、想用的编程语言4、C++多态实现方法5、虚函数实现多态底层原理6、构造函数可以是虚函数吗7、函数可以返回局部变量吗8、C++内存分布9、define，const，inline，valotile关键字10、用过的Java容器11、HashMap实现原理12、为什么使用红黑树替换链表13、b+树14、IO为什么慢15、ConcurrentHashMap16、锁的类型17、TCP三次握手、四次挥手18、为什么建立需要三次，挥手需要四次19、写代码判断一个字符串是否为合法ip地址（要求一次遍历）；判断一个ip地址是否为一个子网下的ip地址，传参也为字符串；20、设计一个判断ip地址是否在路由器黑名单中算法（黑名单数据百万级，要求快速、省空间）黑名单中有网段怎么处理 二面（8.19） 1、遍历map中的键值对内容。按分别正常输出，key从小到大输出，val从大到小输出2、长度为n的数组，数组每个元素在[0,n-1]内且不重复，问第一个缺失的数字。分别按数组有序情况和无序情况处理3、下一步规划安排4、工作地点5、介绍ACM-ICPC6、最喜欢的一门课程以及原因7、最有挑战的一门课 //kpi工具人 二十分钟草草结束… 哔哩哔哩笔试（8.13） 一、选择题三十道，全是计算机基础题二、编程题1、24点游戏，给4个数，问能否通过加减乘除得到242、括号匹配，有三种括号，问序列是否是正确的3、背包问题，给一个整数n，m个整数（每个数无限用），问用这m个数凑出n最小需要多少个数]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工程经济学 学习笔记]]></title>
    <url>%2Fposts%2Ffa8e3b91.html</url>
    <content type="text"><![CDATA[第一章 绪论 工程与经济的关系：工程是手段，经济是目的 工程师的基本责任：分析成本 第二章 资金的时间价值与现金流量 定义：i 利率 n年数 P现值 F终值 A年金 计息方式 单利：F=P(1+ni)\\ 复利：F=P(1+i)^n 现金流量 CI 现金流入，CO 现金流出现金是价值风险最小的一种资产 复利等值计算 一次支付终值公式：$F=P(1+i)^{n}$一次支付现值公式:$P=F(1+i)^{-n}$年金终值公式:$F=A+A(1+i)+A(1+i)^2+…+A(1+i)^{n-1}=A[(1+i)^{n}-1]／i$偿债基金公式:$A=Fi/[(1+i)^{n}-1]$年金现值公式:$P=A[(1+i)^{n}-1]／\{i(1+i)^{n}\}\quad 永久年金:P=A/i$资金回收公式:$A=Pi(1+i)^{n}/[(1+i)^{n}-1]$名义利率r与实际利率i的换算:$i =(1＋r/m)^m-1 \quad$(m为每年计息次数) 第三章 建设项目评价的基本经济要素 建设项目的投资组成 建设期利息估算某年应计利息 = （年初借款资金累计+当年借款/2）×借款年利率 折旧——固定资产摊销——无形资产 线性折旧法 1.平均年限法年折旧额 = 原值 * 折旧率折旧率 = （1 - 净残值率）/ 折旧年限2.工作量法年折旧额 = 工作量 * 折旧率折旧率 = 原值 *（1 - 净残值率）/ 工作量 经营成本 = 总成本 - 折旧、摊销 - 财务费用= 外购原材料、燃料、动力费 + 工资及福利费 + 修理费 + 其他费用 增值额税 = 销项额税 - 进项额税= 销项额(不含税)* 增值税率 - 进项额(不含税)* 增值税率= [销项额(含税)/(1+增值税率)]* 增值税率 - [进项额(不含税)/(1+增值税率)]* 增值税率 企业所得税的税率为25％所得税 = ( 营业收入 - 总成本 = 营业收入-折旧-摊销-经营成本-财务费用(税收、利息等) )*税率 利润营业利润=营业收入－总成本－营业税及附加利润总额＝营业利润＋投资净收益＋营业外收支净额净利润＝利润总额－所得税 第四章 建设项目经济评价指标体系 投资回收期$Pt = T - 1 + \frac{第T-1年年净现金流累计值的绝对值}{第T年的现金流}$，T为累积净现金流量首次为非负值所对应的年份计算动态回收期将净现金流折算到投资初 期即可评价标准：Pt ≤ Pc(基准回收期) 净现值$NPV = \sum_{t=0}^n NCF_t(P/F,ic,t)$评价标准：NPV≥ 0 内部收益率$\sum_{t=0}^nNCF(1+IRR)^{-t}=0$$IRR =i_1 + \frac{NPV_1}{NPV_1+|NPV_2|}(i_2-i_1)，i_2-i_1&lt;0.05$评价标准：IRR≥ic(社会折现率) 利息备付率ICR = EBIT / PI = 息税前利润 / 计入成本的应付利息EBIT = 净利润 + 计入成本的利息 + 所得税 = 毛利润 + 计入成本的利息评价标准：ICR&gt;2 偿债备付率DSCR = (EBITAD - TAX)/PD = (息税折旧摊销前利润 - 企业所得税额) / 应还本付息金额评价标准：DSCR&gt;1 第五章 多方案的经济性比较和选择A-B 第六章 建设项目融资资本金资金成本 优先股成本 $K_p = \frac{年股利}{筹资额(1-筹资费用率)}$ 普通股成本$K_s = \frac{年股利}{筹资额(1-筹资费用率)} + 普通股利每年预期增长率$$K_s = 无风险投资收益率+投资风险系数(社会平均投资收益率-无风险投资收益率)$ 留存盈余资金成本$K_s = \frac{年股利}{筹资额} + 普通股利每年预期增长率$ 债务资金成本 债券资金成本$K_h = \frac{债券年利息额(1-所得税税率)}{债券的筹资额(1-筹资费用率)}$ 银行借款资金成本$K_h = \frac{债券年利息额(1-所得税税率)}{贷款总额-贷款费用}$ 租赁资金成本$K_L = \frac{年租金额(1-所得税税率)}{租赁资产价值}$ 综合资本成本（加权平均）]]></content>
      <categories>
        <category>专业课程</category>
      </categories>
      <tags>
        <tag>工程经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议分析 学习笔记]]></title>
    <url>%2Fposts%2Fc6770e59.html</url>
    <content type="text"><![CDATA[第一章 TCP/IP概述 什么是Internet？ Network of Networks（网络之网络），连接各个子网的网络 如何将异构网络互联？ 使用IP地址，屏蔽所有物理细节，实现异构网络互联 TCP/IP分层模型及OSI对应关系 多路复用 从源主机的不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层中去 多路分解 在接收端，运输层检查这些字段并标识出接收套接字，然后将该报文定向到该套接字。其工作方式可以简单地认为是这样的，主机上的每个套接字被分配一个端口号，当报文到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字 第二章 点到点协议PPP PPP： Point to Point Protocol PPPoE(PPP over Ethernet)：以太网上的PPP，实际上是两种协议的结合 PPP规定的内容：1）帧格式及成帧方法；2）链路控制协议LCP：用于建立、配置和测试PPP链路的（Link Control Protocol）；3）网络控制协议NCP：用于建立和配置网络层协议（Network Control Protocol）。 使用的认证协议：1）口令认证协议PAP：Password Authentication Protocol；2）基于挑战的握手认证协议CHAP：Challenge Handshake Authentication Protocol。 通信过程 以太网回顾 CSMA/CD：多点接入、载波监听、碰撞检测CA半双工；CD全双工 PPPoE的优点 高带宽；提供用户认证、控制、服务、记账等功能 PPPoE协议流程 发现阶段 发起：客户端通过广播请求以获取可用的AC提供：在收到请求后，若AC可以提供服务，则返回该报文请求：如果客户端收到来自多个AC的应答，则必须从中选择一个并向该AC发出请求确认：收到请求的AC向客户端返回确认，从而建立PPP连接及会话 会话阶段 断开链路 第三章 Internet地址及地址解析1. ARP针对问题 实现IP地址到物理地址之间的映射 2. ARP 命令 参数 含义 -a 列出ARP缓存中的所有条目 -a inet_addr 列出与inet_addr对应的条目 -d inet_addr 删除与inet_addr对应的条目 -s inet_addr eth_addr 在ARP缓存中添加一个条目 3. IP地址分类 类型 标志 范围 网络号长度 适用范围 A 首位比特为“0” 1.0.0.0 - 126.255.255.255 1字节 超级大网 B 前两个比特为“10” 128.0.0.0 - 191.255.255.255 2字节 中规模网络 C 前三个比特为“110” 192.0.0.0 - 223.255.255.255 3字节 小规模网络 D 前四个比特为“1110” 224.0.0.0 - 239.255.255.255 — 组播地址 E 前四个比特为“1111” 240.0.0.0 - 255.255.255.254 — 保留 特殊的IP地址 1）网络地址：标识网络，主机号部分设置为全0 ；2）定向广播地址：标识某个网络中的全部主机，主机号部分为全1 ；3）有限广播地址：用于需要在本地网络上广播，又不知道自己所处网络的情形，形式为255.255.255.255 ；4）回送地址：用于本机进程间的通信或协议软件测试，首字节为127；5）保留地址：192.168.0.0 ~ 192.168.255.255//用于私有内部网络 4. ARP的思想与步骤 思想：广播询问，单播回应 步骤： 发送发以广播方式发送一个ARP请求报文，其中包含接收方的IP地址； 网络上所有主机接受该请求，将其中IP地址与自身IP地址比较，如果相同则向发送方回应，回应包含自己的物理地址，否则不回应。 代理ARP：R代理主机D向A发送ARP应答（两次来回） 安全问题：如何实现ARP劫持？ 嗅探：用以获取网络中的通信数据。共享环境下（广播投递模式）：直接把网卡设置为工作于“混杂（promiscuous）”模式。交换环境下：基于ARP欺骗的嗅探器及会话劫持防范：静态缓存、专门的ARP欺骗防范工具 5. ARP提高通信效率的措施（没有最好，只有最合适） 使用缓存机制捎带机制、入网或更换网卡时广播自己的IP/MAC映射关系软状态：如果在给定的时间段（通常为20分钟）内都没有使用某个物理地址，则相应的记录会被删除。（统计性方法或者类似LRU算法的方法优化） 6.反向地址解析协议RARP 问题：IP地址保存在硬盘里，无盘工作站没有硬盘，怎么办？RARP：放在服务器里。问题：没有IP地址怎么通信？解决：使用物理广播。 第四章 互联网协议IP 引入目的 用IP（Internet Protocol）屏蔽底层物理网络协议差异，实现异构网络互联。 IP协议提供无连接、不保证可靠、尽最大努力的投递机制体现在哪里？ 使用ICMP协议允许路由器或主机报告差错情况和提供有关信息 ，帮IP协议尽最大努力服务。 IP数据报中的分片问题 字段含义 标识：2字节，用于数据报分片及重组，相同的分片此字段值相同 标志：3位，MF为1表示后面还有分片，DF为1表示不能分片 片偏移量：13位，起始地址/8 为什么使用片偏移量，而序列号不行？ 因为永远不知道下一个网络的MTU是多大，可能会继续分片 重组：将若干个分片重新组合还原为原来的数据报，地点在目的主机 分片迟迟不来怎么处理？ 设置定时器防止由于分片丢失造成重组过程无限延长 Ping命令 12345678910111213141516171819202122232425-t Ping 指定的主机，直到停止。 若要查看统计信息并继续操作，请键入 Ctrl+Break； 若要停止，请键入 Ctrl+C。-a 将地址解析为主机名。-n count 要发送的回显请求数。-l size 发送缓冲区大小。-f 在数据包中设置“不分段”标记(仅适用于 IPv4)。-i TTL 生存时间。-v TOS 服务类型(仅适用于 IPv4。该设置已被弃用， 对 IP 标头中的服务类型字段没有任何 影响)。-r count 记录计数跃点的路由(仅适用于 IPv4)。-s count 计数跃点的时间戳(仅适用于 IPv4)。-j host-list 与主机列表一起使用的松散源路由(仅适用于 IPv4)。-k host-list 与主机列表一起使用的严格源路由(仅适用于 IPv4)。-w timeout 等待每次回复的超时时间(毫秒)。-R 同样使用路由标头测试反向路由(仅适用于 IPv6)。 根据 RFC 5095，已弃用此路由标头。 如果使用此标头，某些系统可能丢弃 回显请求。-S srcaddr 要使用的源地址。-c compartment 路由隔离舱标识符。-p Ping Hyper-V 网络虚拟化提供程序地址。-4 强制使用 IPv4。-6 强制使用 IPv6。 两种选路方式 直接选路：源主机和目的主机连接于同一物理网络间接选路：源主机和目的主机不在同一物理网络上选路的基础：路由表 路由表构成 目标网络、子网掩码、网关地址、接口 处理传入的数据报 原则：主机和路由器都要参与选路；仅路由器会转发IP数据报，主机不会转发IP数据报。 第五章 Internet控制报文协议ICMP Internet Control Message Protocol 回送应答报文丢了不会重传。 需解决问题 循环投递问题：可能会耗尽网络资源。TTL可以避免这种后果；分片丢失问题：重组超时时钟可防止重组程序无限期等待；投递失败：选路失败、目的主机关机、目的主机处理数据报失败等情况。 拥塞控制问题：路由器处理能力达到极限时要告诉源端慢点发；选路优化问题：有更好的路径时应通知源端；目的地可达性判断；时钟同步问题。 传递控制信息+提供差错报告=ICMP 原则 ICMP差错报告报文的数据区包括发生差错的IP数据报首部以及数据区的至少前64比特。 仅能向数据报的源端报告差错，不能向中间路由器报告差错。 当携带ICMP差错报文的IP数据报出现差错时，不会再生成ICMP报文。 对于被分片的IP数据报，仅能对第一个分片应用ICMP协议。 差错报告报文分类 目的站不可达报文：当路由器无法转发报文或交付数据时，可使用该报文通知数据报的发送者超时报文：TTL=0或者分片重组超时参数错误报文：当问题严重到必须把数据报丢弃时发送Photuris：用于IPsec 网络控制报文分类 回送请求/回送应答报文：用于测试网络连通性路由器通告/路由器恳求报文：用于一个网络中有多个路由器的场合时戳请求/时戳应答报文：分布式系统时钟同步；估算两台主机之间传输数据报的往返时间 初始时戳：记录发送者生成时戳请求报文的时间$T_i$ ；接收时戳：记录接收者收到请求的时间$T_r$ ；传送时戳：记录接收者生成应答报文的时间$T_t$ ；发送方收到回应的时间$T_h$；传输时延：$D_t = [(T_h - T_i) – (T_t - T_r)]/2$ 第六章 用户数据报协议UDP 提供不可靠、无连接的数据交互服务 报文格式 源端口，目的端口 ，报文长度，校验和（可选），都为2字节 校验和与IP首部校验和的区别 计算方法类似，UDP需要将伪首部被附加在UDP报文首部和数据区之前；IP只检验数据报的首部 ，UDP 将首部和数据部分一起都检验 。 校验和计算方法： ①把伪首部添加到UDP上；②将检验和字段添零；③所有位划分为16位的字； 把所有16位的字相加， 0和0相加是0，0和1相加是1，1和1相加是0但要产生一个进位1，加到下一列。若最高位相加后产生进位，则最后得到的结果要加1 ；④最后和取反。 校验时求和取反为0说明无差错。 端口号的实质：缓存 第七章 传输控制协议TCP 三次握手 注意服务端的序列号不是x+1，而是y。 改进的三次握手 提供半关闭能力：一个方向的连接关闭后，另一个方向的还可以继续使用。 RST的作用 连接双方立即停止传输，关闭连接，并释放所有缓冲区等有关资源。 半开连接检测 服务器发现一条TCP连接上已经很长时间没有传输数据。 解决方案：引入保活定时器（通常2小时）。 提供可靠的数据交付服务 ① 防止丢失的机制：带重传的肯定确认技术如果确认报文丢失， 则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。 ② 防止重复乱序重复原因：确认重传机制造成不必要重传乱序原因：每个报文封装在IP数据报中独立传输解决方案：引入序号，第n+1个报文的序号= 第n个报文的序号+ 第n个报文的长度 传输效率与流量控制滑动窗口思想 第八章 Internet地址扩展技术 透明路由器 广域网和局域网的中转局域网：没有自己的IP前缀外部视图：透明，是一般的主机；内部视图：网关优点：节省IP地址；支持负载均衡缺点：适用有大量地址空间的网络；不提供标准路由器提供的服务；不能完全参与ICMP或IGMP等网络管理协议。 代理ARP 允许一个网络地址由两个物理网络共享，一个主网络，一个隐藏网络。主网络和隐藏网络通信的路由器运行代理ARP 子网编址 思想：把一个网络分成若干个物理网络IP地址 = 网络号+物理地址+主机分类：定长子网划分、变长子网划分定长子网的子网号不能全1是为了方便定向广播，变长子网的子网号可以全1是为了更好利用地址空间。 选路算法 123456789101. 从数据报中提取目的IP地址D,并计算网络前缀N2. if N与任何直连的网络地址匹配 then 通过该网络把数据直接交付到目的地D3. else if 表中含D的特定主机路由 then 把数据报发送到表中指定的下一跳4. else if 表中含到N的路由 then 把数据报发送到表中指定的下一跳5. else if 表中含默认路由 then 把数据报发送到表中指定的下一跳6. else 宣布选路出错 匿名点到点链路 超网编址CIDR 思想：无类型编址，将两个或多个小型网络合并成一个大网络表示方法：最低地址+子网掩码；斜杠表示法优点：分配各种大小地址块时的灵活性 NAT 概念 不需要网点上的每台主机都拥有一个全球有效的IP地址，仅需要网点有一条到Internet的连接，并且至少有一个全球有效的IP地址G。 工作原理 将全球有效地址（或地址段）G分配给把网点连接到Internet上并运行NAT软件的计算机（一般是一台多地址主机或路由器，称为NAT盒，NAT box）。 所有数据报从网点传到Internet或从Internet传到网点时，都要通过NAT盒。 NAT对传入数据报和外发数据报中的地址进行转换，即用G替换每个外发数据报中的源地址，用主机的专用地址替换每个传入数据报的目的地址。 从外部主机的角度来看，所有数据报都来自NAT盒，所有响应也返回到NAT盒；从内部主机的角度来看，NAT盒看上去是一个可达Internet的路由器。 地址转换方式 静态NAT，一对一，出于安全考虑 动态NAT，多对多 网络地址端口转换，多对一，利用了TCP或UDP协议端口号来提供并发性 第九章 路由协议概述 距离向量算法应用协议：RIP，BGP 内部网关协议IGP：在一个自制系统内部使用的路由选择协议，如RIP和OSPF协议 外部网关协议EGP：数据报传到自治系统边界时用到，如BGP 第十章 选路信息协议RIP 工作原理 1)RIP路由器使用UDP进行路由信息交换，知名端口为520；2)请求（request）报文：用来向相邻路由器请求路由信息；3)响应（response）报文：用来向相邻路由器通告本地路由信息；4)使用向量距离路由算法。通告路由信息（目的站地址，距离）；5)采用跳数作为距离度量标准。路由器与直接相连网络的距离为1跳。一个路由器R到目的站的一条路径长度是该路径上所有路由器（包括路由器R在内）的数目，有效范围为1-16，其中16表示网络不可达；6)系统启动时，协议模块在所有配置RIP的接口上发出request报文，并进入循环等待状态，等待相邻路由器的request报文或response报文的到来。相邻路由器收到request报文后，将本地路由信息包含在response报文中，予以应答。每当收到response报文，协议模块将调用向量-距离算法，依次处理其中的每一路由条目；7)每个RIP路由器周期性地向相邻路由器通告本地路由信息，该信息也以response报文传送；8)在实际应用中，RIP路由器分为主动型（Active）和被动型（Passive）两种。主机运行RIP时，只能采用被动方式。 慢收敛问题 画拓扑图说明以下对策 计算到无穷问题：R1检测到网络1已经断开，于是将路径设置为不可达（16），并向R2通告该信息；R2也会向R1通告该信息。情形1：在收到R2的通知前，R1已经将信息通报出去，这是理想的情况；情形2：在R1通告前，R2的更新报文已到达，这就坏了…… 简单分割范围法：当路由器向一个接口发送路由更新报文时，其中不包含从该接口获取的路径信息。 带毒性逆转的分割范围法：当路由器向一个接口发送路由更新报文时，如果某个条目是通过该接口获得的，则将该条目的距离设置为无穷大。 抑制法：所有路由器在收到某个网络不可达的消息后，将相应表项的距离值置为16，并将此信息保留一段时间（坏消息保留时间默认60秒）。 触发更新法：一旦发现网络连接消失，就将该网络设置为不可达，并立即发送路由更新报文，而不等待正常的路由更新周期时间到。 第十一章 开放式最短路径优先OSPF 区域的概念 区域包括路由器和网络，用一个编号标识。每个AS都有一个骨干区域，编号为0。所有非骨干区域都与骨干区域相连。每个区域内的路由器相互通告链路状态，维护本区域内的链路状态数据库；同一自治系统中的各区域之间只交换经过汇总的路由信息。非骨干区域之间不能直接进行路由信息交互，它们之间的路由信息分发由骨干区域负责。这种体系结构不仅使得路由维护高效，而且可以隐藏区域内的网络拓扑结构，有利于提高网络安全性。 路由器分类（1）内部路由器（IR）：一个路由器所有直接相连的网络都在同一区域，同一区域内的各内部路由器有着相同的链路状态数据库。（2）区域边界路由器（ABR）：一个路由器的接口位于多个区域。ABR拥有所连每个区域的链路状态数据库，并将其中的信息进行汇总，发送到骨干区域，后者再将这些信息分发到其它区域。（3）骨干路由器（BR）：一个路由器至少有一个接口位于骨干区域，所有ABR和骨干区域中的IR都是骨干路由器。（4）自治系统边界路由器（ASBR）：负责与其它自治系统交换路由信息。它位于骨干区域，将本自治系统的路由信息向其它自治系统通告，也向整个自治系统通告所得到的自治系统外部的路由信息。自治系统内的所有路由器都知道通往ASBR的路径。 区域分类（骨干和非骨干） “桩”的引入：减少计算开销。桩域：仅接受默认路由和汇总LSA，不接受AS外部链路，不包含ASBR的非骨干区域都可以配置为桩域； 第十二章 边界网关协议BGP 用于AS之间进行路由信息交换 基本原理通过相邻AS之间交换路由信息，使得每个AS都拥有一个AS级的Internet连通图。两个相邻AS之间交换路由信息时，要选择相邻的BGP路由器作为发言人（Speaker）。每个发言人向外通告经过聚类后的可达性路由信息，以降低路由表规模和隐藏网络拓扑结构。这些信息可能是关于其AS内部的，也可能来自其它AS。BGP使用来表示一条路由信息，为跨越AS的数据报传递确定路径。 基于TCP，使用端口号179 第十三章 Internet组播 使用D类地址，前四位1110 永久分配地址：用于Internet上的主要服务及基础设施的维护。临时使用地址：需要时创建，当组成员数为0时予以丢弃。 群组管理协议IGMP 功能：成员加入退出群组，判断群组中是否还有组成员。 分级 0 主机不能发送也不能接收组播数据报 1 主机能发送但不能接收组播数据报 2 主机既能发送也能接收组播数据报 管理 当主机要加入一个群组时，必须向本地组播路由器发送IGMP报文，其中包含该群组的地址，以宣布其成员状态；组播路由器收到报文后，向互联网上的其它组播路由器传播该信息以建立必要的路由。组播路由器周期性地轮询本地网络上的主机，以确定现在各个群组中有哪些主机。如果经过若干次轮询后，某个群组中始终没有主机应答，则组播路由器就认为本地网络中不再有该群组的成员，并停止向其它组播路由器通告该群组的成员信息。 管理为什么使用轮询不用广播？ 使用广播的话，主机可能不应答，避免了广播风暴；轮询更有利于安全性；IGMP是不紧急的事件，允许一定时延 第十四章 移动IP 主机在变换网络后，仍能以原来的IP地址与Internet上的其它主机进行通信。 特点透明性；互操作性；安全性；宏安全性 两个IP地址 1) 家乡地址：家乡网络给MH分配的固定地址，在移动过程中保持不变，被主机的应用程序和传输层使用；2) 转交地址：外地网络给MH分配的临时地址，随MH的移动而改变。 第十五章 应用层系统服务 自举协议BOOTH 解决无盘工作站获取IP地址、网关、掩码、域名服务器等信息的问题。基于UDP，使用端口号67 Q：没有自己的IP地址，怎么通信？A：使用有限广播，源IP地址字段设置为全0。 Q：客户端不知道自己的IP地址，也没有IP/MAC映射关系，怎么办？A：（1）在收到BOOTP请求后，服务器就把其中包含的物理地址及相应的IP地址写入ARP缓存，随后使用单播方式发送；（2）广播响应，响应中包含客户端硬件地址。 Q：什么是冷备份、热备份？优缺点是什么？A： 冷备份：先关闭数据库停止使用，再执行备份的方式；优点是简单快速、容易恢复到某个时间点、方便维护；缺点是只能恢复到某个时间点、备份期间数据不便正常使用。热备份：指执行备份时不影响备份文档正常使用的方式；优点是备份速度快、不影响数据使用；缺点是所有操作都会同步，包括删除。 动态主机配置协议DHCP 工作原理：设置DHCP服务器，客户端请求服务器给自己分配IP地址。配置方式：手工配置，即管理员可以为特定的计算机配置一个永久IP地址；自动配置，即为某个第一次上网的计算机分配一个永久地址；动态配置，即为上网的计算机分配一个临时地址。 域名系统DNS 作用：IP地址不方便记忆，给Internet上的主机起个便于记忆的名字，同时解决名字到IP地址的映射问题 两个要素：抽象要素，指明了名字语法和名字的授权管理规则；具体要素，指明了将名字映射到IP地址的具体方法。 域名解析过程：客户端/服务器模型 DNS既可以基于TCP，也可以基于UDP，服务器则使用知名端口53。核心：数据传输量少，可靠性要求低的时候用UDP；否则用TCP。 DNS欺骗：恶意攻击者改变DNS响应并把解析结果指向自己可控的主机 域名前加www.的作用？ 标识这是一个需要用浏览器来访问的网页服务 域名和IP地址的映射关系是一对多还是多对多？为什么？ 多对多；一个域名可以对应多个ip， 根据请求的位置和运营商返回不同的解析结果，比如负载均衡应用；一个ip也可以指向多个域名，比如购买的虚拟主机。 第十六章 网络管理标准SNMP 网络管理需求 FCAPS1）故障管理（Fault Management）：用于检测、定位和排除网络硬件和软件中的故障。出现故障时，要能够确认故障、记录故障，找出故障位置并尽可能排除。2.）配置管理（Configuration Management）：掌握和控制网络的运行状态，包括网络内部设备的状态及其连接关系。3）帐务管理（Account Management）：度量各个终端用户和应用程序对网络资源的使用情况，按照一定标准计算费用并进行保存。4） 性能管理（Performance Management）：考虑的是网络运行的好坏。性能需要用一些指标来衡量，比如：吞吐率、响应时间等。 5）安全管理（Security Management）：对网络资源及重要信息进行访问约束控制。 SNMP的3个组件 MIB：Management Information Base，管理信息库，定义了管理对象的全集；SNMP通信协议：定义了实施网络管理时的通信规约；SMI：Structure of Management Information，管理信息结构，定义了管理对象和传输报文的标准语法。 MIB = 对象+实例 SNMP规定的内容：访问控制机制、通信规约、报文格式 基于UDP，使用端口161（被管者）和162（管理者） 第十七章 万维网与电子邮件系统 WWW World Wide Web，万维网组成：大量Web页面，每个页面是一个超媒体（hypermedia） URL：Universal Resource Locator，统一资源定位符，每个页面唯一的标识 HTTP HyperText Transfer Protocol，超文本传输协议，基于TCP，80端口客户端/服务器模型。页面存储于服务器，客户端通过HTTP向服务器请求页面 请求方式：GET：读取页面或向某个页面附加资源，体现在URL中。POST：向某个页面附加资源，体现在HTTP的消息主体中HEAD：请求读取某个Web页面的头部；可用于测试URL的有效性和搜索引擎CGI：Common Gateway Interface，公共网关接口，用于连接WWW和数据库的接口脚本或程序，通常放在cgi-bin目录下；动态创建页面表单：用于将数据从浏览器传递给服务器，提交时参数和数据都传递 非持久连接：客户端与服务器建立连接，获取页面，之后关闭连接。持久连接：一旦客户端与服务器建立了TCP连接，就可以在这个请求上发送多次请求并接收响应，等所有请求都发送完成后再关闭连接。流水线技术：在响应到来之前就可以发送下一个请求。问题：如何分隔每个请求？解答：发送数据前加入相应长度。 服务器驱动协商方式：浏览器首先发出协商请求，指定一系列选项值及URL；服务器收到请求后，从中选取满足浏览器需求的一项。如果有多项符合条件，则服务器选取优先级最高的一项。浏览器驱动协商方式：浏览器向服务器发送请求，询问可用的内容。服务器返回可能的内容列表。浏览器之后从中选取一项，发送第二个请求获得该数据项。 代理服务器：浏览器和服务器的中介，提高通信效率，减轻服务器负担。浏览器：使用代理服务器可以绕过某些限制。高速缓存：代理服务器设置，缓存页面，不必每次都到服务器取。 报文格式：字符串，包括开始行、首部行、实体主体。首部和实体之间间隔一个空行。 HTTP1问题：只允许一次发送个请求。解决：使用多条链接来并行发送网站请求。HTTP2特点：引入多路复用（Multiplexing）技术来解决请求数量受限的问题，允许同时通过单一的HTTP2连接发起多重的请求-响应消息。 电子邮件系统 MIMIE（Multipurpose Internet Mail Extensions，多用途互联网邮件扩充）解决的问题：让邮件可以发送各种格式的附件 SMTP：发送邮件的协议；使用客户端/服务器模型；基于TCP，使用知名端口号25；定义了14条命令21种应答。 POP：Post Office Protocol，用于接收邮件。使用客户端/服务器模型，基于TCP，使用知名端口号110；用户从邮箱中读取邮件时，会把邮件下载到本地保存，之后服务器会把邮件删除掉。 IMAP：Internet Mail Access Protocol，用于接收邮件。使用客户端/服务器模型，基于TCP，使用知名端口号143 ；对远程邮箱的管理和操作功能更强大，且用IMAP读邮件时，本地并不保存该邮件，在用户明确地发出删除命令之前，服务器都不会删除这个邮件。]]></content>
      <categories>
        <category>专业课程</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理 学习笔记]]></title>
    <url>%2Fposts%2F4ff37aa6.html</url>
    <content type="text"><![CDATA[第一章 数字图像基础 数字图像的概念（理解） 数字图像用二维的亮度函数 f(x,y) 表示，函数值与对应点的光强成正比。其中数字化的空间位置称为像素（Pixel），数字化的亮度值称为灰度值，表示数字图像的二维矩阵N*M为空间分辨率。 数字图像的多样性（理解） 成像类型多样：反射成像是由物体表面反射的电磁波到达成像传感器而成像；发光成像是物体本身辐射的电磁波到达成像传感器而成像；吸收成像是由于一部分透过物体的电磁波到达成像传感器而成像 尺度多样：日常观察物体或场景$1～10^3$; 天文望远镜$&gt;10^{30}$；电子显微镜$&lt;10^{-10}$ 根据图像数据量的分类（理解） 二值图像：每一个像素仅占用1位，灰度值为0或1，其中，0表示黑色，1表示白色 灰度图像：黑与白之间有多级灰色深度，通常灰度级有2^8=256个 索引图像：包含颜色查找表，通过查找映射的方法表示彩色图像的颜色，其中颜色查找表有三维分别代表R,G,B的颜色分量 图像数字化（掌握） 概念：自然场景的空间位置和辐射度都是连续量，将连续（模拟）信号转变为离散（数字）信号的转换过程 过程： 采样：对空间坐标(x,y)的离散化，决定了空间分辨率；空间分辨率越低，可辨细节越差 量化：对亮度值f(x,y)的离散化，决定了灰度级分辨率 对于细节相对丰富的图像：空间分辨率对图像质量影响大，而灰度级分辨率对图像质量影响小 对于灰度相对平坦的图像：灰度级分辨率对图像质量影响大，而空间分辨率对图像质量影响小 数字图像的常见失真类型（理解） 混叠效应当采样间隔过大时，由于采样频率小于奈奎斯特频率，而引起频谱的高频成分发生相互交叠，频谱重叠导致失真 模糊效应长时间曝光过程中成像设备与成像场景的相对运动而造成运动模糊；光学镜头散焦、大气湍流、短时间曝光而造成散焦模糊。 块效应在相邻块之间引入的非连续性，视觉上看似马赛克的效果。块效应产生的原因：对图像分块处理而引起的块状失真。在图像压缩编码中，分块离散余弦变换编码和分块运动补偿是造成块效应的两个主要原因。 噪声感光器件接收光信号并输出的过程中产生的异常像素。根据噪声的分布和统计特征，成像系统的噪声源可以分为光电散粒噪声、读出噪声和脉冲噪声等 第二章 数字图像处理基础 数字图像处理的关键阶段（了解） 图像获取、图像增强、图像恢复、形态学处理、图像分割、表示与描述、目标识别 图像压缩、彩色图像处理 像素的空间关系（理解） 邻域： 4邻域：UDLR4个 对角邻域 ：对角4个 8邻域 ：周围8个 邻接的两个必要条件： 两个像素的位置在某种情况下是否相邻(4邻接、8邻接) 两个像素的值是否满足某种相似性 连通的必要条件：设 p 和 q 是某一图像子集 S 中的两个像素，若存在一条完全由 S 中的像素组成的从 p 到 q 的通路，则称像素 p 和 q 是连通的(4连通、8连通) 区域：设 p为某一图像子集 S 中的一个像素，若像素 p 的某一邻域包含于 S 中则称像素 p 为 S 的内点，若 S 中的像素都是内点，则 S 称为开集，连通的开集称为开区域，简称为区域 边界：若像素 p 的任意邻域内有属于 S 的像素也有不属于 S 的像素，则像素 p 称为 S 的边界像素。 S 的边界像素的全体称为 S 的边界 距离度量： 像素在空间上的近邻程度可以用像素之间的距离来度量 若三个像素满足(正定性：两点之间距离大于等于0) (对称性：距离与方向无关) (三角不等式：两点之间直线距离最短)三个条件，则称d( *,* )为距离函数 1范数(曼哈顿距离、菱形) ；2范数(欧几里得距离、圆形)；3范数(切比雪夫距离、正方形) 第三章 空域图像增强 背景知识（了解） 图像增强：通过对图像的处理，使图像处理更适合一个特定的应用 空域图像增强：点处理和邻域处理 直方图（掌握） 概念：对于每个灰度值、求出在图像中具有该灰度值的像素数或概率(灰度直方图、概率直方图) matlab函数：imhist(I) 性质：只能反映该图像中不同灰度值出现的频数，不能表示出像素的空间位置等其他信息；不同图像可能具有同样的直方图，图像与直方图之间是多对一的映射关系；直方图是总体灰度的概念；直方图可叠加性 累计直方图：是概率直方图 $P(r_k)$ 关于灰度级 $r_k$ 的累积概率分布(注意暗图像、亮图像、低对比度和高对比度图像各自特点) 灰度级变换（理解） 将灰度级r映射到灰度级s； 对数变换：压缩图像中较亮区域的动态范围；应用是傅里叶谱的显示； 指数变换：在照度-反射模型中可对图像进行反变换；应用是对数变换的对消； 幂次变换：幂1,增亮降暗； 灰度反转：突出在大片黑色区域中的白色或灰色细节； 阈值增强：生成一幅高对比度的图像；软阈值，硬阈值。 直方图处理 基础理论（理解）：点处理方法，通过对灰度直方图进行变换有效地实现图像增强 直方图均衡化（掌握）：将直方图的灰度级概率分布变换为均匀分布 matlab函数：J = histeq(I) 通常新直方图分布比原直方图分布疏散，$S_k$的级数比$r_k$少 算术运算（掌握） 图像相加：对同一场景的多幅序列图像求取平均值，降低加性随机噪声；将一幅图像叠加到另一幅图像上，实现二次曝光效果 图像相减：显示两幅图像的差异，检测同一场景两幅图像之间的变化；图像分割（背景减除法） 空域滤波（理解） 基本概念 空域滤波是一种邻域处理方法，通过直接在图像空间中对邻域内像素进行处理 作用域：像素及其邻域 空域滤波通常使用空域模板进行的图像处理，模板本身被称为空域滤波器 目的： 达到平滑或锐化图像的作用 空域滤波器分类 图像平滑的作用：模糊、降低噪声 图像空域平滑分类： 线性平滑滤波 特征：权系数全为正值；系数之和等于1，不会增加总体灰度程度 均值平滑(加权系数平均)、加权平均模板(加权系数中大边小) 统计排序平滑滤波 中值滤波：区域内像素排序后取中值；去噪同时保留了边缘和细节，对滤除脉冲噪声(椒盐噪声)非常有效 选取领域内最大(小)值-最大(小)值滤波 双边滤波（理解） 非线性滤波 权系数由空域和值域平滑函数的乘积给出 随着与中心像素的距离和灰度差值的增大，邻域像素的权系数逐渐减小 双边滤波很好地保持图像的边缘；平滑低对比度变化的细节特征，包括噪声；值域尺度越小，则边缘保持越好 图像锐化（掌握） 作用：增强图像中的边缘和细节， 如边缘增强；减弱或清除灰度变化缓慢的区域，如边缘检测 差分近似偏导数，差分算子的响应程度与图像在该点灰度值的突变程度有关，图像锐化使用差分算子 一阶差分特点：在边缘处有一个强的响应，形成一个峰；一阶差分算子用于边缘检测 二阶差分特点：在边缘过零点，在过零点两侧，分别形成一个峰和一个谷；二阶差分算子用于边缘增强 [#]Sobel算子 [#]拉普拉斯算子 第五章 频域图像增强 滤波基础（理解） 卷积定理是空间域滤波和频率域滤波之间的纽带。 频率平面与图像空域特性的关系： 图像变化平缓的部分靠近频率平面的圆心，这个区域为低频区域 图像中的边、噪声、变化陡峻的部分，以放射方向离开频率平面的圆心，这个区域为高频区域 为什么要在频率域研究图像增强？ 可以利用频率成分和图像表观之间的对应关系。一些在空间域表述困难的增强任务，在频率域中变得非常简单 滤波在频率域更为直观，它可以解释空间域滤波的某些性质 可以在频率域指定滤波器，做逆变换，然后在空间域使用结果滤波器作为空间域滤波器的指导 频域滤波的基本流程：空域-&gt;频域；频域滤波；频域-&gt;空域 低通滤波器（理解） 概念：允许图像的低频成分通过，限制高频成分通过；低通滤波器和空域中的平滑模板具有等效的作用 振铃效应：在图像灰度剧烈变化的邻域产生灰度振荡的图像失真现象 理想低通滤波器：完全截断频谱中的高频成分；锐截止频率不能用电子器件实现，且会产生振铃效应，表现为在图像灰度剧烈变化的邻域产生灰度振荡；非常不实用，但是原理简单 巴特沃斯低通滤波器：物理可实现；通带与阻带之间并非锐截止而是逐渐下降为零，通带到阻带之间平滑过渡，因而滤波图像的振铃效应不明显；随着阶数增加，振铃效应越明显 指数低通滤波器：物理可实现；一阶二阶都没有振铃效应；随着阶数的增加，接近理想低通滤波器，振铃现象越明显 高通滤波器（理解） 概念：允许图像的高频成分通过，而限制低频成分通过；限制或减弱频谱中的低频成分可以起到图像锐化的作用 理想高通滤波器：无法用电子器件实现的，且会产生明显的振铃效应；随着截止频率的增大，被滤除的低频成分越多，边缘、细节逐渐突出；存在振铃效应，截止频率为15和30的振铃效应在图像上体现为边缘产生重影。随着截止频率的进一步增大，振铃效应应趋于增强，但是允许通过的高频也进一步减少，边缘逐渐细化，振铃效应反而不明显 巴特沃斯高通滤波器：物理可实现；如同二阶巴特沃斯低通滤波器，二阶巴特沃斯高通滤波器的传递函数在阻带与通带之间不是锐截止，是平滑的过渡，使滤波器具有良好的性能；随着截止频率的增大，被滤除的低频成分越多，边缘更加清晰化 指数高通滤波器：物理可实现；如同高斯低通滤波器，高斯高通滤波器的传递函数在阻带与通带之间平滑的过渡，使滤波器具有良好的性能；随着截止频率增加，被滤除的低频成分越多，边缘更加清晰化；相同截止频率的指数高通滤波器比巴特沃斯高通滤波器允许更多的低频成分通过，保留了更多的背景基调 带通、带阻与陷波滤波器（理解） 带通滤波器：允许一定频带的信号通过，用于抑制低于或高于该频带的信号、噪声干扰 带阻滤波器：与带通滤波器执行相反的操作；带阻滤波器限制某一带宽范围的频率成分通过，而允许带宽范围以外的频率成分通过 陷波滤波器：一种窄阻带的带阻滤波器；限制某一中心频率邻域内的频率成分通过，而允许其他频率成分通过 空滤滤波与频率滤波的对应关系（理解） 频域滤波器的传递函数和空域冲激响应函数互为傅里叶变换对 通过分析频域特性「主要是幅度特性」来分析空域模板的作用；借助频域滤波器的设计来指导空域模板 在频域图像增强中，利用频率成分和图像内容之间的对应关系，主观判断指定频域滤波器。一些直接在空域中表述困难的增强任务，在频域中变得直观 空域模板的作用可以通过分析其频域特性而知 第八章 数学形态图像处理 背景（了解） 数学形态学的概念：数学形态学是一种基于形状的图像处理理论和方法，数学形态学图像处理的基本思想是选择具有一定尺寸和形状的结构元素度量，并提取图像中相关形状结构的图像分量，以达到对图像分析和识别的目的 基础（理解） 集合运算：并集、交集、差集、补集、映射、平移 逻辑运算：与、或、非 结构元素：是一个由0值和1值组成的矩阵；每一个结构元素有一个原点，结构元素中的原点指定待处理像素的位置；结构元素中的1值定义了结构元素的邻域，输出图像中对应原点的值建立在输入图像中相应像素及其邻域像素比较的基础上 二值图像形态学基本运算（掌握） 膨胀：$A \oplus B$，在图像中目标边界周围增添像素；结构元素对集合膨胀生成的集合是 B 的映射平移集合与集合 A 相交至少有一个非零元素时 B 的原点位置的集合 腐蚀：$A \ominus B$，移除图像中目标边界的像素；结构元素 B 对集合 A 腐蚀生成的集合是 B 的平移集合完全包含在集合 A 中时，B 的原点位置的集合 开运算：$A \circ B$，先腐蚀后膨胀；能消除小尺寸的目标和细小的突出部分，断开细小的桥接部分而分离目标区域、并在不明显改变目标区域面积的条件下平滑较大目标边界的作用 闭运算：$A \bullet B$，先膨胀后腐蚀；能填补目标区域内部小尺寸的孔洞和细窄的缺口、桥接狭窄的断裂部分而使目标区域连通、并在不明显改变目标区域面积的条件下平滑较大目标边界的作用 击中击不中运算：$A \otimes B$，定义在交集为空集的两个结构元素的膨胀和腐蚀运算的基础上；当且仅当 B1 平移某一z值包含在集合 A 的内部「即 B1 击中 A 」，且 B2 平移同一z值包含在集合 A 的外部「即 B2 击不中 A 」，这两个条件同时成立时，B 的原点位置的集合 二值图像形态学实用算法（掌握） 去噪：先开运算后闭运算 边界提取：$ \beta(A)=A-(A \ominus B)$ 空洞填充：利用膨胀不断将由连通的边界包围的背景区域构成目标区域 二值图像形态学运算及其性质总结（理解） 灰度图像形态学算法（了解） 灰度膨胀 灰度腐蚀 灰度开运算 灰度闭运算 第九章 图像分割 图像分割基础（理解） 概念：将图像划分为若干有意义的区域或部分，或者从图像中提取感兴趣目标的图像处理技术 基本策略：根据特征（灰度、颜色、纹理等）； 图像各区域表现为不连续性（边缘检测）和相似性（阈值处理、区域生长） 图像抠图和图像分割的区别：图像抠图是指从一幅图像中尽可能完整地提取出感兴趣的目标；图像分割只是将一幅图像中的前景（目标）从背景中分离出来 基于边界的分割 边缘的定义（理解）：图像中灰度发生突变或不连续的微小区域（一组相连的像素集合），即是两个具有相对不同灰度值特性的区域的分界线。有方向和幅度两个特性。 一阶差分算子（掌握） 二阶差分算子（掌握） … 不同边缘检测算子间的比较（掌握） 梯度算子 Roberts算子利用一阶差分检测边缘，边缘定位精度较高，但抑制噪声能力较差，适用于陡峭边缘且信噪比高的图像。 Sobel与Prewitt算子等效于首先对图像进行加权平滑处理，然后再计算差分，因此，对噪声有一定的抑制能力，但检测出的边缘具有一定宽度，且不能形成闭合、连通的轮廓。 二阶差分算子拉普拉斯算子对噪声非常敏感，不适合直接用于边缘检测。LoG算子克服了拉普拉斯算子抗噪能力差的弱点，并能产生闭合、连通的轮廓，但在抑制噪声的同时也模糊了边缘，从而造成弱边缘漏检。Canny算子可以形成闭合、连通且单像素宽度的边缘，但也会产生类似意大利式细面条盘子效应的虚假边缘 基于阈值的图像分割 原理：通过设定不同的阈值，将图像中的像素分为两类或多类，具有计算简单、容易实现的优点；阈值的选取决定了阈值分割的效果，阈值法的关键是如何选择合适的阈值 特点：适用于目标与背景在灰度上有较强对比度，且目标或背景的灰度比较单一的图像；这种方法总可以得到封闭且连通区域的边界 分类：全局阈值法——利用全局信息对整幅图像求出最优分割阈值，可以是单一或多个阈值；局部阈值法——将整幅图像划分为若干区域，再对各个区域使用全局阈值法分别求出最优分割阈值 P参数法、梯度直方图、灰度-梯度二维直方图、多阈值法（理解）Otsu阈值法、迭代阈值法（掌握） 基于区域的图像分割 区域生长法（掌握）区域分裂合并法（理解） 第十章 小波变换与多分辨率分析 二维离散小波变换（ 2D-DWT）的背景（了解） 含噪图像噪声明显, 去噪图像中噪声被显著抑制；去噪过程, “黑匣子”处理含噪图像, 获得“黑匣子”图像； “黑匣子”是去噪的核心部分, “黑匣子”图像经后续处理得去噪图像；此“黑匣子”即小波变换 小波变换全称为离散小波变换；小波变换能集中信号能量、去信号相关性；针对图像的小波变换为二维小波变换；二维小波变换对应的英文名为2D-DWT，2D Discrete Wavelet Transform 二维离散小波变换（ 2D-DWT）的效果（理解） 经过一级DWT变换(正变换)，原始图像被分解为四个子图：低频A1，以及三个高频H1,V1,D1. 四子图的大小为原始图像的1/4；由DWT子图可还原出原始图像, 此过程称为逆变换；前述图像去噪, 黑匣子为正变换, 后续处理包括逆变换和其它操作 二级DWT通过分解一级DWT的低频子图A1实现；三级DWT通过分解二级DWT的低频子图A2实现；更高级DWT的分解类似完成 二维离散小波变换（ 2D-DWT）的原理（理解） 先处理原始图像的每一行每一行为1D信号(矢量)，变换后得到两个部分，长度均为1D信号的1/2逐行变换后，得行变换子图 后处理行变换子图的每一列每一列为1D信号(矢量)，变换后得到两个部分，长度均为1D信号的1/2逐列变换后，得列变换子图，亦即DWT子图 一维离散小波变换（ 1D-DWT）的效果（掌握） 一维离散小波变换（ 1D-DWT）的原理（掌握）]]></content>
      <categories>
        <category>专业课程</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通信原理 学习笔记]]></title>
    <url>%2Fposts%2Fb5fbac7e.html</url>
    <content type="text"><![CDATA[第一章 绪论 模拟信号与数字信号的区别(给定信号，要求能够区分) 模拟信号：载荷消息的信号参量取值连续（不可数、无穷多），如电话机输出的语音信号，其电压瞬时值随时间连续变化。也称为连续信号，连续是指信号载荷的消息的常量连续变化，在某一取值范围内可以取无穷多个值，而不一定要在时间上连续。 数字信号：载荷消息的信号参量只有有限个取值，如电报机、计算机输出的信号。 通信系统的一般模型 ① 一般模型 信源：把消息变为原始电信号(基带信号) 发送设备：信号变换、放大、滤波、编码和调制等过程 信道：传输媒介 接收设备：信号放大、译码、解调等 信宿：把原始电信号变为消息 ② 模拟通信模型 调制器：基带信号变换为已调信号(带通信号) ③ 数字通信模型 信源编码与译码：提高信息传输有效性；完成模/数(A/D)转换 信道编码与译码：加入监督码元，提高通信系统可靠性 加密与解密：提高安全性 调制：使信号适应信道的特性 同步：使收发两端的信号在时间上保持步调一直一致 数字通信的特点 优点：抗干扰能力强，噪声不积累；传输差错可控；便于数字信息的处理、变换、储存；易于集成，使通信设备轻量化；易于加密且保密性好 缺点：可能需要较大的传输带宽；对同步要求高，系统设备复杂 信息及其度量 ①信息量 ，其中a=e时,单位为奈特(nit)；a=10时,单位为哈特莱(Hartly)；a=2时,单位为比特(bit,b) I = log_a\frac{1}{P(x)} = -log_aP(x)②平均信息量(熵)，等概率时，$H_{max}=log_2M$；M代表符号集合大小 H(x)=-\sum_{i=1}^{M}P(x_i)log_2P(x_i) (b/符号)③总信息量，n代表符号数 I=n*H(x) 通信系统的两个性能指标 ①有效性 模拟通信系统看传输同样信源信号所需带宽，其越小频带利用率越高，有效性越好 数字通信系统 R_B(码元传输速率，波特率) = \frac{1}{T_B(码元持续时间,码元宽度)} (Baud) R_b(信息传输速率,比特率) = R_B*log_2M(b/s) 频带利用率\eta = \frac{R_B}{B}(Baud/Hz) 或 \eta_b = \frac{R_b}{B}(b/(s*Hz))②可靠性 误码率 P_e = \frac{错误码元数}{传输总码元数} 误信率P_b = \frac{错误比特数}{传输总比特数}在二进制中，$P_b=P_e$；M进制中，$P_b&lt;P_e$ 第二章 确知信号 单位门函数频谱密度 ：$ \tau Sa(\pi f \tau )$ 单位冲激函数的特点（$ \delta $函数的性质） ①可用抽样函数的极限表示 \delta(t) = \lim_{k\to \infty}\frac{k}{\pi}Sa(kt)② f(t_0)=\int_{-\infty}^{\infty}f(t)\delta(t-t_0)dt③可以看做单位阶跃函数的导数 u(t) =\begin{cases}0, & t0 \end{cases};u'(t)=\delta(t) 第三章 随机过程 什么是随机过程？ ①随机试验的全体样本函数的集合 ②在时间进程中处于不同时刻的随机变量的集合 兼有随机变量和时间函数的特点。 什么是平稳随机过程？ 狭义平稳(严平稳)；随机过程的统计特性与时间起点无关，即时间平移不影响其任何统计特性，则称该随机过程是在严格意义下的平稳随机过程，简称严平稳随机过程。 广义平稳：①均值与t无关，为常数a；②自相关函数只与时间间t2-t1有关 严平稳随机过程必定是广义平稳过程，反之不一定成立。 什么是各态历经性？ 含义：随机过程中任一次实现都经历了随机过程的所有可能状态。 意义：过程的统计平均值和样本的时间平均值相同，可用一次实现的”时间平均“取代过程的”统计平均“，使测量和计算的问题大大简化。 具有各态历经性的随机过程一定是平稳过程，反之不一定成立。 平稳随机过程通过线性系统（输出均值、功率谱密度） 输出均值：$E = a * H(0)$ ，H(0)为线性系统在f=0处的频率响应，即直流增益 功率谱密度：$P_o(f) = P_i(f) * |H(f)|^2$，输入过程的功率谱密度乘以系统频率响应模值的平方 窄带过程的两种表示方法 and 结论1,2 表达式1：包络-相位形式 \xi(t) = a_{\xi}(t)cos[w_ct+\varphi_{\xi}(t)]，a_{\xi}\ge0表达式2：同相-正交形式 \xi(t) = \xi_c(t)cosw_ct - \xi_s(t)sinw_ct其中$\xi_c(t)$为同相分量 ，$\xi_s(t)$为正交分量 结论1：对于均值为0，方差为$\sigma_{\xi}^2$的平稳高斯窄带过程，其同相分量和正交分量也是平稳高斯过程；均值皆为0，方差等于为 $\sigma_{\xi}^2$，且两者在同一时刻的取值是互不相关的和统计独立的（因为是高斯过程）。 结论2：对于均值为0，方差为$\sigma_{\xi}^2$的平稳高斯窄带过程，其包络和相位的一维分布分别为瑞利分布和均匀分布，且两者统计独立。 第四章 信道 信道的分类 按照传输媒介分类 有线信道：明线、对称电缆、同轴电缆及光纤等； 无线信道：可以传输电磁波(包括光波)的空间；传输方式有地波、天波和视线传播三种。 按信道特性分类 恒定参量信道：信道特性参数随时间缓变或不变； 随机参量信道：信道特性参数随时间随机变化； 多径效应 多径传播：①信号的衰减随时间而变②信号的传输时延随时间而变③信号经过几条路径到达接收端，且每条路径的时延和衰减都随时间而变。 多径传播对信号的影响称为多径效应。 频率选择性衰弱 衰弱与信号频率及相对时延差有关，当发送信号具有一定频带宽度时，多径传播会导致信号中某些频率成分发生严重的随机性衰弱。 连续信道容量的表达式 B(带宽Hz)、S(信号平均功率W)、N(噪声功率W)、n0(噪声功率谱密度W/Hz) C_t = Blog_2(1+\frac{S}{N})=Blog_2(1+\frac{S}{n_0B}) 第五章 模拟调制系统 调制的目的和作用 将基带信号转换成适合在信道中传输的已调信号，提高发射效率；实现信道的多路复用，以提高信道利用率；扩展信号带宽，提高系统抗干扰能力。 线性调制有哪一些？为什么称为线性调制？ 调幅(AM)、双边带(DSB)、单边带(SSB)、残留边带(VSB) 在频谱结构上，幅度已调信号的频谱完全是基带信号在频域内的简单搬移，由于这种搬移是线性的，因此幅度调制又称为线性调制。 单边带调制实现的两种方法 滤波法、相移法 调频信号的带宽 B_{FM}=2(m_f+1)f_m=2(\Delta f+f_m) 第六章 数字基带传输系统 什么是数字基带传输系统？ 未经过载波调制而直接传输数字基带信号的系统。 什么是数字频带传输系统？ 包括了调制和解调过程的数字传输系统。 导致误码率的两个原因 码间串扰、噪声 数字基带信号的几种波形（画图） 单极性、双极性、单极性归零、双极性归零、差分、多电平 基带信号的频谱情况 ①二进制随机脉冲序列的功率谱$P_s(f)$可能包含连续谱和离散谱； ②连续谱总是存在，因为实际中的$G_1(f) &ne; G_2(f)$。连续谱的形状取决于$g_1(t)$和$g_2(t)$的频谱以及概率P； ③离散谱是否存在，取决于$g_1(t)$和$g_2(t)$的频谱以及概率P。当$g_1(t) = -g_2(t) = g(t) $ 且概率 $P=1/2$时，没有离散分量； ④根据连续谱可以确定信号的带宽，根据离散谱可以确定随机序列是否有直流分量和定时分量。 无码间串扰的时域条件推导出频域条件(大题15) 教材P146 and 习题 第七章 数字带通传输系统 两种解调方法 非相干解调(包络检波法)、相干解调(同步检测法) 几种二进制调制系统所占带宽 B_{2ASK}=2f_B=2/T_B=2R_B B_{2FSK}\approx |f_2-f_1|+2f_B B_{2PSK}=B_{2DPSK}=B_{2ASK}=2f_B 2DPSK的解调方法 相干解调(极性比较)&amp;&amp;码反变换法、差分相干解调(相位比较法) 2FSK的分析模型图 （画图，图7-25,7-22,7-26） 每个模块的作用 性能比较 为什么 误码率：2PSK&lt;2DPSK&lt;2FSK&lt;2ASK 频带宽度：2FSK系统的频带利用率最低 2ASK对信道特性变化最敏感 第十章 信源编码 数字化三个步骤 抽样、量化、编码 两个抽样定理 低通抽样定理： 最低抽样速率f_S\geq2f_H,最大抽样间隔T_s\leq\frac{1}{2f_H}带通抽样定理： fs = 2B(1+\frac{k}{n})，B为信号带宽,n为f_H/B的整数部分,k为小数部分 典型电话信号带宽 频率限制300Hz-3400Hz，抽样频率8000Hz 13、15折线（习题） A=1和$\mu$=0无压缩效果 实用的典型值A=87.5，$\mu$=255 第十一章 差错控制编码 差错控制编码的作用 克服信道噪声及其他干扰引起的误码，提高传输可靠性 最小码距d0和编码检错纠错的关系 要求检测e个错码：$d_0 \geq e+1$ 要求纠正t个错误：$d_0 \geq 2t+1$ 要求纠正t个错码，同时检测e个错误：$d_0 \geq e+t+1,e \gt t$]]></content>
      <categories>
        <category>专业课程</category>
      </categories>
      <tags>
        <tag>通信原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019杭电多校 补题日志]]></title>
    <url>%2Fposts%2F95e88c92.html</url>
    <content type="text"><![CDATA[留点曾经被搞自闭的印象… 第一场1009-String 题意：在n长字符串中选出k长子序列，使子序列中每个字母的出现次数分别在一个区间内，且要求字典序最小 思路：统计后缀和，记录[i..n]还有多少个某字符，记录每个字符出现的所有位置，然后每次对于要放的第i个位置，贪心的从小的字母开始选，如果选定该字符且后面的字符个数符合条件就取该字符放在第i个位置，否则下一个；如果有某一位选不了，就说明不够构造出答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5+5;int cnt[maxn][30];vector&lt;int&gt;pos[30];int p[30],used[30];char s[maxn],ans[maxn];int l[30],r[30];int main()&#123; int k; while(~scanf("%s%d",s,&amp;k))&#123; memset(p,0,sizeof(p)); memset(cnt,0,sizeof(cnt)); memset(used,0,sizeof(used)); for(int i=0;i&lt;26;i++)&#123; pos[i].clear(); &#125; for(int i=0;i&lt;26;i++)&#123; scanf("%d%d",&amp;l[i],&amp;r[i]); &#125; int lens=strlen(s); for(int i=lens-1;i&gt;=0;i--)&#123; for(int j=0;j&lt;26;j++)&#123; cnt[i][j]=cnt[i+1][j]+(s[i]-'a'==j); &#125; &#125; for(int i=0;i&lt;lens;i++)&#123; pos[s[i]-'a'].push_back(i); &#125; for(int i=0;i&lt;26;i++)&#123; p[i]=0; &#125; bool ok=true; int last=-1; for(int i=0;i&lt;k;i++)&#123; ok=false; for(int j=0;j&lt;26;j++)&#123; if(used[j]==r[j]) continue; //限制最多拿该字符取的个数 while(p[j]!=pos[j].size()&amp;&amp;pos[j][p[j]]&lt;=last) p[j]++; //当前位置在上一次选定位置之前 if(p[j]==pos[j].size()) continue; used[j]++; int now = pos[j][p[j]]; int flag=1,need=0; for(int k=0;k&lt;26;k++)&#123; if(cnt[now+1][k]&lt;l[k]-used[k]) flag=0; //后面总字符个数不够 need += max(0,l[k]-used[k]); &#125; if(need &gt; k-i-1) flag=0; //至少需要的字符个数位置不够 if(!flag)&#123; //该字符不可取 used[j]--; &#125; else&#123; ans[i]='a'+j; ok=true; last=now; break; &#125; &#125; if(!ok) break; &#125; ans[k]='\0'; if(!ok) puts("-1"); else printf("%s\n",ans); &#125;&#125; 第二场1009-I Love Palindrome String 题意：求所有长度的回文子串，其前一半也是回文子串的个数 思路：PAM模板题，记录每个状态的最后一个字符的下标，然后就可以根据位置和长度hash去判断每个状态的回文串是否合法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn = 3e5+5;const int N = 26 ;struct Palindromic_Tree &#123; int next[maxn][N] ;//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成 int fail[maxn] ;//fail指针，失配后跳转到fail指针指向的节点 int cnt[maxn] ; //在最后统计后它可以表示形如以i为结尾的回文串中最长的那个串个数 int num[maxn] ; //表示以i结尾的回文串的种类数 int len[maxn] ;//len[i]表示节点i表示的回文串的长度 int S[maxn] ;//存放添加的字符 int last ;//指向上一个字符所在的节点，方便下一次add int n ;//字符数组指针 int p ;//节点指针 int pos[maxn]; int newnode ( int l ) &#123; for ( int i = 0 ; i &lt; N ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123;//初始化 p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1 ; &#125; int get_fail ( int x ) &#123;//和KMP一样，失配后找一个尽量最长的 while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; void add ( int c ,int id) &#123; c -= 'a' ; S[++ n] = c ; int cur = get_fail ( last ) ;//通过上一个回文串找这个回文串的匹配位置 if ( !next[cur][c] ) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode ( len[cur] + 2 ) ;//新建节点 fail[now] = next[get_fail ( fail[cur] )][c] ;//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; pos[now] = id; &#125; last = next[cur][c] ; cnt[last] ++ ; &#125; void Count () &#123; for ( int i = p - 1 ; i &gt;= 0 ; -- i ) cnt[fail[i]] += cnt[i] ; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！ &#125;&#125; ptree;char s[maxn];ull base=233;ull p[maxn],hs[maxn];ull geths(int l,int r)&#123; return hs[r]-p[r-l+1]*hs[l-1];&#125;int ans[maxn];int main() &#123; p[0]=1; for(int i=1;i&lt;maxn;i++) p[i]=p[i-1]*base; while(~scanf("%s",s+1))&#123; int n=strlen(s+1); ptree.init(); for(int i=1;i&lt;=n;i++)&#123; ans[i]=0; ptree.add(s[i],i); &#125; ptree.Count(); for(int i=1;i&lt;=n;i++)&#123; hs[i]=hs[i-1]*base+s[i]; &#125; for(int i=2;i&lt;ptree.p;i++)&#123; int len=ptree.len[i],cnt=ptree.cnt[i]; int r=ptree.pos[i]; int l=r-len+1; //printf("%d %d %d %d\n",l,r,len,cnt); int m=(l+r)/2; if(geths(l,m)==geths(m+(len%2==0),r))&#123; ans[len]+=cnt; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; printf("%d%c",ans[i],i==n?'\n':' '); &#125; &#125;&#125; 1012-Longest Subarray 题意：求最长的一段连续序列的长度，序列中使得每个数出现次数&gt;=k 思路：枚举右端点，对于当前数字c，它的当前位置为pos[i]，那么它有两个合法区间：一个是[pos[i]+1,pos[i+1]-1],这段区间对后面的数来说是不选该数，那么该区间左端点的选择合法；另一个是[1,离当前位置前k-1个该数的位置]，左端点落入这段区间就意味该数出现次数&gt;=k。 然后就可以线段树维护每个数的合法区间，对于每个右端点，离它最远满足每个数的合法区间为最优解，对于每个合法区间，线段树区间+1，右端点移动的时候就可以动态更新合法区间。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define lson l,m,o&lt;&lt;1#define rson m+1,r,o&lt;&lt;1|1using namespace std;typedef long long ll;const int maxn = 1e5+5;int n,c,k;int a[maxn],pre[maxn];vector&lt;int&gt;pos[maxn];int Max[maxn&lt;&lt;2],add[maxn&lt;&lt;2];void push_up(int o)&#123; Max[o]=max(Max[o&lt;&lt;1],Max[o&lt;&lt;1|1]);&#125;void push_down(int o)&#123; if(add[o])&#123; add[o&lt;&lt;1]+=add[o]; add[o&lt;&lt;1|1]+=add[o]; Max[o&lt;&lt;1]+=add[o]; Max[o&lt;&lt;1|1]+=add[o]; add[o]=0; &#125;&#125;void build(int l,int r,int o)&#123; Max[o]=0; add[o]=0; if(l==r) return; int m = (l+r)&gt;&gt;1; build(lson); build(rson);&#125;void update(int L,int R,int v,int l,int r,int o)&#123; if(L&gt;R) return; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; Max[o]+=v; add[o]+=v; return; &#125; push_down(o); int m = (l+r)&gt;&gt;1; if(L&lt;=m) update(L,R,v,lson); if(R&gt;m) update(L,R,v,rson); push_up(o);&#125;int query(int l,int r,int o)&#123; if(l==r) return l; push_down(o); int m = (l+r)&gt;&gt;1; if(Max[o&lt;&lt;1]==c) return query(lson); if(Max[o&lt;&lt;1|1]==c) return query(rson); return 0;&#125;int main() &#123; while(~scanf("%d%d%d",&amp;n,&amp;c,&amp;k))&#123; for(int i=1;i&lt;=c;i++)&#123; pos[i].clear(); pos[i].push_back(0); &#125; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); pos[a[i]].push_back(i); &#125; build(1,n,1); for(int i=1;i&lt;=c;i++)&#123; pre[i]=0; pos[i].push_back(n+1); update(1,pos[i][1]-1,1,1,n,1); &#125; int ans=0; for(int i=1;i&lt;=n;i++)&#123; int x = a[i]; //先减去上一次的合法区间 update(pos[x][pre[x]]+1,pos[x][pre[x]+1]-1,-1,1,n,1); if(pre[x]&gt;=k) update(1,pos[x][pre[x]-k+1],-1,1,n,1); pre[x]++; //更新这次的合法区间 update(pos[x][pre[x]]+1,pos[x][pre[x]+1]-1,1,1,n,1); if(pre[x]&gt;=k) update(1,pos[x][pre[x]-k+1],1,1,n,1); int j = query(1,n,1); if(j) ans=max(ans,(i-j+1)); &#125; printf("%d\n",ans); &#125;&#125; 第三场1004-Distribution of books 咕咕咕~ 第四场1003-Divide the Stones 题意：给n个数分别是1,2,…,n，要求分为k组，每组个数相等且和相等 思路：找规律 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;vector&lt;int&gt;ans[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; ll n,k; scanf("%lld%lld",&amp;n,&amp;k); ll sum=(1+n)*n/2; if(sum%k!=0)&#123; puts("no"); continue; &#125; for(int i=1;i&lt;=k;i++) ans[i].clear(); if((n/k)%2==0)&#123; int now=1,op=1; for(int j=1;j&lt;=n/k;j++)&#123; if(op)&#123; for(int i=1;i&lt;=k;i++) ans[i].push_back(now++); &#125; else&#123; for(int i=k;i&gt;=1;i--) ans[i].push_back(now++); &#125; op^=1; &#125; &#125; else&#123; ll need = (1+3*k)*3*k/2/k; int now=1,op=1; for(int i=1;i&lt;=k;i++) ans[i].push_back(now++); for(int i=k;i&gt;=1;i-=2) ans[i].push_back(now++); for(int i=k-1;i&gt;=1;i-=2) ans[i].push_back(now++); for(int i=1;i&lt;=k;i++) ans[i].push_back(need - ans[i][0] - ans[i][1]); now+=k; for(int j=4;j&lt;=n/k;j++)&#123; if(op)&#123; for(int i=1;i&lt;=k;i++) ans[i].push_back(now++); &#125; else&#123; for(int i=k;i&gt;=1;i--) ans[i].push_back(now++); &#125; op^=1; &#125; &#125; puts("yes"); for(int i=1;i&lt;=k;i++)&#123; for(int j=1;j&lt;=n/k;j++)&#123; printf("%d%c",ans[i][j-1],(j==n/k)?'\n':' '); &#125; &#125; &#125;&#125; 1008-K-th Closest Distance 题意：强制在线查询区间离p第k近(绝对值第k小) 思路：对于每个查询区间，先主席树二分区间第k小找到区间&lt;=p最大的那个数，然后双指针左右移动，哪边相差绝对值小就往哪边走，走k次即为答案，复杂度O(kmlogn) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define ls o&lt;&lt;1#define rs o&lt;&lt;1|1#define lson l,mid,ls#define rson mid+1,r,rs#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn=1e5+5;const int maxm=maxn*20;int T[maxn],L[maxm],R[maxm],sum[maxm];int sz[maxn],h[maxn];int n,q,tot;void build(int&amp; rt,int l,int r)&#123; rt=++tot; sum[rt]=0; if(l == r) return ; int mid=(l+r)&gt;&gt;1; build(L[rt],l,mid); build(R[rt],mid+1,r);&#125;void update(int&amp; rt,int l,int r,int pre,int x)&#123; rt=++tot; L[rt]=L[pre]; R[rt]=R[pre]; sum[rt]=sum[pre]+1; if(l == r) return ; int mid=(l+r)&gt;&gt;1; if(x &lt;= mid) update(L[rt],l,mid,L[pre],x); else update(R[rt],mid+1,r,R[pre],x);&#125;int query(int s,int e,int l,int r,int k)&#123; if(l == r) return l; int mid=(l+r)&gt;&gt;1; int res=sum[L[e]]-sum[L[s]]; if(k &lt;= res) return query(L[s],L[e],l,mid,k); else return query(R[s],R[e],mid+1,r,k-res);&#125;int main()&#123; int ca;scanf("%d",&amp;ca); while(ca--)&#123; scanf("%d%d",&amp;n,&amp;q); tot=0; for(int i=1; i&lt;=n; i++)&#123; scanf("%d",&amp;sz[i]); h[i]=sz[i]; &#125; sort(h+1,h+1+n); int num=unique(h+1,h+1+n)-(h+1); build(T[0],1,num); for(int i=1; i&lt;=n; i++) update(T[i],1,num,T[i-1],lower_bound(h+1,h+1+num,sz[i])-(h)); int ql,qr,p,k,l,r,pre,suf,ans=0; while(q--)&#123; scanf("%d%d%d%d",&amp;ql,&amp;qr,&amp;p,&amp;k); ql^=ans,qr^=ans,p^=ans,k^=ans; if(p&lt;=h[query(T[ql-1],T[qr],1,num,1)])&#123; l=0,r=1; &#125; else if(p&gt;=h[query(T[ql-1],T[qr],1,num,qr-ql+1)])&#123; l=qr-ql+1; r=qr-ql+2; &#125; else&#123; l=1,r=qr-ql+1; while(l&lt;r)&#123; int mid = (l+r+1)&gt;&gt;1; if(h[query(T[ql-1],T[qr],1,num,mid)]&lt;=p) l=mid; else r=mid-1; &#125; r=l+1; &#125; if(l!=0) pre=h[query(T[ql-1],T[qr],1,num,l)]; if(r!=qr-ql+2) suf=h[query(T[ql-1],T[qr],1,num,r)]; while(k--)&#123; if(l==0)&#123; r+=k; ans=abs(p-h[query(T[ql-1],T[qr],1,num,r)]); break; &#125; else if(r==qr-ql+2)&#123; l-=k; ans=abs(p-h[query(T[ql-1],T[qr],1,num,l)]); break; &#125; else&#123; int x=abs(p-pre),y=abs(p-suf); if(x&lt;=y)&#123; ans=x; l--; if(l!=0) pre=h[query(T[ql-1],T[qr],1,num,l)]; &#125; else&#123; ans=y; r++; if(r!=qr-ql+2) suf=h[query(T[ql-1],T[qr],1,num,r)]; &#125; &#125; &#125; printf("%d\n",ans); &#125; &#125;&#125; 第五场1002-three arrays 题意：给出两个n长整数序列，求两两配对异或后组成的新的序列字典序最小 思路：要求字典序最小，长度肯定也是n，那么每次贪心构造出最小异或值，建两个trie树，从高位到低位每次尽量都往相同的二进制位方向移动，这样使得异或出来的值尽可能小 get：动态开点初始化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 3e6+5;int tot[2];int t[2][maxn][2],val[2][maxn];void Insert(int op,int x)&#123; int now = 0; for(int i=30;i&gt;=0;i--)&#123; int to = (x&gt;&gt;i)&amp;1; if(!t[op][now][to])&#123; t[op][now][to] = ++tot[op]; val[op][tot[op]] = 0; t[op][tot[op]][0] = t[op][tot[op]][1] = 0; &#125; now = t[op][now][to]; val[op][now]++; &#125;&#125;int query()&#123; int ans=0; int p0=0,p1=0; for(int i=30;i&gt;=0;i--)&#123; if(val[0][t[0][p0][0]] &amp;&amp; val[1][t[1][p1][0]])&#123; p0=t[0][p0][0]; p1=t[1][p1][0]; val[0][p0]--; val[1][p1]--; &#125; else if(val[0][t[0][p0][1]] &amp;&amp; val[1][t[1][p1][1]])&#123; p0=t[0][p0][1]; p1=t[1][p1][1]; val[0][p0]--; val[1][p1]--; &#125; else if(val[0][t[0][p0][0]] &amp;&amp; val[1][t[1][p1][1]])&#123; p0=t[0][p0][0]; p1=t[1][p1][1]; val[0][p0]--; val[1][p1]--; ans+=(1&lt;&lt;i); &#125; else if(val[0][t[0][p0][1]] &amp;&amp; val[1][t[1][p1][0]])&#123; p0=t[0][p0][1]; p1=t[1][p1][0]; val[0][p0]--; val[1][p1]--; ans+=(1&lt;&lt;i); &#125; &#125; return ans;&#125;int ans[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n;scanf("%d",&amp;n); tot[0]=tot[1]=0; t[0][0][0] = t[0][0][1] = 0; t[1][0][0] = t[1][0][1] = 0; int x; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;x); Insert(0,x); &#125; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;x); Insert(1,x); &#125; for(int i=0;i&lt;n;i++)&#123; ans[i]=query(); &#125; sort(ans,ans+n); for(int i=0;i&lt;n;i++)&#123; printf("%d%c",ans[i],i==n-1?'\n':' '); &#125; &#125;&#125; 第六场1002-Nonsense Time 题意：给出一个全排列，初始全部不可用，n步操作，每次恢复排列中一个数，问每一步后的序列LIS长度 思路：因为数据随机，期望LIS长度为sqrt(n)，考虑反向操作，先直接找出一个LIS，然后倒着删除某个数，如果当前数不在LIS中，那么答案不变；否则需要更新LIS。期望重找LIS的次数也就sqrt(n)次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e4+5;int a[maxn],b[maxn],ans[maxn];vector&lt;int&gt;p;bool vis[maxn];int dp[maxn],pos[maxn],seq[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; memset(vis,0,sizeof(vis)); int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;b[i]); int len=0; for(int i=1;i&lt;=n;i++)&#123; if(len==0||a[i]&gt;dp[len])&#123; dp[++len]=a[i]; pos[i]=len; &#125; else&#123; *(lower_bound(dp+1,dp+1+len,a[i])) = a[i]; pos[i] = lower_bound(dp+1,dp+1+len,a[i]) - dp; &#125; &#125; int t=len; for(int i=n;i&gt;=1;i--)&#123; if(pos[i]==t)&#123; seq[t--]=a[i]; &#125; if(!t) break; &#125; p.clear(); for(int i=1;i&lt;=len;i++)&#123; p.push_back(seq[i]); &#125; ans[n] = p.size(); for(int i=n-1;i&gt;=1;i--)&#123; int x = a[b[i+1]]; vis[b[i+1]]=1; if(!binary_search(p.begin(),p.end(),x)) ans[i]=ans[i+1]; else&#123; len=0; for(int i=1;i&lt;=n;i++)&#123; if(vis[i]) continue; if(len==0||a[i]&gt;dp[len])&#123; dp[++len]=a[i]; pos[i]=len; &#125; else&#123; *(lower_bound(dp+1,dp+1+len,a[i])) = a[i]; pos[i] = lower_bound(dp+1,dp+1+len,a[i]) - dp; &#125; &#125; int t=len; for(int i=n;i&gt;=1;i--)&#123; if(vis[i]) continue; if(pos[i]==t) seq[t--]=a[i]; if(!t) break; &#125; p.clear(); for(int i=1;i&lt;=len;i++)&#123; p.push_back(seq[i]); &#125; ans[i] = p.size(); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; printf("%d%c",ans[i],i==n?'\n':' '); &#125; &#125;&#125; 1005-Snowy Smile 题意：给n个点，每个点带点权，问用一个边平行于坐标轴的矩形去框，所得最大点权和为多少 思路：因为点的范围较大，首先离散化，使得所有点落入范围为n*n的矩阵内，然后考虑枚举所有子矩阵，朴素枚举时间复杂度O(n^4)，考虑只枚举上下边界，然后把每一列的点权和看成一个数，再求当前上下边界的最大子段和即为一个矩阵内的最大点权和。点按y从小到大排序，就可以不断加点线段树动态维护区间子段和了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define ls o&lt;&lt;1#define rs o&lt;&lt;1|1#define lson l,mid,ls#define rson mid+1,r,rsusing namespace std;typedef long long ll;const int maxn = 2e3+5;struct Point&#123; int x,y; ll w; bool operator &lt; (const Point &amp;hs)const&#123; if(y!=hs.y) return y&lt;hs.y; return x&lt;hs.x; &#125;&#125;p[maxn];ll sum[maxn&lt;&lt;2],lsum[maxn&lt;&lt;2],rsum[maxn&lt;&lt;2],msum[maxn&lt;&lt;2];void push_up(int o)&#123; sum[o] = sum[ls] + sum[rs]; msum[o] = max(max(msum[ls],msum[rs]),rsum[ls]+lsum[rs]); lsum[o] = max(lsum[ls],sum[ls]+lsum[rs]); rsum[o] = max(rsum[rs],sum[rs]+rsum[ls]);&#125;void build(int l,int r,int o)&#123; sum[o]=lsum[o]=rsum[o]=msum[o]=0; if(l==r) return; int mid = (l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;void update(int p,int v,int l,int r,int o)&#123; if(l==r)&#123; sum[o]+=v; lsum[o]=rsum[o]=msum[o]=sum[o]; return; &#125; int mid = (l+r)&gt;&gt;1; if(p&lt;=mid) update(p,v,lson); else update(p,v,rson); push_up(o);&#125;vector&lt;int&gt;X,Y;vector&lt;int&gt;from[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; X.clear(); Y.clear(); int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d%d%lld",&amp;p[i].x,&amp;p[i].y,&amp;p[i].w); X.push_back(p[i].x); Y.push_back(p[i].y); &#125; sort(X.begin(),X.end()); X.erase(unique(X.begin(),X.end()),X.end()); sort(Y.begin(),Y.end()); Y.erase(unique(Y.begin(),Y.end()),Y.end()); int Mx=0,My=0; for(int i=0;i&lt;n;i++)&#123; p[i].x=lower_bound(X.begin(),X.end(),p[i].x)-X.begin()+1; p[i].y=lower_bound(Y.begin(),Y.end(),p[i].y)-Y.begin()+1; Mx=max(Mx,p[i].x); My=max(My,p[i].y); &#125; sort(p,p+n); for(int i=1;i&lt;=My;i++) from[i].clear(); for(int i=0;i&lt;n;i++) from[p[i].y].push_back(i); ll ans=0; for(int down=1;down&lt;=My;down++)&#123; build(1,Mx,1); for(int up=down;up&lt;=My;up++)&#123; for(int i=0;i&lt;from[up].size();i++)&#123; int j=from[up][i]; update(p[j].x,p[j].w,1,Mx,1); &#125; ans=max(ans,msum[1]); &#125; &#125; printf("%lld\n",ans); &#125;&#125; 第七场A- A + B = C 题意：a⋅10^x+b⋅10^y=c⋅10^z，给出a,b,c求x,y,z 思路：先将a,b,c尾巴补零补到相同长度，然后分四种情况枚举，对于每一种相加结果判断是否相等用hash直接判 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e6+5;typedef unsigned long long ull;const int mod = 998244353;ull base=10;ull p[maxn],hs[3][maxn]; ull geths(ull h[],int l,int r)&#123; return (ull)((h[r]-(p[r-l+1]*h[l-1]%mod)+mod)%mod);&#125;char a[maxn],b[maxn],c[maxn];int main()&#123; p[0]=1; for(int i=1;i&lt;maxn;i++)&#123; p[i]=(p[i-1]*base)%mod; &#125; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%s%s%s",a+1,b+1,c+1); int lena=strlen(a+1); int lenb=strlen(b+1); int lenc=strlen(c+1); int mlen = max(lena+lenb,lenc); mlen=min(mlen,1000000); hs[0][1]=hs[1][1]=hs[2][1]=0; for(int i=1;i&lt;=lena;i++) hs[0][i]=(hs[0][i-1]*base%mod+a[i]-'0')%mod; for(int i=lena+1;i&lt;=mlen;i++) hs[0][i]=(hs[0][i-1]*base%mod)%mod; for(int i=1;i&lt;=lenb;i++) hs[1][i]=(hs[1][i-1]*base%mod+b[i]-'0')%mod; for(int i=lenb+1;i&lt;=mlen;i++) hs[1][i]=(hs[1][i-1]*base%mod)%mod; for(int i=1;i&lt;=lenc;i++) hs[2][i]=(hs[2][i-1]*base%mod+c[i]-'0')%mod; for(int i=lenc+1;i&lt;=mlen;i++) hs[2][i]=(hs[2][i-1]*base%mod)%mod; ull ans = geths(hs[2],1,mlen); ull aa = geths(hs[0],1,mlen),bb,cc; bool ok=false; int x,y,z=mlen-lenc+1; for(int i=lenb;i&lt;=mlen;i++)&#123; bb = geths(hs[1],1,i); if((aa+bb)%mod==ans)&#123; ok=true; x=mlen-lena+1; y=i-lenb+1; break; &#125; &#125; if(!ok)&#123; bb = geths(hs[1],1,mlen); for(int i=lena;i&lt;=mlen;i++)&#123; aa = geths(hs[0],1,i); if((aa+bb)%mod==ans)&#123; ok=true; x=i-lena+1; y=mlen-lenb+1; break; &#125; &#125; &#125; if(!ok)&#123; aa = geths(hs[0],1,mlen-1); for(int i=lenb;i&lt;=mlen-1;i++)&#123; bb = geths(hs[1],1,i); if((aa+bb)%mod==ans)&#123; ok=true; x=mlen-lena; y=i-lenb+1; break; &#125; &#125; &#125; if(!ok)&#123; bb = geths(hs[1],1,mlen-1); for(int i=lena;i&lt;=mlen-1;i++)&#123; aa = geths(hs[0],1,i); if((aa+bb)%mod==ans)&#123; ok=true; x=i-lena+1; y=mlen-lenb; break; &#125; &#125; &#125; if(!ok) puts("-1"); else printf("%d %d %d\n",x,y,z); &#125;&#125; F-Final Exam 题意：有n个题，总分m分，每做出一道题需要这道题的分数+1的时间，问做出k题需要至少多少的时间准备 思路：因为事先不知道每道题的分数分布，那就要按最坏情况看待；田忌赛马的博弈 1234567891011#include&lt;bits/stdc++.h&gt;typedef long long ll;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; ll n,m,k; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); printf("%lld\n",(m/(n-k+1) +1)*(k-1)+(m+1)); &#125;&#125; J-Just Repeat 题意：两个人打牌，每个人有一些种类的牌，如果一个人出了一张对面也有的牌类，那对面这种牌类的牌就不能打出来，最后谁无法出牌谁就输了，问谁最后会赢 思路：统计两个人都有的牌类的张数，既然要对面输，就都会先把出现次数最多的牌类打出来，这样使得我手中的牌可以打出的更多或者对面手里牌打出的更少了，最后看不是相同剩余的牌谁能出的多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#include&lt;ext/pb_ds/assoc_container.hpp&gt;#include&lt;ext/pb_ds/hash_policy.hpp&gt;using namespace __gnu_pbds;gp_hash_table&lt;int,int&gt; hsa, hsb;const int maxn = 1e6 + 5;unsigned long long k1, k2;int mod;unsigned long long rng() &#123; unsigned long long k3 = k1, k4 = k2; k1 = k4; k3 ^= k3 &lt;&lt; 23; k2 = k3 ^ k4 ^ (k3 &gt;&gt; 17) ^ (k4 &gt;&gt; 26); return k2 + k4;&#125;struct node&#123; int a,b; node()&#123;&#125; node(int a,int b):a(a),b(b)&#123;&#125; bool operator &lt; (const node &amp;hs)const&#123; return a&lt;hs.a; &#125;&#125;;int n, m, p;int b[maxn], a[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; hsa.clear(); hsb.clear(); scanf("%d %d %d", &amp;n, &amp;m, &amp;p); if(p == 1) &#123; for(int i=1;i&lt;=n;i++) scanf("%d", &amp;a[i]); for(int i=1;i&lt;=m;i++) scanf("%d", &amp;b[i]); &#125; else &#123; scanf("%llu %llu %d", &amp;k1, &amp;k2, &amp;mod); for (int i = 1; i &lt;= n; ++i) a[i] = rng() % mod; scanf("%llu %llu %d", &amp;k1, &amp;k2, &amp;mod); for (int i = 1; i &lt;= m; ++i) b[i] = rng() % mod; &#125; int ansa = n, ansb = m; for(int i=1;i&lt;=n;i++)&#123; hsa[a[i]]++; &#125; for(int i=1;i&lt;=m;i++)&#123; hsb[b[i]]++; &#125; sort(a+1, a+1+n); int cnta=unique(a+1,a+n+1)-a-1; priority_queue&lt;node&gt; pq; for(int i=1;i&lt;=cnta;++i)&#123; if(hsa[a[i]] &amp;&amp; hsb[a[i]]) pq.push(node(hsa[a[i]]+hsb[a[i]],a[i])), ansa-=hsa[a[i]], ansb-=hsb[a[i]]; &#125; int t = 0; while(pq.size())&#123; node pp = pq.top(); pq.pop(); if(!t)&#123; ansa += hsa[pp.b] - 1; &#125;else &#123; ansb += hsb[pp.b] - 1; &#125; t ^= 1; &#125; if(t) ansb--; if(ansa &gt; ansb) puts("Cuber QQ"); else puts("Quber CC"); &#125;&#125; 第八场D-Acesrc and Hunting 题意：给一个n*m的矩阵，问能否构造出一条任意起点的路径，使得不经过重复点且任意两步之间欧几里得距离大于1且小于3 思路：划几个图就能找出一条一定能走出来的路线，但是要注意一些特判 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 105;int n,m;void pr(int x,int y)&#123; printf("%d %d\n",x,y);&#125;void solve()&#123; puts("YES"); for(int i=n;i&gt;=3;i--)&#123; if(i&amp;1) for(int j=m&amp;1?m:m-1;j&gt;=1;j-=2) pr(i,j); else for(int j=2;j&lt;=m;j+=2) pr(i,j); &#125; pr(1,1); for(int j=2;j&lt;=m;j+=2) pr(2,j); for(int j=m&amp;1?m:m-1;j&gt;=2;j-=2) pr(1,j); for(int j=1;j&lt;=m;j++) pr((j&amp;1)?2:1,j); for(int i=3;i&lt;=n;i++)&#123; if(i&amp;1) for(int j=m&amp;1?m-1:m;j&gt;=2;j-=2) pr(i,j); else for(int j=1;j&lt;=m;j+=2) pr(i,j); &#125;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); if(n==1&amp;&amp;m==1)&#123; puts("YES"); pr(1,1); continue; &#125; if(n==1||m==1||(n==2&amp;&amp;m==2))&#123; puts("NO"); continue; &#125; if(m==2)&#123; puts("YES"); if(n&amp;1)&#123; for(int i=1;i&lt;=n;i++) pr(i,(i&amp;1)?1:2); for(int i=n-2;i&gt;=1;i-=2) pr(i,2); for(int i=2;i&lt;=n;i+=2) pr(i,1); pr(n,2); &#125; else&#123; for(int i=1;i&lt;=n;i++) pr(i,(i&amp;1)?1:2); for(int i=n-2;i&gt;=1;i-=2) pr(i,1); for(int i=1;i&lt;=n;i+=2) pr(i,2); pr(n,1); &#125; continue; &#125; solve(); &#125;&#125; J-Calabash and Landlord 题意：给出两个坐标范围很大矩形，问无穷大平面有多少块区域是属于不同的联通块 思路：一是直接枚举所有情况，当然两矩形的情况不多，用相交之后共有的小矩形看有多少共边比较好写； 二是直接离散化这几个点，把区域缩成很小的一块然后爆搜 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158//思路一#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e6+5;struct rec&#123; int a,b,c,d;&#125;r[5];vector&lt;int&gt;v[2];void calc(rec A,rec B,int op)&#123; if(A.a==B.a) v[op].push_back(1); if(A.b==B.b) v[op].push_back(3); if(A.c==B.c) v[op].push_back(2); if(A.d==B.d) v[op].push_back(4);&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; for(int i=1;i&lt;=2;i++)&#123; scanf("%d%d%d%d",&amp;r[i].a,&amp;r[i].c,&amp;r[i].b,&amp;r[i].d); &#125; int x1=r[1].a,x2=r[1].b,y1=r[1].c,y2=r[1].d; int x3=r[2].a,x4=r[2].b,y3=r[2].c,y4=r[2].d; int a,b,c,d; a=max(min(x1,x2),min(x3,x4)); b=min(max(x1,x2),max(x3,x4)); c=max(min(y1,y2),min(y3,y4)); d=min(max(y1,y2),max(y3,y4)); r[0].a = a;r[0].b = b;r[0].c = c;r[0].d = d; int ans; if(a&gt;=b||c&gt;=d) ans=3; else&#123; v[0].clear(); v[1].clear(); calc(r[0],r[1],0); calc(r[0],r[2],1); int num[2][5]=&#123;0&#125;; int sum0=0,sum1=0; for(int i=0;i&lt;(int)v[0].size();i++)&#123; num[0][v[0][i]]++; sum0+=v[0][i]; &#125; for(int i=0;i&lt;(int)v[1].size();i++)&#123; num[1][v[1][i]]++; sum1+=v[1][i]; &#125; int t1=0,t0=0; for(int i=1;i&lt;=4;i++)&#123; if(num[0][i]) t0++; if(num[1][i]) t1++; &#125; //printf("~~~~~~~~~~ %d %d\n",t0,t1); if(t0==t1 &amp;&amp; t0==4) ans=2; else if(t0==4 || t1==4) &#123; if(t1==2) &#123; if(sum1&amp;1) ans = 3; else ans = 4; &#125; else if(t0 == 2) &#123; if(sum0&amp;1) ans = 3; else ans = 4; &#125; else ans = 3; &#125; else if(t0==3 &amp;&amp; t1==3) ans=4; else if(t0==3 || t1==3) &#123; if(t0 == 3) &#123; if(t1 == 1) ans =4; else if(sum1&amp;1) ans=4; else ans = 5; &#125; else &#123; if(t0 == 1) ans =4; else if(sum0&amp;1) ans=4; else ans = 5; &#125; &#125; else&#123; if(sum0&amp;1) ans=4; else ans=6; &#125; &#125; printf("%d\n",ans); &#125;&#125;//思路二#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define debug(x) cerr&lt;&lt;#x"="&lt;&lt;x&lt;&lt;'\n'; using namespace std;typedef long long ll;const int maxn = 15;bool vis[maxn][maxn];int mat[maxn][maxn];vector&lt;int&gt;X,Y;int go[4][2]=&#123;-1,0,1,0,0,-1,0,1&#125;;void dfs(int x,int y)&#123; vis[x][y]=1; for(int i=0;i&lt;4;i++)&#123; int nx=x+go[i][0]; int ny=y+go[i][1]; if(nx&gt;=1 &amp;&amp; nx&lt;=10 &amp;&amp;ny&gt;=1 &amp;&amp;ny&lt;=10 &amp;&amp; !vis[nx][ny] &amp;&amp;mat[nx][ny]==mat[x][y])&#123; dfs(nx,ny); &#125; &#125;&#125;struct node&#123; int x,y;&#125;p[5];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; X.clear(); Y.clear(); memset(mat,0,sizeof(mat)); memset(vis,0,sizeof(vis)); for(int i=0;i&lt;4;i++)&#123; scanf("%d%d",&amp;p[i].x,&amp;p[i].y); X.push_back(p[i].x); Y.push_back(p[i].y); &#125; sort(X.begin(),X.end()); X.erase(unique(X.begin(),X.end()),X.end()); sort(Y.begin(),Y.end()); Y.erase(unique(Y.begin(),Y.end()),Y.end()); for(int i=0;i&lt;4;i++)&#123; p[i].x = lower_bound(X.begin(),X.end(),p[i].x)-X.begin()+1; p[i].y = lower_bound(Y.begin(),Y.end(),p[i].y)-Y.begin()+1; //printf("%d %d %d\n",i,p[i].x,p[i].y); &#125; for(int i=0;i&lt;4;i+=2)&#123; int flag = i+1; for(int x=p[i].x;x&lt;p[i+1].x;x++)&#123; for(int y=p[i].y;y&lt;p[i+1].y;y++)&#123; mat[x][y] += flag; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=10;i++)&#123; for(int j=1;j&lt;=10;j++)&#123; if(vis[i][j] || !mat[i][j])continue; dfs(i,j); ans++; &#125; &#125; printf("%d\n",ans+1); &#125;&#125; 第九场B-Rikka with Cake 题意：求平面线段交点个数 思路：线段按y排序后枚举每条线段更新线段树or树状数组，单点更新and区间查询 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e6+5;struct seg&#123; int x1,x2,y; int v; seg()&#123;&#125; seg(int x1,int x2,int y,int v):x1(x1),x2(x2),y(y),v(v)&#123;&#125; bool operator &lt; (const seg&amp;hs)const&#123; if(y==hs.y) return v&gt;hs.v; return y&lt;hs.y; &#125;&#125;e[maxn];int d[maxn];int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int v,int n)&#123; while(x&lt;=n)&#123; d[x]+=v; x += lowbit(x); &#125;&#125;int sum(int x)&#123; int ret=0; while(x&gt;0)&#123; ret+=d[x]; x -= lowbit(x); &#125; return ret;&#125;vector&lt;int&gt;X,Y;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; X.clear(); Y.clear(); int n,m,k; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); int x1,y1,x2,y2; char op[5]; int cnt=0; for(int i=1;i&lt;=k;i++)&#123; scanf(&quot;%d%d%s&quot;,&amp;x1,&amp;y1,op); if(op[0]==&apos;L&apos;) x2=1,y2=y1; if(op[0]==&apos;R&apos;) x2=n,y2=y1; if(op[0]==&apos;U&apos;) x2=x1,y2=m; if(op[0]==&apos;D&apos;) x2=x1,y2=1; X.push_back(x1);X.push_back(x2); Y.push_back(y1);Y.push_back(y2); if(x1==x2)&#123; if(y1&gt;y2) swap(y1,y2); e[cnt++]=seg(x1,x1,y1,1); e[cnt++]=seg(x1,x1,y2,-1); &#125; if(y1==y2)&#123; if(x1&gt;x2) swap(x1,x2); e[cnt++]=seg(x1,x2,y1,0); &#125; &#125; sort(X.begin(),X.end()); X.erase(unique(X.begin(),X.end()),X.end()); sort(Y.begin(),Y.end()); Y.erase(unique(Y.begin(),Y.end()),Y.end()); for(int i=0;i&lt;cnt;i++)&#123; e[i].x1 = lower_bound(X.begin(),X.end(),e[i].x1) - X.begin()+1; e[i].x2 = lower_bound(X.begin(),X.end(),e[i].x2) - X.begin()+1; e[i].y = lower_bound(Y.begin(),Y.end(),e[i].y) - Y.begin()+1; &#125; sort(e,e+cnt); // for(int i=0;i&lt;cnt;i++)&#123; // printf(&quot;%d %d %d %d\n&quot;,e[i].x1,e[i].x2,e[i].y,e[i].v); // &#125; int nx = X.size(); for(int i=1;i&lt;=nx+5;i++) d[i]=0; ll ans=0; for(int i=0;i&lt;cnt;i++)&#123; //printf(&quot;%d %d %d\n&quot;,e[i].x1,e[i].x2,e[i].v); if(e[i].v == 0)&#123; ans += sum(e[i].x2)-sum(e[i].x1-1); &#125; else&#123; add(e[i].x1,e[i].v,nx); &#125; &#125; printf(&quot;%lld\n&quot;,ans+1); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>PAM</tag>
        <tag>线段树</tag>
        <tag>主席树</tag>
        <tag>二分</tag>
        <tag>找规律</tag>
        <tag>trie</tag>
        <tag>LIS</tag>
        <tag>最大子段和</tag>
        <tag>hash</tag>
        <tag>博弈</tag>
        <tag>构造</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营 补题日志]]></title>
    <url>%2Fposts%2F30897d7f.html</url>
    <content type="text"><![CDATA[留点曾经被搞自闭的印象… 第一场A-Equivalent Prefixes 题意：给定两个n长整数序列，每个序列不会出现重复元素，问最长的p使得[1,p]区间内的任意子区间都满足[l,r]中的最小值的位置相同 思路：二分答案，对于每个长度递归验证合法性，查询区间最值线段树或ST表维护，总时间复杂度O(nlognlogn) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5+5;int n;int a[maxn],b[maxn];int posa[maxn],posb[maxn];int Mina[maxn&lt;&lt;2],Minb[maxn&lt;&lt;2];void push_up(int o)&#123; Mina[o]=min(Mina[o&lt;&lt;1],Mina[o&lt;&lt;1|1]); Minb[o]=min(Minb[o&lt;&lt;1],Minb[o&lt;&lt;1|1]);&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; Mina[o]=a[l]; Minb[o]=b[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;int query(int k,int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; if(k==1) return Mina[o]; else return Minb[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=INF; if(L&lt;=mid) ret=min(ret,query(k,L,R,lson)); if(R&gt;mid) ret=min(ret,query(k,L,R,rson)); return ret;&#125; bool pd(int l,int r)&#123; if(l&gt;=r) return true; int mina = query(1,l,r,1,n,1); int minb = query(2,l,r,1,n,1); if(posa[mina]!=posb[minb]) return false; int mid = posa[mina]; return pd(l,mid-1)&amp;&amp;pd(mid+1,r);&#125; int main()&#123; while(~scanf("%d",&amp;n))&#123; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); posa[a[i]]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;b[i]); posb[b[i]]=i; &#125; build(1,n,1); int l=1,r=n; while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(pd(1,mid)) l=mid; else r=mid-1; &#125; printf("%d\n",l); &#125;&#125; E-ABBA 题意：有n个”AB”和m个”BA”是由2(n+m)长的字符串中取出的子序列得到，问原字符串有多少种构造可能 思路：dp[i][j]表示当前前缀有i个’A’和j个’B’的合法情况种数，根据合法性再进行转移，dp[n+m][n+m]即为答案 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 2e3+5;const int P = 1e9+7;int f[maxn][maxn];int main() &#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; for(int i=0;i&lt;=n+m;i++)&#123; for(int j=0;j&lt;=n+m;j++)&#123; f[i][j]=0; &#125; &#125; //f[i][j] 表示当前前缀有i个'A'和j个'B'的合法序列种类数 f[0][0]=1; for(int i=0; i&lt;=n+m; i++) &#123; for(int j=0; j&lt;=n+m; j++) &#123; if(i+1&lt;=n || i-n+1&lt;=j) &#123;//AB的A少了或者BA的A少了 f[i+1][j]=(f[i][j]+f[i+1][j])%P; &#125; if(j+1&lt;=m || j-m+1&lt;=i) &#123;//BA的B少了或者AB的B少了 f[i][j+1]=(f[i][j]+f[i][j+1])%P; &#125; &#125; &#125; printf("%d\n",f[n+m][n+m]); &#125;&#125; 第二场D-Kth Minimum Clique 题意：RT,求一张图的第K小团 思路：N最大100，每个团内要求每个点与其他点都有边相连，那么可以对起始每个点作为一个最小独立团进行bfs加点扩大，当新的点满足与当前团内所有点都有边的时候加入该团，bitset标记团内选点和边，K最大1e6，按团的权值出队列最多跑K次，第K次出队列的即为第K小的团，然后每个团记录团内最大结点的id，避免跑出重复的团 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 100+5;struct node&#123; int id; ll w; bitset&lt;maxn&gt;sta; node()&#123;&#125; node(int i,ll w,bitset&lt;maxn&gt;s):id(i),w(w),sta(s)&#123;&#125; bool operator &lt; (const node&amp;hs)const&#123; return w&gt;hs.w; &#125;&#125;;ll w[maxn];bitset&lt;maxn&gt;e[maxn]; int n,k;ll bfs()&#123; if(k==1) return 0; bitset&lt;maxn&gt;sta; priority_queue&lt;node&gt; pq; k--; for(int i=1;i&lt;=n;i++)&#123; sta[i]=1; pq.push(node(i,w[i],sta)); sta[i]=0; &#125; node now; while(!pq.empty())&#123; now = pq.top(); pq.pop(); k--; if(k==0) return now.w; for(int i=now.id+1;i&lt;=n;i++)&#123; if((e[i]&amp;now.sta)==now.sta)&#123; now.sta[i]=1; pq.push(node(i,now.w+w[i],now.sta)); now.sta[i]=0; &#125; &#125; &#125; return -1;&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;w[i]); &#125; char s[maxn][maxn]; for(int i=1;i&lt;=n;i++)&#123; scanf("%s",s[i]+1); for(int j=1;j&lt;=n;j++)&#123; e[i][j]=s[i][j]-'0'; &#125; &#125; printf("%lld\n",bfs());&#125; F-Partition problem 题意：2N个人需要分成两个N人的队，任意两个来自不同队的人配对有个value，求所有队员分别配对后的最大value和 思路：起始将2N个人都放在一队，2^2N枚举哪些人被分到了二队，如果第i个人被调到二队，算代价只需O(n)计算第i个人对整体value和的变化，注意剪枝 123456789101112131415161718192021222324252627282930313233343536373839404142434445#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 30;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n;int vis[30];ll ans,v[maxn][maxn]; void dfs(int i,int cnt,ll sum)&#123; if(cnt==n)&#123; ans=max(ans,sum); return; &#125; if(i-cnt&gt;n) return; //剪枝 前面有i-cnt&gt;n个人在一队肯定不行 //不动 dfs(i+1,cnt,sum); //移到另一队 ll tmp=0; for(int j=1;j&lt;=2*n;j++)&#123; if(!vis[j]) tmp+=v[i][j]; else tmp-=v[i][j]; &#125; vis[i]=1; dfs(i+1,cnt+1,sum+tmp); vis[i]=0;&#125; int main()&#123; n=read(); for(int i=1;i&lt;=2*n;i++)&#123; for(int j=1;j&lt;=2*n;j++)&#123; v[i][j]=read(); &#125; &#125; dfs(1,0,0); printf("%lld\n",ans);&#125; H-Second Large Rectangle 题意：给出一个n*m的只包含01的矩阵，求第二大的只含1的子矩阵大小 思路：对于求第一大，单调栈维护以当前行为底和包含每一列矩阵的左边界和右边界，就可以求出所有可能的最大矩形；对于求第二大，因为有可能是第一大缩小单位宽或者单位高，也可能是和第一大面积相等但位置不同，所以把全部可能情况排序去重查找即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e3+5;struct rec&#123; int h,w,x,y,s; bool operator &lt; (const rec&amp;hs)const&#123; return s&lt;hs.s; &#125; bool operator == (const rec&amp;hs)const&#123; return h==hs.h&amp;&amp;w==hs.w&amp;&amp;x==hs.x&amp;&amp;y==hs.y&amp;&amp;s==hs.s; &#125;&#125;a[maxn*maxn*3]; char mp[maxn][maxn];int h[maxn],L[maxn],R[maxn];int main() &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf("%s",mp[i]+1); &#125; int cnt=0; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; if(mp[i][j]=='1') h[j]++; else h[j]=0; &#125; for(int j=1; j&lt;=m; j++) &#123; L[j]=j; while(L[j]&gt;1&amp;&amp;h[j]&lt;=h[L[j]-1]) L[j]=L[L[j]-1]; &#125; for(int j=m; j&gt;=1; j--) &#123; R[j]=j; while(R[j]&lt;m&amp;&amp;h[j]&lt;=h[R[j]+1]) R[j]=R[R[j]+1]; &#125; for(int j=1;j&lt;=m;j++)&#123; int hh=h[j],ww=R[j]-L[j]+1,x=i,y=L[j],s=hh*ww; a[cnt++]=rec&#123;hh,ww,x,y,s&#125;; a[cnt++]=rec&#123;hh-1,ww,x,y,s-ww&#125;; a[cnt++]=rec&#123;hh,ww-1,x,y,s-hh&#125;; &#125; &#125; sort(a,a+cnt); for(int i=cnt-1;i&gt;=0;i--)&#123; if(!(a[i]==a[i-1]))&#123; printf("%d\n",a[i-1].s); break; &#125; &#125;&#125; 第三场F-Planting Trees 题意：求一个最大矩阵面积，使得其中最大值-最小值&lt;=M 思路：看那些猛男都是剪枝+二维ST表也可以过的，我就不行了，n^4优化不来 正解是枚举小矩阵的上下边界，再枚举右边界的时候用两个单调队列维护影响当前列的最值，就可以O(n)求出每列的最大左边界 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e3+5;int a[maxn][maxn];int mi[maxn],mx[maxn];//在up down上下边界中每一列的最值int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,M; scanf("%d%d",&amp;n,&amp;M); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; scanf("%d",&amp;a[i][j]); &#125; &#125; int ans=1; for(int up=1;up&lt;=n;up++)&#123; for(int j=1;j&lt;=n;j++) mi[j]=INF,mx[j]=-INF; for(int down=up;down&lt;=n;down++)&#123; for(int j=1;j&lt;=n;j++)&#123; mi[j]=min(mi[j],a[down][j]); mx[j]=max(mx[j],a[down][j]); &#125; deque&lt;int&gt;q1,q2;//单调递减和单调递增队列维护前面列影响第r列的最值 int l=0; for(int r=1;r&lt;=n;r++)&#123; while(!q1.empty()&amp;&amp;mx[r]&gt;mx[q1.back()]) q1.pop_back(); q1.push_back(r); while(!q2.empty()&amp;&amp;mi[r]&lt;mi[q2.back()]) q2.pop_back(); q2.push_back(r); while(!q1.empty()&amp;&amp;!q2.empty()&amp;&amp;mx[q1.front()]-mi[q2.front()]&gt;M)&#123; l++; if(q1.front()&lt;=l) q1.pop_front(); if(q2.front()&lt;=l) q2.pop_front(); &#125; ans=max(ans,(down-up+1)*(r-l)); if(ans&gt;(down-up+1)*(n-l)) break; //剪枝 &#125; &#125; &#125; printf("%d\n",ans); &#125;&#125; J-LRU management 题意：模拟LRU调度算法 思路：STL瞎搞，pbds大法好 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#pragma GCC optimize(2)#include&lt;ext/pb_ds/assoc_container.hpp&gt;#include&lt;ext/pb_ds/hash_policy.hpp&gt;//用hashusing namespace __gnu_pbds;#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; string s; int v; node() &#123;&#125;; node(string s,int v): s(s), v(v) &#123;&#125;&#125;;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); int q,m,t; cin&gt;&gt;t; while(t--) &#123; list&lt;node&gt; L; gp_hash_table&lt;string,list&lt;node&gt;::iterator&gt; mp; cin&gt;&gt;q&gt;&gt;m; while(q--) &#123; int op,v; string s; cin&gt;&gt;op&gt;&gt;s&gt;&gt;v; if(op==0) &#123; if(mp.find(s)!=mp.end()) &#123; auto it = mp[s]; v = it-&gt;v; L.erase(it); &#125; L.push_back(node(s,v)); mp[s]=prev(L.end()); cout&lt;&lt;v&lt;&lt;'\n'; if(L.size()&gt;m) &#123; mp.erase(L.begin()-&gt;s); L.erase(L.begin()); &#125; &#125; else &#123; if(mp.find(s)==mp.end()) &#123; cout&lt;&lt;"Invalid"&lt;&lt;'\n'; &#125; else &#123; auto pos=mp[s]; if((pos==L.begin()&amp;&amp;v==-1)||(pos==prev(L.end())&amp;&amp;v==1)) cout&lt;&lt;"Invalid"&lt;&lt;'\n'; else &#123; if(v==1) pos=next(pos); if(v==-1) pos=prev(pos); cout&lt;&lt;pos-&gt;v&lt;&lt;'\n'; &#125; &#125; &#125; &#125; &#125;&#125; 第四场C-sequence 题意：相当于求一段区间的最小值*区间和最大值 思路：对于每个a[i]，它作为最小值的区间可用单调栈O(n)处理出左边界L[i]和右边界R[i]，算答案就有两种情况： 一是a[i]&gt;=0，那么a[i]作为最小值的区间都是非负数，区间和最大即是整个区间和； 二是a[i]&lt;0，那么区间和就要尽可能小，用[i,R[i]]的最小前缀和减去[L[i],i]的最大前缀和可以使得包含a[i]的区间和最小，答案最优，线段树维护前缀和区间最值即可，3e6的数据范围ST表显然空间不够，题解怎么做到的？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define ls o&lt;&lt;1#define rs o&lt;&lt;1|1#define lson l,mid,ls#define rson mid+1,r,rs#define INF 0x3f3f3f3f3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 3e6+5;int n;ll a[maxn],b[maxn];int L[maxn],R[maxn];ll sum[maxn],Max[maxn&lt;&lt;2],Min[maxn&lt;&lt;2];void push_up(int o)&#123; Max[o]=max(Max[ls],Max[rs]); Min[o]=min(Min[ls],Min[rs]);&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; Max[o]=Min[o]=sum[l]; return; &#125; int mid = (l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;ll querymax(int L,int R,int l=1,int r=n,int o=1)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Max[o]; &#125; int mid = (l+r)&gt;&gt;1; ll ret = -INF; if(L&lt;=mid) ret=max(ret,querymax(L,R,lson)); if(R&gt;mid) ret=max(ret,querymax(L,R,rson)); return ret;&#125;ll querymin(int L,int R,int l=1,int r=n,int o=1)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Min[o]; &#125; int mid = (l+r)&gt;&gt;1; ll ret = INF; if(L&lt;=mid) ret=min(ret,querymin(L,R,lson)); if(R&gt;mid) ret=min(ret,querymin(L,R,rson)); return ret;&#125; int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;b[i]); sum[i]=sum[i-1]+b[i]; &#125; build(1,n,1); deque&lt;int&gt;q; a[0]=a[n+1]=-INF; for(int i=1;i&lt;=n+1;i++)&#123; while(!q.empty()&amp;&amp;a[i]&lt;a[q.back()])&#123; R[q.back()]=i-1; q.pop_back(); &#125; q.push_back(i); &#125; q.clear(); for(int i=n;i&gt;=0;i--)&#123; while(!q.empty()&amp;&amp;a[i]&lt;a[q.back()])&#123; L[q.back()]=i+1; q.pop_back(); &#125; q.push_back(i); &#125; ll ans=0; for(int i=1;i&lt;=n;i++)&#123; if(a[i]&gt;=0)&#123; ans=max(ans,a[i]*(sum[R[i]]-sum[L[i]-1])); &#125; else&#123; ans=max(ans,a[i]*(querymin(i,R[i])-querymax(L[i],i))); &#125; &#125; printf("%lld\n",ans);&#125; I-string 题意：给出一个字符串，求其最大子串集合大小，子串集合中满足无重复串和翻转相同串 思路：把原串反过来拼接到原串后面，中间用特殊符号隔开，统计这时所有的子串数-含有特殊字符的字符串数，理论上原串的子串数都会增加一倍，但因为有回文串和翻转相同串的存在会使得新增子串并没有那么多，此时加上原串不同本质回文子串数就使得原串中每个子串又有一个翻转串对应，/2即为答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6 + 5;const int N = 27;struct SAM&#123; int tot, last, ch[maxn &lt;&lt; 1][N], fa[maxn &lt;&lt; 1], len[maxn &lt;&lt; 1]; int Tr(char c)&#123;return c - 'a';&#125; int val(int c)&#123;return len[c] - len[fa[c]];&#125; void init() &#123; last = tot = 1; len[1] = 0; memset( ch[1], 0, sizeof ch[1]); &#125; void add(int x) &#123; int p = last, np = last = ++tot; len[np] = len[p] + 1, cnt[last] = 1; memset( ch[np], 0, sizeof ch[np]); while( p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = fa[p]; if( p == 0) fa[np] = 1; else &#123; int q = ch[p][x]; if( len[q] == len[p] + 1) fa[np] = q; else &#123; int nq = ++tot; memcpy( ch[nq], ch[q], sizeof ch[q]); len[nq] = len[p] + 1, fa[nq] = fa[q], fa[q] = fa[np] = nq; while( p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = fa[p]; &#125; &#125; &#125; void build(char s[]) &#123; int lens = strlen(s + 1); for(int i = 1; i &lt;= lens; i++) add(Tr(s[i])); add(26); for(int i = lens; i &gt;= 1; i--) add(Tr(s[i])); &#125; ll getsubnum() &#123; ll ans = 0; for(int i = tot; i; i--) &#123; ans += val(i); &#125; return ans; &#125;&#125; sam;struct PAM&#123; int next[maxn][N] ; int fail[maxn] ; int cnt[maxn] ; int num[maxn] ; int len[maxn] ; int S[maxn] ; int last ; int n ; int p ; int newnode ( int l ) &#123; for ( int i = 0 ; i &lt; N ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123; p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ; fail[0] = 1 ; &#125; int get_fail ( int x ) &#123; while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; void add ( int c ) &#123; c -= 'a' ; S[++ n] = c ; int cur = get_fail ( last ) ; if ( !next[cur][c] ) &#123; int now = newnode ( len[cur] + 2 ) ; fail[now] = next[get_fail ( fail[cur] )][c] ; next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; &#125; last = next[cur][c] ; cnt[last] ++ ; &#125;&#125; pam;char s[maxn];int main()&#123; scanf("%s", s + 1); int lens = strlen(s + 1); sam.init(); sam.build(s); ll ans1 = sam.getsubnum() - 1LL*(lens+1)*(lens+1); pam.init(); for(int i = 1; i &lt;= lens; i++) &#123; pam.add(s[i]); &#125; ll ans2 = pam.p-2; printf("%lld\n",(ans1+ans2)/2);&#125; 第五场G-subsequence 1 题意：给两个字符串，求字符串s中的字符子序列组合成的无前导零整数大于t组合成的整数的方案数 思路：首先长度大于t串的可以枚举非0前导，通过组合数学求出；长度相等的情况dp来搞 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 3e3+5;const int P = 998244353; ll C[maxn][maxn];void getC()&#123; for(int i=0;i&lt;maxn;i++)&#123; C[i][0]=C[i][i]=1; for(int j=1;j&lt;i;j++)&#123; C[i][j]=(C[i-1][j-1]+C[i-1][j])%P; &#125; &#125;&#125; char s[maxn],t[maxn];ll dp[maxn][maxn];void Add(ll &amp;x,ll y)&#123; x+=y; if(x&gt;=P) x-=P;&#125;int main()&#123; getC(); int T; scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%s%s&quot;,s+1,t+1); ll ans=0; //长度不相等答案 for(int i=1;i&lt;=n;i++)&#123; if(s[i]!=&apos;0&apos;)&#123; for(int j=m;j&lt;=n-i;j++)&#123; Add(ans,C[n-i][j]); &#125; &#125; &#125; //长度相等答案,dp[i][j]表示s串前i个选出j个和t串前j个相等的方案数 for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=m;j++)&#123; dp[i][j]=0; &#125; dp[i][0]=1; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; dp[i][j]=dp[i-1][j]; if(s[i]==t[j])&#123; Add(dp[i][j],dp[i-1][j-1]); &#125; if(s[i]&gt;t[j])&#123; if(n-i&gt;=0&amp;&amp;m-j&gt;=0&amp;&amp;n-i&gt;=m-j)&#123; Add(ans,dp[i-1][j-1]*C[n-i][m-j]%P); &#125; &#125; &#125; &#125; printf(&quot;%lld\n&quot;,ans); &#125;&#125; 第六场D-Move 题意：n个物品放在k个体积相同的箱子里，规则是对于每一个箱子都一直尽可能放当前最大的物品进去直到不能放就换下一个箱子放，求箱子最小体积 思路：二分答案，出来的答案还要瞎搞下，因为不是最优解，复杂度爆炸也过了，毕竟数据水 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;const int maxn = 1e3+5;typedef long long ll;ll a[maxn];ll n,k;bool vis[maxn];bool pd(ll x)&#123; if(a[n]&gt;x) return false; memset(vis,0,sizeof(bool)*(n+2)); int take=0; for(int j=1;j&lt;=k;j++)&#123; ll rest=x; for(int i=n;i&gt;=1;i--)&#123; if(vis[i]) continue; if(rest&gt;=a[i])&#123; rest -= a[i]; vis[i]=1; take++; &#125; if(rest&lt;a[1]) break; &#125; if(take==n)break; &#125; return take==n;&#125; int main()&#123; int T; scanf("%d",&amp;T); int ca=1; while(T--)&#123; scanf("%d%d",&amp;n,&amp;k); ll sum=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); sum+=a[i]; &#125; sort(a+1,a+1+n); ll l=0,r=10*sum; while(l&lt;r)&#123; ll mid = (l+r)&gt;&gt;1; if(pd(mid)) r=mid; else l=mid+1; &#125; printf("Case #%d: ",ca++); for(int i=l-20;i&lt;=l;i++) if(pd(i))&#123; printf("%d\n",i); break; &#125; &#125; &#125; G-Is Today Friday? 题意：给出1e5个由大写字母A-J组成的字符串，每个字符串代表一个规定年限内的周五日期，求A-J每个字母的数字含义，要求字典序最小 思路：因为日期有限制，所以1e5个中有很多会有重复的，排序去重后，直接枚举0-9的全排列（合法的其实很少），即枚举答案，同时保证了字典序最小。复习了一下基姆拉尔森公式和判断平闰年qwq 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5+5;int a[15];int m[15]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;int larson(int year,int month,int day)&#123; if(month == 1 || month == 2)&#123; year -= 1; month += 12; &#125; return (day+2*month+3*(month+1)/5+year+(year/4)-(year/100)+(year/400)+1)%7;&#125;bool pd(string s)&#123; int year = a[s[0]-'A']*1000+a[s[1]-'A']*100+a[s[2]-'A']*10+a[s[3]-'A']; int month = a[s[5]-'A']*10+a[s[6]-'A']; int day = a[s[8]-'A']*10+a[s[9]-'A']; if( (year%4==0&amp;&amp;year%100!=0) || year%400==0 ) m[2]=29; else m[2]=28; if(year&lt;1600 || month&lt;1 ||month&gt;12 || day&lt;1 ||day&gt;m[month] || larson(year,month,day)!=5) return false; return true;&#125;string s[maxn];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int T,ca=1;cin&gt;&gt;T; while(T--)&#123; int n;cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;s[i]; &#125; sort(s,s+n); n = unique(s,s+n)-s; for(int i=0;i&lt;10;i++) a[i]=i; bool ok=false; do&#123; bool flag=true; for(int i=0;i&lt;n;i++)&#123; if(!pd(s[i]))&#123; flag=false; break; &#125; &#125; if(flag)&#123; ok=true; break; &#125; &#125;while(next_permutation(a,a+10)); printf("Case #%d: ",ca++); if(!ok) puts("Impossible"); else&#123; for(int i=0;i&lt;10;i++) printf("%d",a[i]); puts(""); &#125; &#125; &#125; 第七场E-Find the median 题意：给n段区间，每次将区间[L,R]每个数加到当前序列中，区间范围1e9，求每次操作后的中位数 思路：如果区间范围较小那就是个权值线段树模板题，这里区间需要离散化，线段树上每个叶子结点代表一个区间，记录每个区间的长度和出现次数，就可以知道当前所有数的个数，然后线段树中二分查找第k小即可 get：区间离散化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define ls o&lt;&lt;1#define rs o&lt;&lt;1|1#define lson l,mid,ls#define rson mid+1,r,rsusing namespace std;typedef long long ll;const int maxn = 2*4e5+5;ll X[maxn],Y[maxn],l[maxn],r[maxn];ll A1,A2,B1,B2,C1,C2,M1,M2;ll cnt[maxn&lt;&lt;2],sum[maxn&lt;&lt;2],len[maxn&lt;&lt;2];//区间覆盖次数,区间所有数个数,区间长度vector&lt;int&gt;v;void push_up(int o)&#123; sum[o]=sum[ls]+sum[rs]; len[o]=len[ls]+len[rs];&#125;void push_down(int o)&#123; if(cnt[o])&#123; cnt[ls]+=cnt[o]; cnt[rs]+=cnt[o]; sum[ls]+=cnt[o]*len[ls]; sum[rs]+=cnt[o]*len[rs]; cnt[o]=0; &#125;&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; cnt[o]=sum[o]=0; len[o]=v[l]-v[l-1]; return; &#125; int mid = (l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;void update(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; cnt[o]++; sum[o]+=len[o]; return; &#125; push_down(o); int mid = (l+r)&gt;&gt;1; if(L&lt;=mid) update(L,R,lson); if(R&gt;mid) update(L,R,rson); push_up(o);&#125;int query(int l,int r,int o,ll k)&#123; if(l==r)&#123; return v[l-1]+(k-1)/(sum[o]/len[o]); &#125; push_down(o); int mid = (l+r)&gt;&gt;1; if(sum[ls]&gt;=k) return query(lson,k); else return query(rson,k-sum[ls]);&#125; int main()&#123; int n,m; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%lld%lld%lld%lld%lld%lld&quot;,&amp;X[1],&amp;X[2],&amp;A1,&amp;B1,&amp;C1,&amp;M1); scanf(&quot;%lld%lld%lld%lld%lld%lld&quot;,&amp;Y[1],&amp;Y[2],&amp;A2,&amp;B2,&amp;C2,&amp;M2); for(int i=3;i&lt;=n;i++)&#123; X[i] = (A1*X[i-1]%M1 + B1*X[i-2]%M1 + C1)%M1; Y[i] = (A2*Y[i-1]%M2 + B2*Y[i-2]%M2 + C2)%M2; &#125; for(int i=1;i&lt;=n;i++)&#123; l[i]=min(X[i],Y[i])+1; r[i]=max(X[i],Y[i])+1; r[i]++; v.push_back(l[i]);v.push_back(r[i]); &#125; sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end()); m=v.size(); for(int i=1;i&lt;=n;i++)&#123; l[i] = lower_bound(v.begin(),v.end(),l[i])-v.begin()+1; r[i] = lower_bound(v.begin(),v.end(),r[i])-v.begin()+1; r[i]--; &#125; build(1,m-1,1); ll all=0; for(int i=1;i&lt;=n;i++)&#123; update(l[i],r[i],1,m-1,1); all=sum[1]; printf(&quot;%d\n&quot;,query(1,m-1,1,(all+1)/2)); &#125;&#125; 第八场A-All-one Matrices 题意：求极大全一子矩阵个数 思路：固定上边界，单调队列处理当前下边界，这样知道每一列可拓展的最左边界和最右边界，然后看下边界是否可以拓展 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 3e3+5;int n, m;char mp[maxn][maxn];int h[maxn],L[maxn],R[maxn],sum[maxn][maxn];int st[maxn];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%s",mp[i]+1); &#125; for(int i=1;i&lt;=n;i++)&#123; sum[i][0]=0; for(int j=1;j&lt;=m;j++)&#123; sum[i][j] = sum[i][j-1]+(mp[i][j]=='1'); &#125; &#125; int ans=0; h[m+1]=-1; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; if(mp[i][j]=='1') h[j]++; else h[j]=0; &#125; for(int j=1; j&lt;=m; j++) &#123; L[j]=j; while(L[j]&gt;1&amp;&amp;h[j]&lt;=h[L[j]-1]) L[j]=L[L[j]-1]; &#125; for(int j=m; j&gt;=1; j--) &#123; R[j]=j; while(R[j]&lt;m&amp;&amp;h[j]&lt;=h[R[j]+1]) R[j]=R[R[j]+1]; &#125; int top=0; for(int j=1;j&lt;=m+1;j++)&#123; while(top&amp;&amp;h[j]&lt;h[st[top]])&#123; int now = st[top]; top--; if(!h[now]) continue; int l = L[now]; int r = R[now]; if(sum[i+1][r]-sum[i+1][l-1] != r-l+1)&#123; //printf("%d %d %d %d %d\n",i,j,now,l,r); ans++; while(top&amp;&amp;st[top]&gt;=l) top--; &#125; &#125; st[++top]=j; &#125; &#125; printf("%d\n",ans);&#125; E-Explorer 题意：一张图中所有边有个[l,r]，问从点1到点n可以有多少个值可以通过 思路：线段树维护可撤销并查集，每个结点表示区间被哪些两个点包含，每次将这些两个点的集合加到一起，并查集合并时因为要撤销所以不能路径压缩，只能按秩合并 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define lc o&lt;&lt;1#define rc o&lt;&lt;1|1#define lson l,mid,lc#define rson mid+1,r,rcusing namespace std;typedef long long ll;const int maxn = 1e5+5;int U[maxn],V[maxn],L[maxn],R[maxn];vector&lt;int&gt;ve;int fa[maxn],sz[maxn];int Find(int x)&#123; return x==fa[x]?x:Find(fa[x]);&#125; vector&lt;int&gt;tag[maxn&lt;&lt;3];void update(int L,int R,int v,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; tag[o].push_back(v); return; &#125; int mid = (l+r)&gt;&gt;1; if(L&lt;=mid) update(L,R,v,lson); if(R&gt;mid) update(L,R,v,rson);&#125; int n,m,ans;void query(int l,int r,int o)&#123; vector&lt;int&gt;tmp; for(auto i:tag[o])&#123; int u = U[i],v = V[i]; int fu = Find(u),fv = Find(v); if(fu==fv) continue; if(sz[fu]&gt;sz[fv]) swap(fu,fv); fa[fu]=fv; sz[fv]+=sz[fu]; tmp.push_back(fu); &#125; if(Find(1)==Find(n)) ans+=ve[r]-ve[l-1]; else if(l&lt;r)&#123; int mid = (l+r)&gt;&gt;1; query(lson); query(rson); &#125; for(auto v:tmp) fa[v]=v;&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d%d",&amp;U[i],&amp;V[i],&amp;L[i],&amp;R[i]); R[i]++; ve.push_back(L[i]); ve.push_back(R[i]); &#125; sort(ve.begin(),ve.end()); ve.erase(unique(ve.begin(),ve.end()),ve.end()); int nx = ve.size(); for(int i=1;i&lt;=m;i++)&#123; L[i]=lower_bound(ve.begin(),ve.end(),L[i])-ve.begin()+1; R[i]=lower_bound(ve.begin(),ve.end(),R[i])-ve.begin(); update(L[i],R[i],i,1,nx,1); &#125; for(int i=1;i&lt;=n;i++)&#123; fa[i]=i; sz[i]=1; &#125; query(1,nx,1); printf("%d\n",ans);&#125; 第九场H-Cutting Bamboos 题意：区间一些数减到某一定值，操作y次，要使每次减掉部分和相等，问第x次减到的定值 思路：实数域上二分答案，主席树区间查询比&lt;=x的和为多大 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 2e5+5;int T[maxn*20],L[maxn*20],R[maxn*20],cnt[maxn*20];ll sum[maxn*20];int tot;void build(int &amp;x,int l,int r)&#123; x=++tot; sum[x]=cnt[x]=0; if(l==r) return; int mid = (l+r)&gt;&gt;1; build(L[x],l,mid); build(R[x],mid+1,r);&#125;void update(int &amp;now,int pre,int l,int r,int h)&#123; now=++tot; L[now]=L[pre]; R[now]=R[pre]; cnt[now]=cnt[pre]+1; sum[now]=sum[pre]+h; if(l==r) return; int mid = (l+r)&gt;&gt;1; if(h&lt;=mid) update(L[now],L[pre],l,mid,h); else update(R[now],R[pre],mid+1,r,h);&#125;double nnum,ssum;void query(int ql,int qr,int l,int r,int h)&#123; if(l&gt;h) &#123; nnum += cnt[qr]-cnt[ql]; return; &#125; if(r&lt;=h)&#123; ssum += sum[qr]-sum[ql]; return; &#125; int mid = (l+r)&gt;&gt;1; query(L[ql],L[qr],l,mid,h); query(R[ql],R[qr],mid+1,r,h);&#125; int h[maxn];int all = 100000;int main()&#123; int n,q; scanf("%d%d",&amp;n,&amp;q); tot=0; build(T[0],1,all); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;h[i]); update(T[i],T[i-1],1,all,h[i]); &#125; while(q--)&#123; int ql,qr,x,y; scanf("%d%d%d%d",&amp;ql,&amp;qr,&amp;x,&amp;y); double rest = (sum[T[qr]]-sum[T[ql-1]])*1.0/y*(y-x); double l=0.0,r=100000.0,mid,eps=1e-8; while(l+eps&lt;r)&#123; mid = (l+r)/2; nnum=ssum=0; query(T[ql-1],T[qr],1,all,mid); ssum += nnum*mid; if(ssum&gt;rest) r=mid; else l=mid; &#125; printf("%.15f\n",l); &#125;&#125; J-Symmetrical Painting 题意：给n个矩形，要求去掉部分矩形覆盖面积，使得剩余矩形覆盖面积关于某对称轴水平对称，求最大剩余覆盖面积 思路：要使水平对称，那枚举每个矩形的对称轴，上中下，每次根据位置标记算贡献 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 3e5+5;struct node&#123; double y;int w; node()&#123;&#125; node(double a,int b):y(a),w(b)&#123;&#125; bool operator &lt; (const node&amp;hs)const&#123; return y&lt;hs.y; &#125;&#125;a[maxn*3]; int main()&#123; int n; scanf("%d",&amp;n); int cnt=0; for(int i=0;i&lt;n;i++)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); a[cnt++]=node(l,1); a[cnt++]=node((l+r)*1.0/2,-2); a[cnt++]=node(r,1); &#125; sort(a,a+cnt); double pre=0; double ans=0,now=0,len=0,sum=0; for(int i=0;i&lt;cnt;i++)&#123; len = a[i].y - pre; sum += 1LL*now*len*2; ans = max(ans,sum); now += a[i].w; pre = a[i].y; &#125; printf("%.0f\n",ans);&#125; 第十场B-Coffee Chicken 题意：求斐波那契规则构成的n个字符串，第n个的第k-k+9个字符 思路：根据斐波那契的实现，输出长度只有10，最后输出的字符肯定会落在第一个和第二个串上 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e6+5;string s[5]=&#123;"", " COFFEE", " CHICKEN"&#125;;ll f[505];void pr(int n,ll k)&#123; while(n&gt;2)&#123; if(f[n-2]&gt;=k) n-=2; else k-=f[n-2],n--; &#125; putchar(s[n][k]);&#125; int main()&#123; f[0] = 0; f[1] = 6; f[2] = 7; for(int i=3;i&lt;=500;i++) f[i] = min(f[i-1]+f[i-2],(ll)1e12+10); int T; scanf("%d",&amp;T); while(T--)&#123; int n;ll k; scanf("%d%lld",&amp;n,&amp;k); for(int i=0;i&lt;10;i++)&#123; if(k+i&lt;=f[n]) pr(n,k+i); &#125; puts(""); &#125;&#125; F-Popping Balloons 题意：二维平面上一些点上有气球，现在可以射击6次，水平垂直各3次，射击可使一行或一列的气球都命中，两种方式任意两次射击的距离只能为r，求最大射击气球数 思路：线段树维护的叶子结点表示第一发打中x，后面x+r,x+r+r一起的收益，这样固定x轴的，枚举y轴，然后更新减掉x，y重复的，求x轴的最大值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define lc o&lt;&lt;1#define rc o&lt;&lt;1|1#define lson l,mid,lc#define rson mid+1,r,rcusing namespace std;typedef long long ll;const int maxn = 3e5+5;int sumx[maxn],Max[maxn&lt;&lt;2];vector&lt;int&gt;Y[maxn];int n,r;void push_up(int o)&#123; Max[o]=max(Max[lc],Max[rc]);&#125;void update(int p,int v,int l,int r,int o)&#123; if(l==r)&#123; Max[o] += v; return; &#125; int mid =(l+r)&gt;&gt;1; if(p&lt;=mid) update(p,v,lson); else update(p,v,rson); push_up(o);&#125;int Mx,My;void sub(int p)&#123; update(p,-1,0,Mx,1); if(p-r&gt;=0)update(p-r,-1,0,Mx,1); if(p-r-r&gt;=0)update(p-r-r,-1,0,Mx,1);&#125;void add(int p)&#123; update(p,1,0,Mx,1); if(p-r&gt;=0)update(p-r,1,0,Mx,1); if(p-r-r&gt;=0)update(p-r-r,1,0,Mx,1);&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;r); Mx=0,My=0; for(int i=0;i&lt;n;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); sumx[x]++; Y[y].push_back(x); Mx=max(Mx,x); My=max(My,y); &#125; for(int i=0;i&lt;=Mx;i++)&#123; update(i,sumx[i]+sumx[i+r]+sumx[i+r+r],0,Mx,1); &#125; int ans=0; for(int i=0;i&lt;=My;i++)&#123; for(auto p:Y[i]) sub(p); for(auto p:Y[i+r]) sub(p); for(auto p:Y[i+r+r]) sub(p); int sumX = Max[1]; int sumY = Y[i].size()+Y[i+r].size()+Y[i+r+r].size(); //printf("%d %d %d\n",i,sumX,sumY); ans=max(ans,sumX+sumY); for(auto p:Y[i]) add(p); for(auto p:Y[i+r]) add(p); for(auto p:Y[i+r+r]) add(p); &#125; printf("%d\n",ans);&#125; 完结撒花&gt;&gt;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>PAM</tag>
        <tag>线段树</tag>
        <tag>主席树</tag>
        <tag>二分</tag>
        <tag>分治</tag>
        <tag>dp</tag>
        <tag>单调栈</tag>
        <tag>dfs</tag>
        <tag>bitset</tag>
        <tag>STL</tag>
        <tag>单调队列</tag>
        <tag>模拟</tag>
        <tag>SAM</tag>
        <tag>组合数学</tag>
        <tag>几何</tag>
        <tag>离散化</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC2019女生专场D-Tree]]></title>
    <url>%2Fposts%2F18d71047.html</url>
    <content type="text"><![CDATA[今天花一天时间好好学习了下树链剖分，之前听上去很高大上的样子，上半年寒假集训学长讲的时候还完全不懂，现在学着学着就很好理解了。刚好这道最近要补的题就是个裸题，拿来练练手。 原题链接 如果想区间维护更新的话因为是开根号，不满足加减乘幂等运算性质，所以只好单点更新，但这样复杂度会是O(qnlogn)？实际上，因为ai最大1e9，对其在在10次开根号的操作下会变为1，然后就不会变了，所以维护一个区间最大值，每次更新看是否最大值&lt;=1，是的话线段树就不要递归向下更新了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;typedef long long ll;const int maxn = 1e5+10;const int maxm = 1e5+10;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct edge&#123; int next,to;&#125;e[maxm*2];int head[maxn],cnt;void addedge(int u,int v)&#123; e[++cnt]=edge&#123;head[u],v&#125;; head[u]=cnt;&#125;int n,q,val[maxn];int fa[maxn],deep[maxn],siz[maxn],son[maxn],rk[maxn],top[maxn],id[maxn];void dfs1(int u,int pre,int dep)&#123; fa[u]=pre;deep[u]=dep;siz[u]=1; for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v==pre)continue; dfs1(v,u,dep+1); siz[u]+=siz[v]; if(siz[v]&gt;siz[son[u]])son[u]=v; &#125;&#125;void dfs2(int u,int t)&#123; top[u]=t;id[u]=++cnt;rk[cnt]=u; if(!son[u])return; dfs2(son[u],t); for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v!=son[u]&amp;&amp;v!=fa[u])dfs2(v,v); &#125;&#125;ll Max[maxn&lt;&lt;2],Sum[maxn&lt;&lt;2];void push_up(int o)&#123; Sum[o]=Sum[o&lt;&lt;1]+Sum[o&lt;&lt;1|1]; Max[o]=max(Max[o&lt;&lt;1],Max[o&lt;&lt;1|1]);&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; Max[o]=Sum[o]=val[rk[l]]; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;void update(int L,int R,int l,int r,int o)&#123; if(Max[o]&lt;=1) return; if(l==r)&#123; Sum[o]=(int)sqrt(Sum[o]); Max[o]=Sum[o]; return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) update(L,R,lson); if(R&gt;mid) update(L,R,rson); push_up(o);&#125;ll querysum(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Sum[o]; &#125; int mid=(l+r)&gt;&gt;1;ll ret=0; if(L&lt;=mid) ret+=querysum(L,R,lson); if(R&gt;mid) ret+=querysum(L,R,rson); return ret;&#125;void PathUpdate(int x,int y)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); update(id[top[x]],id[x],1,n,1); x=fa[top[x]]; &#125; if(id[x]&gt;id[y]) swap(x,y); update(id[x],id[y],1,n,1);&#125;ll PathQuery(int x,int y)&#123; ll ret=0; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); ret+=querysum(id[top[x]],id[x],1,n,1); x=fa[top[x]]; &#125; if(id[x]&gt;id[y])swap(x,y); ret+=querysum(id[x],id[y],1,n,1); return ret;&#125;int main()&#123; n=read(),q=read(); for(int i=1;i&lt;=n;i++) val[i]=read(); cnt=0; for(int i=1;i&lt;=n;i++) head[i]=0; for(int i=0;i&lt;n-1;i++)&#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; cnt=0; dfs1(1,0,1); dfs2(1,1); build(1,n,1); while(q--)&#123; int op=read(),x=read(),y=read(); if(op==0)&#123; PathUpdate(x,y); &#125; else&#123; printf("%lld\n",PathQuery(x,y)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客小白月赛16&&CodeForces1191 补题]]></title>
    <url>%2Fposts%2Fccc91f18.html</url>
    <content type="text"><![CDATA[又是自闭的一天… D-小阳买水果求序列连续子段和大于0的最长子序列长度 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3ftypedef long long ll;using namespace std;const int maxn = 2e6+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int ans,sum,n;int a[maxn];int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; //枚举r二分l (l,r] int x=read(); sum+=x; a[i]=min(a[i-1],sum); if(sum-a[i-1]&lt;=0) continue; int l=0,r=i-1; while(l&lt;r)&#123; int m=(l+r)&gt;&gt;1; if(sum-a[m]&gt;0) r=m; else l=m+1; &#125; ans=max(ans,i-l); &#125; printf("%d\n",ans);&#125; F-小石的妹子拓扑思想+线段树维护区间最大值 发现用数组数组常数小，代码量也少 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1#define INF 0x3f3f3f3ftypedef long long ll;using namespace std;const int maxn = 1e5+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct node&#123; int a,b,id; bool operator &lt; (const node&amp;hs)const&#123; return a&gt;hs.a; &#125;&#125;p[maxn];int n;int bb[maxn],ans[maxn];int Max[maxn&lt;&lt;2];void update(int p,int v,int l,int r,int o)&#123; if(l==r)&#123; Max[o]=v; return; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) update(p,v,lson); else update(p,v,rson); Max[o]=max(Max[o&lt;&lt;1],Max[o&lt;&lt;1|1]);&#125;int querymax(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Max[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=-1; if(L&lt;=mid) ret=max(ret,querymax(L,R,lson)); if(R&gt;mid) ret=max(ret,querymax(L,R,rson)); return ret;&#125;int main()&#123; n=read(); for(int i=0;i&lt;n;i++)&#123; int a=read(),b=read(); bb[i]=b; p[i]=node&#123;a,b,i&#125;; &#125; sort(p,p+n); sort(bb,bb+n); //离散化bi for(int i=0;i&lt;n;i++)&#123; p[i].b=lower_bound(bb,bb+n,p[i].b)-bb+1; &#125; //因为已经对ai排序,满足aj&gt;ai,则只要考虑bj&gt;bi的最大排名即可 for(int i=0;i&lt;n;i++)&#123; ans[p[i].id]=querymax(p[i].b,n,1,n,1)+1; update(p[i].b,ans[p[i].id],1,n,1); &#125; for(int i=0;i&lt;n;i++) printf("%d\n",ans[i]);&#125; H-小阳的贝壳$gcd(a,b,c)=gcd(a,b-a,c-b)=gcd(a,gcd(b-a,c-b));$ $gcd([l,r])=gcd(a[l],gcd([l+1,r]))$ a[l]=$\sum_{i=1}^{l}f[i]$,f[i]为差分数列f[i]=a[i]-a[i-1] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1#define INF 0x3f3f3f3ftypedef long long ll;using namespace std;const int maxn = 1e5+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int a[maxn],f[maxn];int Sum[maxn&lt;&lt;2],Max[maxn&lt;&lt;2],Gcd[maxn&lt;&lt;2];void push_up(int o)&#123; Sum[o]=Sum[o&lt;&lt;1]+Sum[o&lt;&lt;1|1]; Max[o]=max(Max[o&lt;&lt;1],Max[o&lt;&lt;1|1]); Gcd[o]=__gcd(Gcd[o&lt;&lt;1],Gcd[o&lt;&lt;1|1]);&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; Sum[o]=f[l]; Max[o]=Gcd[o]=abs(Sum[o]); return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;void update(int p,int v,int l,int r,int o)&#123; if(l==r)&#123; Sum[o]+=v; Max[o]=Gcd[o]=abs(Sum[o]); return; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) update(p,v,lson); else update(p,v,rson); push_up(o);&#125;int querymax(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Max[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=0; if(L&lt;=mid) ret=max(ret,querymax(L,R,lson)); if(R&gt;mid) ret=max(ret,querymax(L,R,rson)); return ret;&#125;int querysum(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Sum[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=0; if(L&lt;=mid) ret+=querysum(L,R,lson); if(R&gt;mid) ret+=querysum(L,R,rson); return ret;&#125;int querygcd(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Gcd[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=0; if(L&lt;=mid) ret=__gcd(ret,querygcd(L,R,lson)); if(R&gt;mid) ret=__gcd(ret,querygcd(L,R,rson)); return ret;&#125;int main()&#123; int n=read(),m=read(); for(int i=1;i&lt;=n;i++)&#123; a[i]=read(); f[i]=a[i]-a[i-1]; &#125; build(1,n,1); while(m--)&#123; int op=read(),l=read(),r=read(); if(op==1)&#123; int x=read(); update(l,x,1,n,1); if(r+1&lt;=n) update(r+1,-x,1,n,1); &#125; else if(op==2)&#123; if(l==r) puts("0"); else printf("%d\n",querymax(l+1,r,1,n,1)); &#125; else&#123; if(l==r) printf("%d\n",querysum(1,l,1,n,1)); else printf("%d\n",__gcd(querysum(1,l,1,n,1),querygcd(l+1,r,1,n,1))); &#125; &#125;&#125; 复习一下线段树~好久没写的样子 C-Tokitsukaze and Discard Items123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5+5;ll a[maxn];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); ll n,m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;a[i]; &#125; int ans=0,cnt=0; int i=1; while(i&lt;=m)&#123; ll r = ((a[i]-cnt-1)/k+1)*k+cnt; //计算第一个特殊数所在页上限 while(i&lt;=m&amp;&amp;a[i]&lt;=r)&#123; cnt++; i++; &#125; ans++; &#125; cout&lt;&lt;ans&lt;&lt;'\n';&#125; D-Tokitsukaze, CSL and Stone Game12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5+5;int a[maxn];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int n;cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; sort(a,a+n); if(n&gt;=2&amp;&amp;a[0]==0&amp;&amp;a[1]==0)&#123;//注意特判 puts("cslnb"); return 0; &#125; ll sum=0; int has2=0;//相同数对的个数 for(int i=0;i&lt;n;i++)&#123; sum+=a[i]-i; //贪心选取,要使不重复,最后每堆数目留下的肯定是0,1,2,... if(i&lt;n-1&amp;&amp;a[i]==a[i+1]) has2++; if(i&gt;0&amp;&amp;i&lt;n-1&amp;&amp;a[i]==a[i+1]&amp;&amp;a[i-1]+1==a[i])&#123;//x,x+1,x+1这种情况无论怎么取都先手输 puts("cslnb"); return 0; &#125; &#125; if((sum&amp;1)==0 || has2&gt;=2) puts("cslnb"); else puts("sjfnb");&#125; 补完Div2的CD发现真的不难，因为读错题和读题太慢很影响心态，下次还得细心点啊]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>二分</tag>
        <tag>树状数组</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法学习(转)]]></title>
    <url>%2Fposts%2F76aac626.html</url>
    <content type="text"><![CDATA[b站上无意翻到新疆小姐姐莎依拜 (Sahiba Anwar)的英语语法视频《一堂课让你懂得英语语法百分之九十五》，全长103分钟，语速较慢，2倍速下不到1小时可以看完。中学上的语法课都是零零散散的，整体总结一下，感觉知识体系清晰了很多。（BTW，小姐姐声音真好听） 概要 语法是一座体系，是一座大楼，但是中学期间学习的语法是零散的，我们学习的内容都是砖块，无法看到英语语法的大楼。这个视频能够让我们快速认识语法大楼的全貌（相当于理解了95%）。剩余的5%，都是小碎砖，再去细地探索。视频作者是新疆小姐姐莎依拜 (Sahiba Anwar)。本篇内容完全来自视频。 结构分类 按照结构分类时，所有英文句子能够分成三类： 简单句： 1主语 + 谓语 + 宾语 并列句： 1234主谓宾， 并列词 + 主谓宾 ————————————————⟶ ↓ ↳ e.g. and,or,but etc. ↓(简单句) (简单句) |-----------同等地位，并列关系------------| 复合句： 123主谓宾， 从句引导词 + 主谓宾 ————————————————⟶ ↓ ↳ e.g. which,when,where... ↓主句(主导地位，大哥，简单句) 从句(从属地位，小弟，简单句) 从句类型： 名词性从句（名词） 定语从句（形容词） 状语从句（副词） 主语：subject → 动作的发出者 ⇒ 我谓语： verb → 动作 ⇒ 踢宾语： object → 动作的承受者 ⇒ 球 主谓宾和它的五个兄弟（简单句的六个基本句型） 所有的英文句子无外乎主谓宾的问题，把主谓宾研究清楚了，把所有句子就搞清楚了。 句型112主（名） 谓（及物） 宾（名） I play games. 句型2123主（名） 谓（不及物） Spring comes. ↳此动作无承受者，所以没有宾语 句型312345678主（名） 系 表 ↳共3种 （名词；形容词；不定式；介宾[介词+名词]）&lt;1&gt; Be动词：am, is, are, was, were&lt;2&gt; 感官动词（五官）：look, sound, smell, taste, feel&lt;3&gt; 变化动词：become, turn, go, get, grow&lt;4&gt; 静止动词：stay, remain, keep* 不定式[to do], 但是如果遇到to + 动词ing，这里的to是介词。 句型4123 主 谓 宾 宾（名） (及物) （名） （名） I give you money 句型512345678主 谓 宾 补（名） （及物） （名） （1.形容词 2.不定式）|----结构完成，意思不完整---| |---补充说明意思---|1. The music makes me sad.2. He tells me to go. * He helps me (to) understand the problem. 特殊 句型61234567There be 句型，表达&quot;存在&quot;。There be 名词There is a dog.There be 名词 介宾There is a dog under the tree. 从句：引导词 + 主谓宾（或其五个兄弟）名词性从句 主语从句 宾语从句 表语从句 同位语从句 一模一样的句子，只不过位置不同，所以名称不同。 12345主 谓 宾语(名词) (及物动词) (名词)名词性从句 名词性从句 ↓ ↓主语从句 宾语从句 名词性从句常用的引导词有:that, whether, what 12345678e.g. 名词性从句： that he likes football (引导词) (名) (动) (名) | |------主谓宾(句子)-------| ⇒ 不能做句子成分* |-----------------------| | ⇓ ↲ 降级成 名词（可以做句子成分）* 为什么不能做句子成分？英文里一个句子只能有一个谓语动词，否则句子不成立。 主语从句 1234That he likes football surprised us.--------------------- ▲ ▲ 名词 及物动词 名词 （主语） （谓语）（宾语） 宾语从句 1234 He said that he likes football. ▲ ▲ ---------------------- 名词 及物动词 名词（主语）（谓语） （宾语） 表语从句 1234 The fact is that he likes football. -------- ▲ ▲ 名词 be动词 名词（主语） （系语） （表语） 同位语从句什么是同位语？同位语起解释说明名词的作用，和其解释的名词相等；同位语是[名词] 123456789101112如： 主， 同位语， 谓宾. Yusuf, a Uyghur man, loves spring. 主谓宾， 同位语 . Yusuf loves spring, on of the four season.上面的同位语是以插入语的形式。The fact that he likes football surprised us.-------- ---------------------- ▲ ▲ 名词 同位语从句 动词（谓） 名词（宾）He states the fact that he likes football. ▲ ▲ ▲ ------------------------* 同位语从句的引导词只有that。 定语从句什么是定语？修饰限定名词，红红的花定语Ⅰ：形容词（短一些）定语Ⅱ：短语或从句（长一些） 1234567891011121314151617181920**为什么要分两种呢**？因为英语忌讳头重脚轻，定语稍微长一点，马上往后挪。 定Ⅰ 主 定Ⅱ 谓 定Ⅰ 宾 定Ⅱ （名） （动） （名） A beautiful girl shared a fascinating story. --------- ▲ ----------- ▲ 定Ⅰ(形) 定Ⅰ(形) A girl from Mars shared a story about her people. ▲ --------- ▲ --------------- 定Ⅱ(介宾短语) 定Ⅱ(介宾短语) A task to tackle is the potential crisis. ▲ --------- --------- ▲ 定Ⅱ(不定式) 定Ⅰ(形) A girl who likes spring shared a story which moved us. ▲ ---------------- ▲ --------------- (定语从句) （定语从句） 状语从句 什么是状语？ 副词：修饰动词:walk slowly； 修饰形容词：slightly higher； 起副词作用的句子：状语从句 按作用划分： 时间状语(从句)：何时？ 地点状语(从句)：在哪？ 原因状语(从句)：为啥？因为…； 条件状语(从句)：在什么情况下？如果…；只要…；只有…； 目的状语(从句)：为了啥？为了…；这样就能…； 结果状语(从句)：导致了啥？结果…；以至于…； 让步状语(从句)：转折的前奏，强调前的东西不重要。虽然…； 方式状语(从句)：怎么做的（发生的）？用…；通过…； 状语从句是存在于简单句（主谓宾）之外的。 例子： 1234Yusuf smiles happily. 副词修饰动词，出现在动词之后Yusuf quickly understood. 副词修饰动词，出现在动词之前She is strikingly beautiful. 副词修饰形容词，表示程度：强He is pretty tall. 副词修饰形容词，表示程度：弱 123456789101112131415He came yesterday. 时间副词，位置灵活Yesterday he came.He called me when I was sleeping. 时间状语从句He celebrated hes birthday at school. 地点副词，位置灵活At school he celebrated his birthday.We met where we used to go for a walk. 地点状语从句He likes spring for its beauty.He likes srping for it is beautiful.He likes spring because it is beautiful.He likes spring as it is beautiful.He likes spring since it is beautiful. 都是从句，原因除了since前后都可以外，其他的都靠后Because开头的不是状语从句，而是一个名词性句子 12If you win, there will be a reward. 条件状语从句As long as you win, there will be a reward. 条件状语从句 1234I study for my well-being. I don&apos;t spend extra to save money. (to is short for in order to)I don&apos;t spend extra in order to save money. (in order to 可以提前)I don&apos;t spend extra so that I can save money. 目的状语从句 12He tried so hard that he finally succeeded. 结果状语从句这里的so...that...和目的状语从句的so that不同，目的状语从句中的so that不能加任何东西，so that共同引导。 12Although you have a point there, I don&apos;t agree with your proposal.让步状语从句，不需转折词。重点在转折后面的东西。 1234567I learned English through an online course.I contact my friends via Wechat.I draw with my pen.I found differences by contasting the two.She looks at me as if she knows me.He finished the work as I told him to.方式状语 三个特殊句式（对六种基本句型的操纵） 强调句 12345678He hit me.It was him that hit me.I learned about this project through this site.It was through this site that I learned about this project.It is 名 that 动(名)It is 介宾 that 主谓(宾) 倒装句 1234567891011正常句序：主 谓 (宾)倒装句序：谓 主 (宾） -&gt; 强调加强语气的作用正常：We can win only when we try harder. (情态动词+实意动词 才算一个谓语)倒装：Only when we try harder can we win. 部分倒装正常：The bus comes.倒装： Here comes the bus.正常：The Queen live long!倒装：Long live The Queen! 虚拟语句 假设一个有可能发生的事情–&gt;条件状语If it rains, the event will be canceled. (主将从现) 假设一件不可能发生的事-&gt;虚拟语气现在不可能： If I were a boy, I would be a soldier. (过去时)过去不可能（和既成事实相反）If I had studied English, it would have been easier now.If I hadn’t had that extra cake, I wouldn’t have been feeling guilty.(过去完成) （过去时 + 完成时） 时态 一般（习惯性） 进行（正在发生） 完成（有结果） 完成进行时（持续性：一直在做） 语态 主动语态 1I finished my task. 被动语态 1My task is finished. 非谓语分词： 现在分词（doing）：和主句主语为主动关系 过去分词（done）：和主句主语为被动关系 1234567The boy was lost, failing to find the way back home. ---------------------------------- 非谓语The boy was lost, failed by his poor memory. ------------------------- 非谓语 至此，语法大楼搭建结束，赶紧去拾小砖块。]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-1182C Beautiful Lyrics]]></title>
    <url>%2Fposts%2F7ba5fd12.html</url>
    <content type="text"><![CDATA[原题链接 题意： 给出最多1e5个字符串，问求最多能构成多少个字符串四元组，要求四元组的前两个字符串中的元音字母个数相同，后两个元音字母个数相同且还要每个字符串的最后一个元音字母相同 思路： 先对所有字符串用STL嵌套分类，把符合后两个字符串条件的优先先分到一块，然后剩下的元音字母数量相同的在分到一块，最后两两合并 #auto &amp; 表示可以修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;bool isvowel(char ch)&#123; return (ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u');&#125;int getcount(string &amp;str)&#123; int res=0; for(auto ch:str) if(isvowel(ch)) res++; return res;&#125;char getlast(string &amp;str)&#123; for(int i=str.length()-1;i&gt;=0;i--)&#123; if(isvowel(str[i])) return str[i]; &#125;&#125;unordered_map&lt;int,unordered_map&lt;char,vector&lt;string&gt;&gt;&gt; all;vector&lt;pair&lt;string,string&gt;&gt; both1,both2,ans;string a,b;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; string str; cin&gt;&gt;str; all[getcount(str)][getlast(str)].push_back(str); &#125; for(auto &amp;same_count:all)&#123; for(auto &amp;same_last:same_count.second)&#123; while(same_last.second.size()&gt;=2)&#123; a=same_last.second.back(); same_last.second.pop_back(); b=same_last.second.back(); same_last.second.pop_back(); both2.push_back(&#123;a,b&#125;); &#125; &#125; vector&lt;string&gt;rest; for(auto &amp;same_last:same_count.second)&#123; if(same_last.second.size())&#123; rest.push_back(same_last.second.back()); &#125; &#125; while(rest.size()&gt;=2)&#123; a=rest.back(); rest.pop_back(); b=rest.back(); rest.pop_back(); both1.push_back(&#123;a,b&#125;); &#125; &#125; pair&lt;string,string&gt; b1,b2; while(both1.size()&amp;&amp;both2.size())&#123; b1=both1.back(); both1.pop_back(); b2=both2.back(); both2.pop_back(); ans.push_back(&#123;b1.first,b2.first&#125;); ans.push_back(&#123;b1.second,b2.second&#125;); &#125; while(both2.size()&gt;=2)&#123; b1=both2.back(); both2.pop_back(); b2=both2.back(); both2.pop_back(); ans.push_back(&#123;b1.first,b2.first&#125;); ans.push_back(&#123;b1.second,b2.second&#125;); &#125; cout&lt;&lt;ans.size()/2&lt;&lt;'\n'; for(auto s:ans)&#123; cout&lt;&lt;s.first&lt;&lt;' '&lt;&lt;s.second&lt;&lt;'\n'; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>STL</tag>
        <tag>cf</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[湘潭大学2019程序设计实践]]></title>
    <url>%2Fposts%2F5f8600d5.html</url>
    <content type="text"><![CDATA[抄袭一时爽，查重火葬场因考前会查重，故仅提供思路参考，代码后续补上，有问题欢迎下方评论留言 ericxie官方解析点这里 食用此篇博文代码前建议上网自学一些C++STL容器(set、vector、map等)的用法 1262 Fish贪心，优先队列维护每个池塘能钓到鱼的数量即可，当前池塘有最多鱼的池塘优先出队列 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e3+5;struct fish&#123; int a,b; fish()&#123;&#125; fish(int a,int b):a(a),b(b)&#123;&#125; bool operator &lt; (const fish &amp;hs)const&#123; return a&lt;hs.a; &#125;&#125;;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; priority_queue&lt;fish&gt;pq; int n,m,a,b; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;a,&amp;b); pq.push(fish(a,b)); &#125; int ans=0; fish now; while(m--)&#123; now=pq.top(); pq.pop(); ans+=now.a; now.a=max(0,now.a-now.b); pq.push(now); &#125; printf("%d\n",ans); &#125;&#125; 1271 Color结论：n*m-(x的种类数)*(y的种类数) 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e3+5;set&lt;int&gt;x,y;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; x.clear(); y.clear(); int n,m,k,a,b; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=0;i&lt;k;i++)&#123; scanf("%d%d",&amp;a,&amp;b); x.insert(a); y.insert(b); &#125; printf("%d\n",n*m-x.size()*y.size()); &#125;&#125; 1163 ASCLL直接模拟，输出%05X和%02X即带前导0的十六进制，回车的ASCLL码也要输出，注意输出空格和回车的地方 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+5;string s;int main()&#123; char ch; while(ch=getchar())&#123; if(ch==-1) break; else s+=ch; &#125; int id=0,cnt=0; int lens=s.length(); for(int i=0;i&lt;lens;i++)&#123; if(cnt==0) printf("%05X ",id++); printf("%02X",(int)s[i]); cnt++; if(i!=lens-1)&#123; if(cnt!=16) printf(" "); else&#123; cnt=0; printf("\n"); &#125; &#125; &#125;&#125; 1243 Bob’s Password枚举九个数字会非法的情况即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+5;char s[10];int vis[10];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; for(int i=0;i&lt;10;i++) vis[i]=0; scanf("%s",s); int lens=strlen(s); bool ok=true; for(int i=0;i&lt;lens;i++)&#123; int a=s[i]-'0'; if(i==0)&#123; vis[a]=1; continue; &#125; if(a==1)&#123; if((!vis[2]&amp;&amp;s[i-1]=='3')||(!vis[4]&amp;&amp;s[i-1]=='7')||(!vis[5]&amp;&amp;s[i-1]=='9'))&#123; ok=false; break; &#125; &#125; else if(a==2)&#123; if(!vis[5]&amp;&amp;s[i-1]=='8')&#123; ok=false; break; &#125; &#125; else if(a==3)&#123; if((!vis[2]&amp;&amp;s[i-1]=='1')||(!vis[5]&amp;&amp;s[i-1]=='7')||(!vis[6]&amp;&amp;s[i-1]=='9'))&#123; ok=false; break; &#125; &#125; else if(a==4)&#123; if(!vis[5]&amp;&amp;s[i-1]=='6')&#123; ok=false; break; &#125; &#125; else if(a==6)&#123; if(!vis[5]&amp;&amp;s[i-1]=='4')&#123; ok=false; break; &#125; &#125; else if(a==7)&#123; if((!vis[4]&amp;&amp;s[i-1]=='1')||(!vis[5]&amp;&amp;s[i-1]=='3')||(!vis[8]&amp;&amp;s[i-1]=='9'))&#123; ok=false; break; &#125; &#125; else if(a==8)&#123; if(!vis[5]&amp;&amp;s[i-1]=='2')&#123; ok=false; break; &#125; &#125; else if(a==9)&#123; if((!vis[5]&amp;&amp;s[i-1]=='1')||(!vis[6]&amp;&amp;s[i-1]=='3')||(!vis[8]&amp;&amp;s[i-1]=='7'))&#123; ok=false; break; &#125; &#125; vis[a]=1; &#125; if(ok) puts("Yes"); else puts("No"); &#125;&#125; 1246 Matrix Transposition看半天题意，n,m没用，将输入的x看做y，输入的y看做x，反过来按y优先排序即可 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+5;struct node&#123; int x,y,v; node()&#123;&#125; node(int x,int y,int v):x(x),y(y),v(v)&#123;&#125; bool operator &lt; (const node &amp;b) const&#123; if(y!=b.y) return y&lt;b.y; return x&lt;b.x; &#125;&#125;p[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,m,k; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=0;i&lt;k;i++)&#123; int x,y,v; scanf("%d%d%d",&amp;x,&amp;y,&amp;v); p[i]=node(x,y,v); &#125; sort(p,p+k); for(int i=0;i&lt;k;i++)&#123; printf("%d %d %d\n",p[i].y,p[i].x,p[i].v); &#125; puts(""); &#125;&#125; 1248 Alice and Bob直接模拟，将1作为数字7处理会很好写很多，注意求和依然是+1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;int cnta[10],cntb[10];int suma,sumb;bool pd1()&#123; int a=0,b=0; for(int i=2;i&lt;=7;i++)&#123; if(cnta[i]==3)a=i; if(cntb[i]==3)b=i; &#125; if(a||b)&#123; if(a&amp;&amp;b)&#123; if(a&gt;b) puts("Alice"); else if(a&lt;b) puts("Bob"); else puts("Draw"); &#125; else if(a) puts("Alice"); else if(b) puts("Bob"); return true; &#125; return false;&#125;bool pd2()&#123; int a=0,aa=0,b=0,bb=0; for(int i=2;i&lt;=7;i++)&#123; if(cnta[i]==2)a=i; if(cntb[i]==2)b=i; if(cnta[i]==1)aa=i; if(cntb[i]==1)bb=i; &#125; if(a||b)&#123; if(a&amp;&amp;b)&#123; if(a&gt;b) puts("Alice"); else if(a&lt;b) puts("Bob"); else &#123; if(aa&gt;bb) puts("Alice"); else if(aa&lt;bb) puts("Bob"); else puts("Draw"); &#125; &#125; else if(a) puts("Alice"); else if(b) puts("Bob"); return true; &#125; return false;&#125;bool pd3()&#123; if(suma&gt;sumb) puts("Alice"); else if(suma&lt;sumb) puts("Bob"); else puts("Draw"); return true;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; for(int i=0;i&lt;10;i++) cnta[i]=cntb[i]=0; suma=0,sumb=0; for(int i=0;i&lt;3;i++)&#123; int x; scanf("%d",&amp;x); suma+=x; if(x==1) x=7; cnta[x]++; &#125; for(int i=0;i&lt;3;i++)&#123; int x; scanf("%d",&amp;x); sumb+=x; if(x==1) x=7; cntb[x]++; &#125; if(pd1()); else if(pd2()); else if(pd3()); &#125;&#125; 1251 Colombian Number简单数学，注意到[1,1000000000]区间内数位和在[1,81]内，所以只需在区间[n-81,n]内枚举k看是否能使k+sum(k)==n成立即可 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int calc(int x)&#123; int sum=0; while(x)&#123; sum+=x%10; x/=10; &#125; return sum;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); bool ok=false; for(int i=max(1,n-100);i&lt;n;i++)&#123; if(i+calc(i)==n)&#123; ok=true; break; &#125; &#125; if(ok) puts("No"); else puts("Yes"); &#125;&#125; 1253 Robot贪心，如果在中途转弯肯定不如每次从头走到尾，可以证明最多转n-1次，时间复杂度O($n^2$) 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3+5;int vis[maxn],a[maxn];int main()&#123; int n; while(~scanf("%d",&amp;n))&#123; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; int cnt=0,ans=0; while(1)&#123; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i]&amp;&amp;cnt&gt;=a[i])&#123; vis[i]=1; cnt++; &#125; &#125; if(cnt==n) break; else ans++; for(int i=n;i&gt;=1;i--)&#123; if(!vis[i]&amp;&amp;cnt&gt;=a[i])&#123; vis[i]=1; cnt++; &#125; &#125; if(cnt==n) break; else ans++; &#125; printf("%d\n",ans); &#125;&#125; 1252 Matrix Word统计每个字符在每一行每一列的出现次数，最后判断是否都为1即可 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;char s[maxn][maxn];int x[maxn][26],y[maxn][26];int main()&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; memset(x,0,sizeof(x)); memset(y,0,sizeof(y)); for(int i=1;i&lt;=n;i++)&#123; scanf("%s",s[i]+1); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; x[i][s[i][j]-'a']++; y[j][s[i][j]-'a']++; &#125; &#125; string ans=""; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; if(x[i][s[i][j]-'a']==1 &amp;&amp; y[j][s[i][j]-'a']==1) ans+=s[i][j]; &#125; &#125; cout&lt;&lt;ans&lt;&lt;'\n'; &#125;&#125; 1261 Duplicate Elementsunordered_map或map或set记录每个值是否出现即可,当然也可以用其他的哈希方法 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;using namespace std;const int maxn = 1e4+5;unordered_map&lt;int,int&gt;mp;vector&lt;int&gt;ans;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int main()&#123; int T;T=read(); while(T--)&#123; mp.clear(); int n;n=read(); ans.clear(); for(int i=0;i&lt;n;i++)&#123; int x;x=read(); if(mp.find(x)==mp.end())&#123; ans.push_back(x); mp[x]=1; &#125; &#125; for(int i=0;i&lt;ans.size();i++)&#123; printf("%d%c",ans[i],i==ans.size()-1?'\n':' '); &#125; &#125;&#125; 1263 矩形面积的并哪一年的蓝桥杯原题来着，求出相交矩形的边界,判掉不会相交的情况，在不知道位置相对位置的情况下计算面积注意取绝对值，面积并=两矩形面积和-两矩形面积交 l=max(min(x1,x2),min(x3,x4));r=min(max(x1,x2),max(x3,x4));d=max(min(y1,y2),min(y3,y4));u=min(max(y1,y2),max(y3,y4)); 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int main()&#123; int x1,y1,x2,y2,x3,y3,x4,y4,a,b,c,d; while(~scanf("%d%d%d%d%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;x3,&amp;y3,&amp;x4,&amp;y4))&#123; a=max(min(x1,x2),min(x3,x4)); b=min(max(x1,x2),max(x3,x4)); c=max(min(y1,y2),min(y3,y4)); d=min(max(y1,y2),max(y3,y4)); int sum=abs(x2-x1)*abs(y2-y1)+abs(x4-x3)*abs(y4-y3); if(a&gt;=b||c&gt;=d) printf("%d\n",sum); else printf("%d\n",sum-(b-a)*(d-c)); &#125;&#125; 1268 鞍点输入的时候就记录每行每列的最值即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int minx[maxn],miny[maxn],maxx[maxn],maxy[maxn];int a[maxn][maxn];struct Ans&#123; int x,y,v; Ans()&#123;&#125; Ans(int x,int y,int v):x(x),y(y),v(v)&#123;&#125;&#125;ans[maxn*maxn];inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int main()&#123; int T;T=read(); while(T--)&#123; int n,m;n=read(),m=read(); for(int i=0;i&lt;n;i++) minx[i]=1001,maxx[i]=-1; for(int j=0;j&lt;m;j++) miny[j]=1001,maxy[j]=-1; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; a[i][j]=read(); minx[i]=min(minx[i],a[i][j]); miny[j]=min(miny[j],a[i][j]); maxx[i]=max(maxx[i],a[i][j]); maxy[j]=max(maxy[j],a[i][j]); &#125; &#125; int cnt=0; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if((a[i][j]==minx[i]&amp;&amp;a[i][j]==maxy[j])||(a[i][j]==maxx[i]&amp;&amp;a[i][j]==miny[j]))&#123; ans[cnt++]=Ans(i,j,a[i][j]); &#125; &#125; &#125; if(!cnt) puts("None"); else&#123; printf("%d\n",cnt); for(int i=0;i&lt;cnt;i++)&#123; printf("%d %d %d\n",ans[i].x,ans[i].y,ans[i].v); &#125; &#125; &#125;&#125; 1272 Robot统计L,R,U,D的个数，假定其中有一种没有，那么剩下三种中使多余的那一种变为另外两种的其中一种看是否这两种数目相等 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char s[205]; int L,R,U,D; while(~scanf(&quot;%s&quot;,s))&#123; L=R=U=D=0; int lens=strlen(s); for(int i=0;i&lt;lens;i++)&#123; if(s[i]==&apos;L&apos;) L++; else if(s[i]==&apos;R&apos;) R++; else if(s[i]==&apos;U&apos;) U++; else D++; &#125; bool ok=false; if(!L)&#123; if(R+U==D||R+D==U) ok=true; &#125; else if(!R)&#123; if(L+U==D||L+D==U) ok=true; &#125; else if(!U)&#123; if(R+D==L||L+D==R) ok=true; &#125; else if(!D)&#123; if(R+U==L||L+U==R) ok=true; &#125; if(ok) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125;&#125; 1277 Tri-Triangle找规律然后直接输出 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main() &#123; char ch; while(scanf("%c",&amp;ch)!=EOF) &#123; int n=ch-'A'+1; int space=2*n-1; for(int i=1; i&lt;=n; i++) &#123; for(int j=1;j&lt;=space;j++) printf(" "); for(int k=1;k&lt;=i;k++) printf("%c",64+k); for(int k=i-1;k&gt;=1;k--) printf("%c",64+k); puts(""); space--; &#125; space=n-1; for(int i=1; i&lt;=n; i++) &#123; for(int j=1;j&lt;=space;j++) printf(" "); for(int k=1;k&lt;=i;k++) printf("%c",64+k); for(int k=i-1;k&gt;=1;k--) printf("%c",64+k); for(int j=1;j&lt;=2*space+1;j++) printf(" "); for(int k=1;k&lt;=i;k++) printf("%c",64+k); for(int k=i-1;k&gt;=1;k--) printf("%c",64+k); puts(""); space--; &#125; &#125;&#125; 1280 String Hash就是26进制转10进制 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;typedef __int64 ll;const int P = 1e9+7;const int maxn = 1e3+5;char s[maxn];int main()&#123; while(~scanf("%s",s+1)) &#123; s[0]='b'; int lens=strlen(s); ll ans=0; for(int i=0;i&lt;lens;i++)&#123; ans=(ans*26%P+(s[i]-'a'))%P; &#125; printf("%lld\n",ans); &#125;&#125; 1281 Cute String输入用gets或者循环getchar()，跳过字符串首部空格后，统计中间空格个数便可知道单词个数，看空格个数是否&gt;9和字母种类个数&gt;10即可 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;unordered_map&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; char s[205],ch; while(1)&#123; int cnt=0; ch=getchar(); if(ch==-1) break; s[cnt++]=ch; while(ch=getchar())&#123; if(ch=='\n') break; s[cnt++]=ch; &#125; s[cnt]='\0'; int space=0,lens=strlen(s); int p=0; unordered_map&lt;char,int&gt;mp; while(s[p++]==' '); for(int i=p;i&lt;lens;i++)&#123; if(s[i]==' ') space++; else mp[s[i]]=1; &#125; if(mp.size()&gt;10||space&gt;9) puts("No"); else puts("Yes"); &#125;&#125; 1284 多项式直接求和，求和过程中取模 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;using namespace std;typedef __int64 ll;const int maxn = 1e4+5;ll qpow(ll a,ll b,ll p)&#123; ll res=1%p; while(b)&#123; if(b&amp;1) res=res*a%p; a=a*a%p; b&gt;&gt;=1; &#125; return res;&#125;int a[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,m,x; scanf("%d%d%d",&amp;n,&amp;m,&amp;x); for(int i=n;i&gt;=0;i--) scanf("%d",&amp;a[i]); ll ans=0; for(int i=0;i&lt;=n;i++)&#123; ans=(ans+a[i]*qpow(x,i,m)%m)%m; &#125; printf("%lld\n",ans); &#125;&#125; 1286 比赛当时找的规律+猜结论？ 好像是dp[i]表示冠军最多打i场需要的最多选手人数，那么容易退推出前几项dp[0]=1,dp[1]=2,dp[2]=4… dp[i]=dp[i-1]+dp[i-2]+1，如果n&lt;=dp[i]，那么答案就是i 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;typedef __int64 ll;ll f[105];int main()&#123; f[0]=1; f[1]=2; for(int i=2;i&lt;=85;i++) f[i]=f[i-1]+f[i-2]+1; ll n; while(~scanf("%I64d",&amp;n))&#123; for(int i=0;i&lt;=85;i++)&#123; if(n&lt;=f[i])&#123; printf("%d\n",i); break; &#125; &#125; &#125;&#125; 1291 Buying Gifts要想最大值和最小值相差最小，那么连续的m长连续段礼物价格序列是最有可能的 将价格升序排序后以长度m尺取找出最小价格差即可，由于排好序所以总和肯定取之前的更小 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#define inf 0x3f3f3f3fusing namespace std;typedef __int64 ll;const int maxn = 1e3+5;int a[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); &#125; sort(a,a+n); int d=inf,pos=0; for(int i=0;i&lt;n-m+1;i++)&#123; if(a[i+m-1]-a[i]&lt;d)&#123; d=a[i+m-1]-a[i]; pos=i; &#125; &#125; int sum=0; for(int i=pos;i&lt;=pos+m-1;i++) sum+=a[i]; printf("%d %d\n",d,sum); &#125;&#125; 1292 Co-stringhash预处理+枚举最大长度或者暴力枚举左右端点+剪枝 看statu应该有更简单的解法（直接枚举最大可能长度，找到了就退出 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;string.h&gt;const int maxn = 1e3+5;typedef unsigned long long ull;using namespace std;char s[maxn];int lens;ull base=233;ull p[maxn],hs[maxn];ull geths(int l,int r)&#123; return (ull)hs[r]-p[r-l+1]*hs[l-1];&#125;bool pd(int k)&#123; for(int i=1;i+2*k-1&lt;=lens;i++)&#123; if(geths(i,i+k-1)==geths(i+k,i+2*k-1)) return true; &#125; return false;&#125;int main()&#123; p[0]=1; for(int i=1;i&lt;maxn;i++)&#123; p[i]=p[i-1]*base; &#125; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%s",s+1); lens=strlen(s+1); for(int i=1;i&lt;=lens;i++)&#123; hs[i]=hs[i-1]*base+s[i]; &#125; bool ok=false; for(int i=lens/2;i&gt;=1;i--)&#123; if(pd(i))&#123; ok=true; printf("%d\n",i*2); break; &#125; &#125; if(!ok) puts("0"); &#125;&#125; 1293 Diamond找规律直接输出 1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int T,n; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); for(int i=1; i&lt;=n; i++) &#123; for(int j=1;j&lt;=n-i;j++)printf(" "); for(int j=1;j&lt;=i;j++) printf("%c",65+n-j); for(int j=1;j&lt;=i-1;j++)printf("%c",65+n-i+j); puts(""); &#125; for(int i=n-1;i&gt;=1;i--) &#123; for(int j=1;j&lt;=n-i;j++)printf(" "); for(int j=1;j&lt;=i;j++) printf("%c",65+n-j); for(int j=1;j&lt;=i-1;j++)printf("%c",65+n-i+j); puts(""); &#125; &#125;&#125; 1294 Enquiry维护一个前缀和,sum[i]表示1…i有多少男女相邻的个数 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;const int maxn = 1e4+5;char s[maxn];int sum[maxn];int main()&#123; int T,n; scanf("%d",&amp;T); while(T--)&#123; scanf("%s",s); int lens=strlen(s),cnt=0; sum[0]=0; for(int i=1; i&lt;lens; i++)&#123; if(s[i]!=s[i-1]) cnt++; sum[i]=cnt; &#125; scanf("%d",&amp;n); while(n--) &#123; int l,r; scanf("%d%d",&amp;l,&amp;r); printf("%d\n",sum[r-1]-sum[l-1]); &#125; &#125;&#125; 1296 GCD容斥，与6互素就不会有和6一样的因子2,3，所以[l,r]区间的数减去2和3的倍数再加上6的倍数(计算2和3的倍数时多减了一次)即为答案 12345678910111213#include&lt;stdio.h&gt;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); int cnt2=r/2-(l-1)/2; int cnt3=r/3-(l-1)/3; int cnt6=r/6-(l-1)/6; printf("%d\n",r-l+1-cnt2-cnt3+cnt6); &#125;&#125; 1299 String按题意模拟即可 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char s[105]; while(~scanf("%s",s))&#123; char op[5]; int lens=strlen(s),step=0; while(scanf("%s",op)&amp;&amp;strcmp(op,"END")!=0)&#123; if(op[0]=='S')&#123; int l,r;char ch[5]; scanf("%d%d%s",&amp;l,&amp;r,ch);l--,r--; for(int i=l;i&lt;=r;i++) s[i]=ch[0]; &#125; else&#123; char ss[5],tt[5]; scanf("%s%s",ss,tt); for(int i=0;i&lt;lens;i++) if(s[i]==ss[0]) s[i]=tt[0]; &#125; printf("%d:%s\n",++step,s); &#125; puts(""); &#125;&#125; 1300 Dice按题意模拟即可 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int T; scanf("%d",&amp;T); char s[10]; int n,m,k,cnt[10]; while(T--)&#123; scanf("%s",s); for(int i=1;i&lt;=6;i++) cnt[i]=0; for(int i=0;i&lt;6;i++) cnt[s[i]-'0']++; scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;n,&amp;k); int num=cnt[k]; if(k!=1) num+=cnt[1]; printf("%d:%s\n",i,num&gt;=n?"true":"false"); &#125; puts(""); &#125;&#125; 1301 Zeroes按题意模拟循环1000次即可 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;algorithm&gt;int main()&#123; int T; scanf("%d",&amp;T); int a[20]; while(T--)&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); bool ok; for(int k=0;k&lt;=1000;k++)&#123; ok=true; for(int i=0;i&lt;n;i++)&#123; if(a[i]) ok=false; &#125; if(ok)&#123; printf("%d\n",k); break; &#125; int tmp=a[0]; for(int i=0;i&lt;n-1;i++)&#123; a[i]=abs(a[i]-a[i+1]); &#125; a[n-1]=abs(a[n-1]-tmp); &#125; if(!ok) puts("Impossible"); &#125;&#125; 1305 斐波那契区间直接扫描一遍即可，注意防止越界，如果中途a[i]+a[i+1]!=a[i+2],那么左端点起点重新从i+1开始 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;algorithm&gt;const int maxn = 1e4+5;int a[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); int ans=0; for(int i=0;i&lt;n;i++)&#123; int cnt=2; while(i+2&lt;n&amp;&amp;a[i]+a[i+1]==a[i+2])&#123; cnt++; i++; &#125; if(cnt&gt;ans) ans=cnt; &#125; printf("%d\n",ans); &#125;&#125; 1308 比赛按题意模拟计算即可 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;algorithm&gt;const int maxn = 1e4+5;int a[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); int rounds=0,fields=0; while(n&gt;1)&#123; int k=2; while(k&lt;=n) k*=2; k/=2; fields+=k/2; rounds++; n-=k/2; &#125; printf("%d %d\n",rounds,fields); &#125;&#125; 1239 2048巨恶心的大模拟，建议直接写相关函数每次调用，方便调试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;int a[5][5],tmp[5];void gatherL(int k)&#123; int cnt=0; for(int j=1;j&lt;=4;j++)&#123; if(a[k][j]) tmp[++cnt]=a[k][j]; a[k][j]=0; &#125; for(int i=1;i&lt;=cnt;i++) a[k][i]=tmp[i];&#125;void gatherR(int k)&#123; int cnt=4; for(int j=4;j&gt;=1;j--)&#123; if(a[k][j]) tmp[cnt--]=a[k][j]; a[k][j]=0; &#125; for(int i=4;i&gt;cnt;i--) a[k][i]=tmp[i];&#125;void gatherU(int k)&#123; int cnt=0; for(int i=1;i&lt;=4;i++)&#123; if(a[i][k]) tmp[++cnt]=a[i][k]; a[i][k]=0; &#125; for(int i=1;i&lt;=cnt;i++) a[i][k]=tmp[i];&#125;void gatherD(int k)&#123; int cnt=4; for(int i=4;i&gt;=1;i--)&#123; if(a[i][k]) tmp[cnt--]=a[i][k]; a[i][k]=0; &#125; for(int i=4;i&gt;cnt;i--) a[i][k]=tmp[i];&#125;void LEFT() &#123; for(int i=1;i&lt;=4;i++)&#123; gatherL(i); for(int j=1;j&lt;=3;j++)&#123; if(a[i][j]==a[i][j+1])&#123; a[i][j]*=2; a[i][j+1]=0; gatherL(i); &#125; &#125; &#125;&#125;void RIGHT() &#123; for(int i=1;i&lt;=4;i++)&#123; gatherR(i); for(int j=4;j&gt;=2;j--)&#123; if(a[i][j]==a[i][j-1])&#123; a[i][j]*=2; a[i][j-1]=0; gatherR(i); &#125; &#125; &#125;&#125;void UP() &#123; for(int j=1;j&lt;=4;j++)&#123; gatherU(j); for(int i=1;i&lt;=3;i++)&#123; if(a[i][j]==a[i+1][j])&#123; a[i][j]*=2; a[i+1][j]=0; gatherU(j); &#125; &#125; &#125;&#125;void DOWN() &#123; for(int j=1;j&lt;=4;j++)&#123; gatherD(j); for(int i=4;i&gt;=2;i--)&#123; if(a[i][j]==a[i-1][j])&#123; a[i][j]*=2; a[i-1][j]=0; gatherD(j); &#125; &#125; &#125;&#125;int main() &#123; int T; scanf("%d",&amp;T); while(T--) &#123; for(int i=1; i&lt;=4; i++) &#123; for(int j=1; j&lt;=4; j++) &#123; scanf("%d",&amp;a[i][j]); &#125; &#125; char op[10]; scanf("%s",op); if(op[0]=='L') LEFT(); else if(op[0]=='R') RIGHT(); else if(op[0]=='U') UP(); else DOWN(); for(int i=1; i&lt;=4; i++) &#123; for(int j=1; j&lt;=4; j++) &#123; printf("%d%c",a[i][j],j==4?'\n':' '); &#125; &#125; puts(""); &#125;&#125; 1264 字符不重复子串如果是简单的求长度就直接用两个指针+标记数组做就好了，有点像滑动窗口 这里要用动态规划，pre[s[i]]为前一个s[i]的位置，f[i]表示以s[i]结尾的最长不重复子串长度 那么对于s[i]有两种情况，一是s[i]在前面未出现，那么f[i]=f[i-1]+1；二是前面已经出现了s[i]，如果控制的区间左端点l在pre[s[i]]前面，说明当前控制的区间中有部分要跳过，f[i]=i-pre[s[i]]，区间要缩小，否则依然是f[i]=f[i-1]+1 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e4+5;char s[maxn];int pre[26],f[maxn];int main() &#123; ios::sync_with_stdio(false); cin.tie(0); while(cin&gt;&gt;s)&#123; for(int i=0;i&lt;26;i++) pre[i]=-1; int ans=1,lens=strlen(s); int l=0; pre[s[0]-'a']=0; f[0]=1; for(int i=1;i&lt;lens;i++)&#123; int ch=s[i]-'a'; if(pre[ch]==-1) f[i]=f[i-1]+1; else&#123; if(l&lt;=pre[ch])&#123; f[i]=i-pre[ch]; l=pre[ch]+1; &#125; else&#123; f[i]=f[i-1]+1; &#125; &#125; pre[s[i]-'a']=i; ans=max(ans,f[i]); &#125; string ss=s; set&lt;string&gt;anss; for(int i=0;i&lt;lens;i++)&#123; if(f[i]==ans)&#123; anss.insert(ss.substr(i-ans+1,ans)); &#125; &#125; cout&lt;&lt;ans&lt;&lt;'\n'; for(set&lt;string&gt;::iterator it=anss.begin();it!=anss.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;'\n'; &#125; &#125;&#125; 1273 Set用set或map或其他容器等统计数字种类数，种类数&lt;=3肯定可以，&gt;4肯定不行，==4特判一下 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;inline int read(int &amp;x)&#123; x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); vector&lt;int&gt;v; for(int i=0;i&lt;n;i++)&#123; int x;read(x); v.push_back(x); &#125; sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end()); bool ok=false; if(v.size()&lt;=3) ok=true; else if(v.size()&gt;4) ok=false; else &#123; if(v[0]+v[1]==v[2]+v[3]||v[0]+v[2]==v[1]+v[3]||v[0]+v[3]==v[1]+v[2]) ok=true; &#125; if(ok) puts("Yes"); else puts("No"); &#125;&#125; 1274 Matrix很容易看出规律$ans=1+2^2+2^2+1+4^2+4^2+1+…+(2n)^2+(2n)^2+1$ 由于$1^2+2^2+3^2+…+n^2=n(n+1)(2n+1)/6$ 可以推出$2^2+4^2+6^2+…+(2n)^2=2n(n+1)(2n+1)/3$ 因为答案要取模,又因为公式中有除法需用到数论中逆元的知识解决，即(a/b)%p=a*(b^(p-2))%p，p为素数 当然也可以直接上Java大数，最终结果再取模 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;typedef __int64 ll;const int P = 1e9+7;ll qmul(ll a,ll b,ll p)&#123; ll res=0; while(b)&#123; if(b&amp;1) res=res+a%p; a=a+a%p; b&gt;&gt;=1; &#125; return res;&#125;ll qpow(ll a,ll b,ll p)&#123; ll res=1; while(b)&#123; if(b&amp;1) res=res*a%p; a=a*a%p; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; ll n; while(scanf("%I64d",&amp;n)&amp;&amp;n)&#123; ll num1=(n+1)/2; ll m=n/2; ll ans=(num1+(4*(m*(m+1)%P*(2*m+1)%P)%P)*qpow(3,P-2,P)%P)%P; if(n%2==0) ans-=qmul(n,n,P); while(ans&lt;0) ans+=P; printf("%I64d\n",ans); &#125;&#125; 1275 Exam Schedule直接模拟 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;string.h&gt;int sche[10][20];struct Ans&#123; int d,s,t;&#125;ans[30];char table[5][10]=&#123;"Mon","Tue","Wen","Thur","Fri"&#125;;int pd(int d,int s,int t)&#123; for(int i=s;i&lt;=t;i++)&#123; if(sche[d][i]) return 0; &#125; return 1;&#125;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; memset(sche,0,sizeof(sche)); int n,k; scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;n;i++)&#123; char day[5];int s,t; scanf("%s%d%d",day,&amp;s,&amp;t); if(strcmp(day,"Mon")==0)&#123; for(int i=s;i&lt;=t;i++) sche[1][i]=1; &#125; else if(strcmp(day,"Tue")==0)&#123; for(int i=s;i&lt;=t;i++) sche[2][i]=1; &#125; else if(strcmp(day,"Wen")==0)&#123; for(int i=s;i&lt;=t;i++) sche[3][i]=1; &#125; else if(strcmp(day,"Thur")==0)&#123; for(int i=s;i&lt;=t;i++) sche[4][i]=1; &#125; else if(strcmp(day,"Fri")==0)&#123; for(int i=s;i&lt;=t;i++) sche[5][i]=1; &#125; &#125; int cnt=0; for(int d=1;d&lt;=5;d++)&#123; for(int i=1;i&lt;=4;i++)&#123; if(4-i+1&gt;=k&amp;&amp;pd(d,i,i+k-1))&#123; ans[cnt].d=d-1; ans[cnt].s=i; ans[cnt].t=i+k-1; cnt++; &#125; &#125; for(int i=5;i&lt;=8;i++)&#123; if(8-i+1&gt;=k&amp;&amp;pd(d,i,i+k-1))&#123; ans[cnt].d=d-1; ans[cnt].s=i; ans[cnt].t=i+k-1; cnt++; &#125; &#125; for(int i=9;i&lt;=11;i++)&#123; if(11-i+1&gt;=k&amp;&amp;pd(d,i,i+k-1))&#123; ans[cnt].d=d-1; ans[cnt].s=i; ans[cnt].t=i+k-1; cnt++; &#125; &#125; &#125; printf("%d\n",cnt); for(int i=0;i&lt;cnt;i++)&#123; printf("%s %d %d\n",table[ans[i].d],ans[i].s,ans[i].t); &#125; &#125;&#125; 1170 ICPC统计每列的最高等级和所有列最高等级的出现次数即可 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;char s[3][105];int cnt[5],Min[105];int main()&#123; int n; while(scanf("%d",&amp;n),n)&#123; for(int i=0;i&lt;3;i++)&#123; scanf("%s",s[i]); &#125; for(int i=0;i&lt;5;i++) cnt[i]=0; for(int j=0;j&lt;n;j++)&#123; Min[j]=10; for(int i=0;i&lt;3;i++)&#123; Min[j]=min(Min[j],s[i][j]-'A'); &#125; for(int i=0;i&lt;5;i++)&#123; if(Min[j]==i) cnt[i]++; &#125; &#125; for(int j=0;j&lt;n;j++) printf("%c",Min[j]+'A');puts(""); for(int i=0;i&lt;5;i++) printf("%d%c",cnt[i],i==4?'\n':' '); &#125;&#125; 1241 Permutation首先先学习一下置换的定义和置换乘法的性质，离散数学刘任任版P190 其实就是要通过不断映射使得序列回到初始序列 如果暴力模拟，可能会卡成O(n!)的复杂度，即全排列的情况 其实只需要计算对每一个数使a[i]变为i的次数，然后计算所有次数的最小公倍数即为答案 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;typedef __int64 ll;using namespace std;const int maxn = 105;int a[maxn];int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; int ans=1; for(int i=1;i&lt;=n;i++)&#123; int cnt=1,p=a[i]; while(p!=i)&#123; cnt++; p=a[p]; &#125; ans=ans/__gcd(ans,cnt)*cnt; &#125; printf("%d\n",ans); &#125;&#125; 1249 Alice’s Prime首先一位的素数只有2,3,5,7，然后dfs将这四个数后面不断添加1,3,5,7,9再判断素数，最后排个序 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;typedef __int64 ll;using namespace std;vector&lt;int&gt;ans;bool pd(ll x)&#123; for(ll i=2;i*i&lt;=x;i++)&#123; if(x%i==0) return false; &#125; return true;&#125;void dfs(ll x)&#123; if(x&gt;INT_MAX) return; for(int i=1;i&lt;=9;i+=2)&#123; if(pd(x*10+i))&#123; ans.push_back(x*10+i); dfs(x*10+i); &#125; &#125;&#125;int main() &#123; ans.push_back(2); ans.push_back(3); ans.push_back(5); ans.push_back(7); for(int i=0;i&lt;4;i++)&#123; dfs(ans[i]); &#125; sort(ans.begin(),ans.end()); for(int i=0;i&lt;ans.size();i++)&#123; printf("%d %d\n",i+1,ans[i]); &#125;&#125; 1266 RGB统计R,G,B的出现次数，在0…R-1统计G,B的出现次数，记为R1,R2，在R…R+G-1统计R,B的出现次数，记为G1,G2，在R+G…lens-1统计R,G的出现次数，记为B1,B2 那么首先肯定是两个两个区间互相交换，R1,G1交换，R2,B1交换和G2,B2交换，有可能交换不完，成为0…R-1还有’G’，R…R+G-1还有’B’，R+G…lens-1还有’R’的情况，那对于每个未交换字符的需要交换2次 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;typedef __int64 ll;using namespace std;const int maxn = 1e4+5;char s[maxn];int main() &#123; while(~scanf("%s",s))&#123; int lens=strlen(s); int R=0,G=0,B=0; for(int i=0;i&lt;lens;i++)&#123; if(s[i]=='R') R++; else if(s[i]=='G') G++; else B++; &#125; int R1=0,R2=0; //0...R-1 G,B for(int i=0;i&lt;R;i++)&#123; if(s[i]=='G') R1++; else if(s[i]=='B')R2++; &#125; int G1=0,G2=0; //R...R+G-1 R,B for(int i=R;i&lt;R+G;i++)&#123; if(s[i]=='R') G1++; else if(s[i]=='B') G2++; &#125; int B1=0,B2=0; //R+G...lens-1 R,G for(int i=R+G;i&lt;lens;i++)&#123; if(s[i]=='R') B1++; else if(s[i]=='G') B2++; &#125; int tmp=0,ans=0; if(R1&amp;&amp;G1)&#123; tmp=min(R1,G1); ans+=tmp; R1-=tmp; G1-=tmp; &#125; if(R2&amp;&amp;B1)&#123; tmp=min(R2,B1); ans+=tmp; R2-=tmp; B1-=tmp; &#125; if(G2&amp;&amp;B2)&#123; tmp=min(G2,B2); ans+=tmp; G2-=tmp; B2-=tmp; &#125; ans+=(R1+R2+G1+G2+B1+B2)/3*2; printf("%d\n",ans); &#125;&#125; 1267 Matrix直接模拟 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 15;int a[maxn][maxn],b[maxn][maxn];int tmp[maxn];int n,m;void swapx(int x,int y)&#123; for(int i=1;i&lt;=m;i++) tmp[i]=a[x][i]; for(int i=1;i&lt;=m;i++) a[x][i]=a[y][i]; for(int i=1;i&lt;=m;i++) a[y][i]=tmp[i];&#125;void swapy(int x,int y)&#123; for(int i=1;i&lt;=n;i++) tmp[i]=a[i][x]; for(int i=1;i&lt;=n;i++) a[i][x]=a[i][y]; for(int i=1;i&lt;=n;i++) a[i][y]=tmp[i];&#125;int main()&#123; char op[5]; int x,y; while(~scanf("%s",op))&#123; if(strcmp(op,"IN")==0)&#123; scanf("%d%d",&amp;n,&amp;m); int num=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; a[i][j]=++num; &#125; &#125; &#125; else if(strcmp(op,"SR")==0)&#123; scanf("%d%d",&amp;x,&amp;y); swapx(x,y); &#125; else if(strcmp(op,"SC")==0)&#123; scanf("%d%d",&amp;x,&amp;y); swapy(x,y); &#125; else if(strcmp(op,"TR")==0)&#123; for(int j=1;j&lt;=m;j++)&#123; for(int i=1;i&lt;=n;i++)&#123; b[j][i]=a[i][j]; &#125; &#125; swap(n,m); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; a[i][j]=b[i][j]; &#125; &#125; &#125; else if(strcmp(op,"FR")==0)&#123; for(int i=1,j=n;i&lt;=n/2;i++,j--)&#123; swapx(i,j); &#125; &#125; else if(strcmp(op,"FC")==0)&#123; for(int i=1,j=m;i&lt;=m/2;i++,j--)&#123; swapy(i,j); &#125; &#125; else if(strcmp(op,"PR")==0)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; printf("%d%c",a[i][j],j==m?'\n':' '); &#125; &#125; puts(""); &#125; &#125;&#125; 1279 Dual Prime素数打表，1e6以内最多不到1e5个素数，然后枚举任意两个不同的素数，弄个前缀和维护1..i 内符合条件的个数 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;int p[maxn],sum[maxn];int cnt=0;bool isp[maxn];void getprime()&#123; memset(isp,true,sizeof(isp)); isp[0]=isp[1]=false; isp[2]=true; for(int i=2;i&lt;maxn;i++)&#123; if(isp[i]) p[cnt++]=i; for(int j=0;j&lt;cnt&amp;&amp;p[j]*i&lt;maxn;j++)&#123; isp[p[j]*i]=false; &#125; &#125;&#125;void getsum()&#123; for(int i=0;i&lt;cnt;i++)&#123; for(int j=0;j&lt;cnt;j++)&#123; if(i==j) continue; if(p[i]*p[j]&lt;maxn) sum[p[i]*p[j]]=1; else break; &#125; &#125; for(int i=1;i&lt;maxn;i++)&#123; sum[i]+=sum[i-1]; &#125;&#125;int main() &#123; getprime(); getsum(); int T; scanf("%d",&amp;T); while(T--)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); printf("%d\n",sum[r]-sum[l-1]); &#125;&#125; 1283 Good Number首先n位数第一位必须是1，满足条件只需要n-1个数中的1的个数&gt;=0的个数，那么对n-1分奇偶谈论 n-1为奇，$ans=C_{n-1}^{n/2}+C_{n-1}^{n/2+1}+…+C_{n-1}^{n-1}$ n-1为偶，$ans=C_{n-1}^{n-1/2}+C_{n-1}^{n-1/2+1}+…+C_{n-1}^{n-1}$ n==1特判下，组合数用杨辉三角打表就好 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;ll C[70][70];void getC()&#123; for(int i=1;i&lt;=65;i++)&#123; C[i][0]=C[i][i]=1; for(int j=1;j&lt;i;j++)&#123; C[i][j]=C[i-1][j-1]+C[i-1][j]; &#125; &#125;&#125;int main() &#123; getC(); int n; while(~scanf("%d",&amp;n))&#123; if(n==1)&#123; puts("1"); continue; &#125; ll ans=0; if(n-1%2)&#123; for(int i=n/2;i&lt;=n-1;i++)&#123; ans+=C[n-1][i]; &#125; &#125; else&#123; for(int i=(n-1)/2;i&lt;=n-1;i++)&#123; ans+=C[n-1][i]; &#125; &#125; printf("%I64d\n",ans); &#125;&#125; 1287 银行因为所有业务在当天，则可以把时间化为分钟数，然后枚举一天的所有分钟24*60=1440 对于每一分钟，如果有新的用户来了，则加入优先队列；如果过了上一个业务办理的时间，把队列中等待超时的出队列，然后队列中选一个优先级最高的业务开始处理 每个业务的等待时间：超时的就是最大等待时间，没超时的就是当前处理时间-业务开始时间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 205;struct user&#123; string id; int i,s,t,d,ans; bool done; user()&#123;&#125; user(string id,int i,int s,int t,int d,bool done):id(id),i(i),s(s),t(t),d(d),done(done)&#123;&#125; bool operator &lt; (const user &amp;hs)const&#123; if(id[0]!=hs.id[0]) return id[0]!='V'; return s&gt;hs.s; &#125;&#125;p[maxn];int main()&#123; char id[10]; int h,m,t,d,cnt=0; while(~scanf("%s%d:%d%d%d",id,&amp;h,&amp;m,&amp;t,&amp;d))&#123; p[cnt]=user(id,cnt,h*60+m,t,d,false); p[cnt].ans=p[cnt].d; cnt++; &#125; int nowtime=0,k=0; priority_queue&lt;user&gt;pq; for(int i=1;i&lt;=1440;i++)&#123; if(k&lt;cnt&amp;&amp;i&gt;=p[k].s)&#123; pq.push(p[k++]); &#125; if(i&gt;=nowtime)&#123; while(!pq.empty()&amp;&amp;pq.top().s+pq.top().d&lt;nowtime) pq.pop(); if(!pq.empty())&#123; user tmp=pq.top(); pq.pop(); p[tmp.i].done=true; p[tmp.i].ans=i-tmp.s; nowtime=i+tmp.t; &#125; &#125; &#125; for(int i=0;i&lt;cnt;i++)&#123; cout&lt;&lt;p[i].id&lt;&lt;' '&lt;&lt;p[i].ans&lt;&lt;' '&lt;&lt;(p[i].done?"Yes":"No")&lt;&lt;'\n'; &#125;&#125; 1295 Flawless Prime首先判断数位是否有0，存在0肯定不是，然后依次去掉最高位暴力判断是否为素数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;bool has0(int x)&#123; while(x)&#123; if(x%10==0) return true; x/=10; &#125; return false;&#125;bool isprime(int x)&#123; if(x==1) return false; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0) return false; &#125; return true;&#125;int len(int x)&#123; int res=0; while(x)&#123; res++; x/=10; &#125; return res;&#125;bool pd(int x)&#123; while(x)&#123; if(!isprime(x)) return false; int cnt=len(x); int tmp=1; for(int i=1;i&lt;cnt;i++) tmp*=10; x%=tmp; &#125; return true;&#125;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); if(has0(n) || !pd(n)) puts("No"); else puts("Yes"); &#125;&#125; 1297 Homework发现与题目号无关，只需要通过学号和排名的关系来用map记录对应学号的积分，最后算出成绩排个序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;unordered_map&lt;int,int&gt;mp;struct stu&#123; int sid,grade; stu()&#123;&#125; stu(int a,int b):sid(a),grade(b)&#123;&#125; bool operator &lt; (const stu &amp;b)const&#123; if(grade==b.grade) return sid&lt;b.sid; return grade&gt;b.grade; &#125;&#125;s[maxn];int main()&#123; int pid,sid,prank; int MaxS=0; while(~scanf("%d%d%d",&amp;pid,&amp;sid,&amp;prank))&#123; if(1&lt;=prank&amp;&amp;prank&lt;=12)&#123; mp[sid]+=32; &#125; else if(13&lt;=prank&amp;&amp;prank&lt;=24)&#123; mp[sid]+=16; &#125; else if(25&lt;=prank&amp;&amp;prank&lt;=48)&#123; mp[sid]+=8; &#125; else if(49&lt;=prank&amp;&amp;prank&lt;=96)&#123; mp[sid]+=4; &#125; else if(97&lt;=prank&amp;&amp;prank&lt;=192)&#123; mp[sid]+=2; &#125; else&#123; mp[sid]+=1; &#125; MaxS=max(MaxS,mp[sid]); &#125; int cnt=0; for(unordered_map&lt;int,int&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123; s[cnt++]=stu(it-&gt;first,round(100+10*log(it-&gt;second*1.0/MaxS))); &#125; sort(s,s+cnt); for(int i=0;i&lt;cnt;i++)&#123; printf("%d %d\n",s[i].sid,s[i].grade); &#125;&#125; 1304 ZUMA!模拟把c放到第i个和第i+1个之间后的结果，然后答案取最大值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 105;int n,c;int b[maxn];int tmp[maxn],a[maxn];int func(int x)&#123; for(int i=0;i&lt;n;i++) a[i]=b[i]; int cnt=1; int i=x,j=x+1,p=0; while(i&gt;=0&amp;&amp;a[i]==c)&#123; i--; cnt++; &#125; while(j&lt;n&amp;&amp;a[j]==c)&#123; j++; cnt++; &#125; if(cnt&lt;3) return 0; else&#123; for(int k=0;k&lt;=i;k++) tmp[p++]=a[k]; for(int k=j;k&lt;n;k++) tmp[p++]=a[k]; &#125; for(int i=0;i&lt;p;i++) a[i]=tmp[i]; while(1)&#123; int pp=0; for(int i=0;i&lt;p;i++)&#123; cnt=1; while(i+1&lt;p&amp;&amp;a[i]==a[i+1])&#123; cnt++; i++; &#125; if(cnt&lt;3)&#123; for(int k=i-cnt+1;k&lt;=i;k++) tmp[pp++]=a[k]; &#125; &#125; if(pp==p) break; for(int i=0;i&lt;pp;i++) a[i]=tmp[i]; p=pp; &#125; return n-p;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;c); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;b[i]); &#125; int ans=0; for(int i=0;i&lt;n-1;i++)&#123; ans=max(ans,func(i)); &#125; printf("%d\n",ans); &#125;&#125; 1307 Beautiful Number二进制枚举0的位置和二进制串的长度，对于64位整数第63位是符号位，唯一的0前面必须有1，不然就会成为前导0，如果0…61个位置中的第i个位置为0，那么len…i+1的位置为1，i-1…0的位置也为1， 计算出所有这样的数后排序，求答案每次遍历即可 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;int main()&#123; vector&lt;ll&gt;v; for(int i=0;i&lt;62;i++)&#123; for(int len=62;len&gt;=i+1;len--)&#123; ll res=0; for(int j=len;j&gt;=i+1;j--)&#123; res=res*2+1; &#125; res*=2; for(int j=i-1;j&gt;=0;j--)&#123; res=res*2+1; &#125; v.push_back(res); &#125; &#125; sort(v.begin(),v.end()); int T; scanf("%d",&amp;T); while(T--)&#123; ll l,r; scanf("%I64d%I64d",&amp;l,&amp;r); int ans=0; for(int i=0;i&lt;v.size();i++)&#123; if(l&lt;=v[i]&amp;&amp;v[i]&lt;=r) ans++; else if(v[i]&gt;r) break; &#125; printf("%d\n",ans); &#125;&#125; 1309 唯一的子串枚举左端点取出子串丢到set或map中去重，自动排序 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int m;char str[105]; scanf("%d%s",&amp;m,str); string s=str; map&lt;string,int&gt;mp; for(int i=0;i+m-1&lt;s.length();i++)&#123; mp.insert(&#123;s.substr(i,m),1&#125;); &#125; for(map&lt;string,int&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123; cout&lt;&lt;it-&gt;first&lt;&lt;'\n'; &#125; puts(""); &#125;&#125; 1270 Unique Digit Number看top应该可以推公式，根据排列组合可以算出位数为1…10的符合条件数的个数…然后不会了 只会暴力dfs打表，根据位数打表就可以确保大小顺序，然后注意0不能作为前导 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 9e6+5;ll ans[maxn];int cnt,vis[10];void dfs(ll x,int k,int len)&#123; if(k==len)&#123; ans[++cnt]=x; return; &#125; for(int i=0;i&lt;10;i++)&#123; if(i==0&amp;&amp;k&gt;0&amp;&amp;!vis[0])&#123; vis[i]=1; dfs(x*10+i,k+1,len); vis[i]=0; &#125; if(i&amp;&amp;!vis[i])&#123; vis[i]=1; dfs(x*10+i,k+1,len); vis[i]=0; &#125; &#125;&#125;int main()&#123; ans[++cnt]=0; for(int len=1;len&lt;=10;len++)&#123; dfs(0,0,len); &#125; int n; while(~scanf("%d",&amp;n))&#123; printf("%I64d\n",ans[n]); &#125;&#125; 1289 3的倍数一道神奇的动态规划，输入为s[]字符串数组，能被3整除说明新的数的数位和%3=0 f[i][j]表示以s[i]为前导的所有新正整数数中 %3==j 的种类数 对于s[i]分数码%3=0,1,2的3种情况讨论，且对于每个s[i]又分取和不取2种情况，这样f[i]可由f[i+1]递推而来，最后f[0][0]是包含所有s[i]为前导的数%3=0的种类数，此时答案包含前导0的情况 因为不能有前导0，所以去掉所有以s[i]==0为前导的的种类数，就是f[0][0]-(f[i+1][0]+1)，即当前位是0，后面符合条件共有f[i+1][0]种，然后后面全部不选，只选0也满足，所以减掉f[i+1]+1 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 5005;const int P = 1e9+7;char s[maxn];int f[maxn][3];int main()&#123; while(~scanf("%s",s))&#123; int lens=strlen(s); f[lens][0]=f[lens][1]=f[lens][2]=0; for(int i=lens-1;i&gt;=0;i--)&#123; int x=(s[i]-'0')%3; if(x==0)&#123; f[i][0]=(f[i+1][0]+f[i+1][0]+1)%P; f[i][1]=(f[i+1][1]+f[i+1][1])%P; f[i][2]=(f[i+1][2]+f[i+1][2])%P; &#125; else if(x==1)&#123; f[i][0]=(f[i+1][0]+f[i+1][2])%P; f[i][1]=(f[i+1][1]+f[i+1][0]+1)%P; f[i][2]=(f[i+1][2]+f[i+1][1])%P; &#125; else &#123; f[i][0]=(f[i+1][0]+f[i+1][1])%P; f[i][1]=(f[i+1][1]+f[i+1][2])%P; f[i][2]=(f[i+1][2]+f[i+1][0]+1)%P; &#125; &#125; int ans=f[0][0]; for(int i=0;i&lt;lens;i++)&#123; if(s[i]=='0') ans=(ans-(f[i+1][0]+1))%P; &#125; while(ans&lt;0) ans+=P; printf("%d\n",ans); &#125;&#125; 1303 Sequence乍一看以为是贪心，每次取较大的一端，其实这样有问题 记忆化搜索（备忘录），直接深搜的话对于当前长度都有两个选择，要么取左端点要么取右端点，时间复杂度O($2^n$) ans[l][r]表示区间l,r的最优解，回溯的时候如果已经求出了子区间的，直接返回对应值即可，不必重复计算 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 65;ll a[maxn],b[maxn];ll ans[maxn][maxn];ll dfs(int l,int r,int k)&#123; if(l&gt;r) return 0; if(ans[l][r]) return ans[l][r]; return ans[l][r]=min(a[l]*b[k-1]+dfs(l+1,r,k+1),a[r]*b[k-1]+dfs(l,r-1,k+1));&#125;int main()&#123; b[0]=1; for(int i=1;i&lt;60;i++) b[i]=b[i-1]*2; int T; scanf("%d",&amp;T); while(T--)&#123; memset(ans,0,sizeof(ans)); int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%I64d",&amp;a[i]); &#125; printf("%I64d\n",dfs(1,n,1)); &#125;&#125; 1244 Estrella’s Chocolate求最小的最大值，二分最大热量 以当前最大热量值吃完所有巧克力所需天数&gt;m，说明最大热量需要再大一些，左指针右移；反过来同理 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e4+5;int n,m;int a[maxn];int pd(int x)&#123; int day=1,sum=0; for(int i=0;i&lt;n;i++)&#123; if(sum+a[i]&lt;=x) sum+=a[i]; else&#123; day++; sum=a[i]; &#125; &#125; return day&lt;=m;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); &#125; int l=*max_element(a,a+n),r=1e9; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(pd(mid)) r=mid; else l=mid+1; &#125; printf("%d\n",l); &#125;&#125; 1269 Craftman求制作手套最大值，二分手套件数 如果制作当前x件所需多余原料数&gt;k，说明原材料不够，右指针左移；反过来同理 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e3+5;int n,k;ll a[maxn],b[maxn];bool pd(ll x)&#123; ll need=0; for(int i=0;i&lt;n;i++)&#123; need+=(x*a[i]-b[i]&gt;0?x*a[i]-b[i]:0); &#125; return need&lt;=k;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;n;i++) scanf("%I64d",&amp;a[i]); for(int i=0;i&lt;n;i++) scanf("%I64d",&amp;b[i]); ll l=0,r=*max_element(b,b+n)+k; while(l&lt;r)&#123; ll mid=(l+r+1)&gt;&gt;1; if(pd(mid)) l=mid; else r=mid-1; &#125; printf("%I64d\n",l); &#125;&#125; 1167 逆序数（大数据）既然是大数据，暴力O($n^2$)肯定T 树状数组或者归并排序O(nlogn) 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e4+5;int n;int a[maxn],b[maxn],c[maxn];int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int v)&#123; while(x&lt;=n)&#123; c[x]+=v; x+=lowbit(x); &#125;&#125;int sum(int x)&#123; int res=0; while(x)&#123; res+=c[x]; x-=lowbit(x); &#125; return res;&#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; memset(c,0,sizeof(c)); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); b[i]=a[i]; &#125; sort(b,b+n); int m=unique(b,b+n)-b; for(int i=0;i&lt;n;i++)&#123; a[i]=lower_bound(b,b+m,a[i])-b+1; &#125; int ans=0; for(int i=n-1;i&gt;=0;i--)&#123; ans+=sum(a[i]-1); add(a[i],1); &#125; printf("%d\n",ans); &#125;&#125; 1160 猜数字需要满足所有的k个条件，则需要把询问存起来离线操作，然后枚举$C_n^4$个的所有组合，回溯法或者直接枚举，对于每个组合看是否满足这k个询问 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 3e5+5;const int maxk = 105;int n,K;int x[maxk],y[maxk];int a[maxk][5],b[5],vis[maxn],cnt;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;bool pd()&#123; for(int k=0;k&lt;K;k++)&#123; int xx=0,yy=0; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; if(i==j&amp;&amp;a[k][i]==b[j]) xx++; if(i!=j&amp;&amp;a[k][i]==b[j]) yy++; &#125; &#125; if(x[k]!=xx||y[k]!=yy)return false; &#125; return true;&#125;void dfs(int k)&#123; if(k==4)&#123; if(pd())&#123; cnt++; printf("%d %d %d %d\n",b[0],b[1],b[2],b[3]); &#125; return; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i])&#123; vis[i]=1; b[k]=i; dfs(k+1); vis[i]=0; &#125; &#125;&#125;int main()&#123; while(n=read())&#123; K=read(); for(int i=0;i&lt;K;i++)&#123; for(int j=0;j&lt;4;j++) a[i][j]=read(); x[i]=read(),y[i]=read(); &#125; cnt=0; dfs(0); printf("%d\n",cnt); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 3e5+5;const int maxk = 105;int n,K;int x[maxk],y[maxk];int a[maxk][5];int ans[maxn][5],cnt;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;bool pd(int b[])&#123; for(int k=0;k&lt;K;k++)&#123; int xx=0,yy=0; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; if(i==j&amp;&amp;a[k][i]==b[j]) xx++; if(i!=j&amp;&amp;a[k][i]==b[j]) yy++; &#125; &#125; if(x[k]!=xx||y[k]!=yy)return false; &#125; return true;&#125;int main()&#123; while(n=read())&#123; K=read(); for(int i=0;i&lt;K;i++)&#123; for(int j=0;j&lt;4;j++) a[i][j]=read(); x[i]=read(),y[i]=read(); &#125; cnt=0; int b[5]; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; for(int k=1;k&lt;=n;k++)&#123; for(int l=1;l&lt;=n;l++)&#123; if(i==j||i==k||i==l||j==k||j==l||k==l) continue; b[0]=i,b[1]=j,b[2]=k,b[3]=l; if(pd(b))&#123; ans[cnt][0]=i,ans[cnt][1]=j,ans[cnt][2]=k,ans[cnt][3]=l; cnt++; &#125; &#125; &#125; &#125; &#125; for(int i=0;i&lt;cnt;i++)&#123; printf("%d %d %d %d\n",ans[i][0],ans[i][1],ans[i][2],ans[i][3]); &#125; printf("%d\n",cnt); &#125;&#125; 1179 Shortest PathDijkstra求k+1次最短路然后求和，注意指定的城市只能走一次，所以跑Dij的时候需要稍稍标记即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3ftypedef __int64 ll;using namespace std;const int maxn = 1e3+5;const int maxm = 1e4+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n,m,k;int city[5];struct node&#123; int val,id; node(int id,int val):id(id),val(val) &#123;&#125; bool operator &lt;(const node &amp;hs)const&#123; return val&gt;hs.val; &#125;&#125;;struct edge&#123; int next,to,w;&#125;e[maxm*2];int head[maxn],cnt;void addedge(int u,int v,int w)&#123; e[++cnt]=edge&#123;head[u],v,w&#125;; head[u]=cnt;&#125;int dis[maxn],vis[maxn];void dijkstra(int from,int to)&#123; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++) dis[i]=INF; for(int i=0;i&lt;=k+1;i++) vis[city[i]]=true; vis[from]=vis[to]=false; priority_queue&lt;node&gt;q; q.push(node(from,0)); dis[from]=0; while(!q.empty())&#123; int cur=q.top().id; q.pop(); if(vis[cur])continue; vis[cur]=true; for(int i=head[cur]; i ; i=e[i].next)&#123; int v=e[i].to; if(dis[cur]+e[i].w &lt; dis[v])&#123; dis[v]=dis[cur]+e[i].w; q.push(node(v,dis[v])); &#125; &#125; &#125;&#125;int main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;k)&amp;&amp;(n||m||k))&#123; cnt=0; memset(head,0,sizeof(head)); for(int i=0;i&lt;m;i++)&#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; city[0]=1;city[k+1]=n; for(int i=1;i&lt;=k;i++)&#123; city[i]=read(); &#125; bool ok=true; int ans=0; for(int i=0;i&lt;=k;i++)&#123; dijkstra(city[i],city[i+1]); if(dis[city[i+1]]==INF)&#123; ok=false; break; &#125; ans+=dis[city[i+1]]; &#125; if(!ok) puts("Impossible"); else printf("%d\n",ans); &#125;&#125; 1186 Tourist 2经典的TSP问题，回溯法O(n!)求出最优值并记录路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3ftypedef __int64 ll;using namespace std;const int maxn = 15;int n,c[maxn][maxn];inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int ans,ways;int vis[maxn],path[maxn][maxn],tmp[maxn];void dfs(int k,int cur,int cost)&#123; if(cost&gt;ans) return; if(k==n)&#123; cost+=c[cur][0]; if(cost&lt;ans)&#123; ans=cost; for(int i=0;i&lt;n;i++) path[0][i]=tmp[i]; ways=1; &#125; else if(cost==ans&amp;&amp;ways&lt;10)&#123; for(int i=0;i&lt;n;i++) path[ways][i]=tmp[i]; ways++; &#125; return; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i])&#123; vis[i]=1; tmp[k]=i; dfs(k+1,i,cost+c[cur][i]); vis[i]=0; &#125; &#125;&#125;int main()&#123; int T=read(); while(T--)&#123; n=read(); for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=n;j++)&#123; c[i][j]=read(); &#125; &#125; ans=INF,ways=0; dfs(0,0,0); printf("%d\n",ans); for(int i=0;i&lt;ways;i++)&#123; for(int j=0;j&lt;n;j++)&#123; printf("%d%c",path[i][j],j==n-1?'\n':' '); &#125; &#125; &#125;&#125; 1195 Large Population要求边最少，互相连通且边权最大，就是求最大生成树，把边按边权降序排然后Kruskal跑一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3ftypedef __int64 ll;using namespace std;const int maxn = 1e3+5;const int maxm = 1e4+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n,m;int f[maxn];struct edge&#123; int u,v,w; bool operator &lt; (const edge &amp;hs)const&#123; return w&gt;hs.w; &#125;&#125;e[maxm];int Find(int x)&#123; return x==f[x]?x:f[x]=Find(f[x]);&#125;int main()&#123; int T=read(); while(T--)&#123; n=read(); m=read(); for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=0;i&lt;m;i++)&#123; e[i]=edge&#123;read(),read(),read()&#125;; &#125; sort(e,e+m); int cnt=0,ans=0; for(int i=0;i&lt;m;i++)&#123; int u=e[i].u,v=e[i].v,w=e[i].w; int fu=Find(u),fv=Find(v); if(fu!=fv)&#123; f[fu]=fv; cnt++; ans+=w; &#125; if(cnt==n-1) break; &#125; printf("%d\n",ans); &#125;&#125; 1245 Lisa’s Puzzle把二进制反过来看做求前缀，构造一个只有01结点的trie树，就是哈夫曼树，把每个数化为二进制01串插入到trie树，并记录每个结点经过的次数，每个数的答案就是该数最后一个结点的下面两个结点的经过次数和，下面没有结点说明该数不是其他数的前缀了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int tot=0;int a[maxn];unordered_map&lt;int,int&gt;cnt;int trie[maxn][2],vis[maxn],End[maxn];int len(int x)&#123; int res=0; while(x)&#123; res++; x&gt;&gt;=1; &#125; return res;&#125;void Insert(int k,int x)&#123; int now=0; for(int i=0;i&lt;cnt[x];i++)&#123; int next=((1&lt;&lt;i)&amp;x)?1:0; if(!trie[now][next]) trie[now][next]=++tot; now=trie[now][next]; vis[now]++; &#125; End[k]=now;&#125;int query(int k,int x)&#123; return vis[trie[End[k]][0]]+vis[trie[End[k]][1]];&#125;int main()&#123; int n=read(); for(int i=0;i&lt;n;i++)&#123; a[i]=read(); cnt[a[i]]=len(a[i]); Insert(i,a[i]); &#125; for(int i=0;i&lt;n;i++)&#123; printf("%d\n",query(i,a[i])); &#125;&#125; 1250 Bonus把输入看做有向图，从出度为0的开始拓扑排序，也就是和常规的反过来，求出每个人的等级即可算工资 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e4+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;vector&lt;int&gt;V[maxn];int n,m;int out[maxn],Rank[maxn];bool topu()&#123; queue&lt;int&gt;q; for(int i=1;i&lt;=n;i++)&#123; if(out[i]==0) q.push(i); &#125; int cnt=0; while(!q.empty())&#123; int x=q.front(); q.pop(); cnt++; for(int i=0;i&lt;V[x].size();i++)&#123; int next=V[x][i]; if(--out[next]==0) q.push(next); Rank[next]=Rank[x]+1; &#125; &#125; return cnt==n;&#125;int main()&#123; int T=read(); while(T--)&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++)&#123; V[i].clear(); Rank[i]=out[i]=0; &#125; for(int i=0;i&lt;m;i++)&#123; int u=read(),v=read(); V[v].push_back(u); out[u]++; &#125; if(topu())&#123; int sum=0; for(int i=1;i&lt;=n;i++)&#123; sum+=Rank[i]*1000+888; &#125; printf("%d\n",sum); for(int i=1;i&lt;=n;i++)&#123; printf("%d%c",Rank[i]*1000+888,i==n?'\n':' '); &#125; &#125; else&#123; printf("%d\n",n*888); for(int i=0;i&lt;n;i++)&#123; printf("888%c",i==n-1?'\n':' '); &#125; &#125; &#125;&#125; 1288 Binary Search Tree用new和free动态开结点再释放不是MLE就是TLE 因为最多100个数，可以把静态数组空间分配给新节点，但也不能用数组下标直接将左儿子下标为父节点的2倍，右儿子下标为父节点的2倍+1，100个数可以卡成$2^{100}$，明显数组不够大 其实只要空间为100的结构体数组给新节点使用就行了，每次建树初始化一个递增值记录下标用到第几个即可，其他就和数据结构课上实现的差不多，最后左右递归比较 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 105;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct node&#123; int v; node *l,*r;&#125;tree[2][maxn];int tot;node* Newnode(int k,int x)&#123; tree[k][tot].v=x; tree[k][tot].l=NULL; tree[k][tot].r=NULL; return &amp;tree[k][tot++];&#125;void Insert(int k,node *root,int x)&#123; if(x &lt; root-&gt;v)&#123; if(root-&gt;l==NULL) root-&gt;l=Newnode(k,x); else Insert(k,root-&gt;l,x); &#125; else&#123; if(root-&gt;r==NULL) root-&gt;r=Newnode(k,x); else Insert(k,root-&gt;r,x); &#125;&#125;bool same(node *root0,node *root1)&#123; if(root0==NULL&amp;&amp;root1==NULL) return true; if(root0!=NULL&amp;&amp;root1!=NULL)&#123; return same(root0-&gt;l,root1-&gt;l)&amp;&amp;same(root0-&gt;r,root1-&gt;r); &#125; return false;&#125;int main()&#123; int T=read(); while(T--)&#123; int n=read(),m=read(); tot=0; node *root0 = Newnode(0,read()); for(int i=1;i&lt;n;i++)&#123; Insert(0,root0,read()); &#125; for(int ca=1;ca&lt;=m;ca++)&#123; tot=0; node *root1 = Newnode(1,read()); for(int i=1;i&lt;n;i++)&#123; Insert(1,root1,read()); &#125; printf("%d: ",ca); if(same(root0,root1)) puts("Yes"); else puts("No"); &#125; puts(""); &#125;&#125; 1302 Balance Tree和上一题差不多，静态开结点建树，然后dfs求每个结点的左子树高度和右子树高度判断是否平衡 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1005;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct node&#123; int v; node *l,*r;&#125;tree[maxn];int tot;node* Newnode(int x)&#123; tree[tot].v=x; tree[tot].l=NULL; tree[tot].r=NULL; return &amp;tree[tot++];&#125;void Insert(node *root,int x)&#123; if(x &lt; root-&gt;v)&#123; if(root-&gt;l==NULL) root-&gt;l=Newnode(x); else Insert(root-&gt;l,x); &#125; else&#123; if(root-&gt;r==NULL) root-&gt;r=Newnode(x); else Insert(root-&gt;r,x); &#125;&#125;bool ok;int dfs(node *root)&#123; if(root==NULL) return 0; int lh=dfs(root-&gt;l); int rh=dfs(root-&gt;r); if(abs(lh-rh)&gt;1) ok=false; return max(lh,rh)+1;&#125;int main()&#123; int T=read(); while(T--)&#123; int n=read(); tot=0; node *root = Newnode(read()); for(int i=1;i&lt;n;i++)&#123; Insert(root,read()); &#125; ok=true; dfs(root); if(ok) puts("Yes"); else puts("No"); &#125;&#125; 模拟测试1 E-合并堆典型的区间dp，和矩阵连乘、石子合并等问题相似，可是考试的时候读错了题以为是贪心，气气+1 维护一个前缀和为了方便计算两两区间合并代价值，首先算出短区间最小代价，再自底向上算出长区间最小代价，转移方程看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 305;ll dp[maxn][maxn],h[maxn];ll inf = (1LL&lt;&lt;63)-1;ll sum[maxn];ll cost(int i,int j,int ii,int jj)&#123; ll H1=sum[j]-sum[i-1]; ll H2=sum[jj]-sum[ii-1]; ll a=min(H1,H2); ll b=max(H1,H2); return a*(log2(b)+1);&#125;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;h[i]); sum[i]=sum[i-1]+h[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; dp[i][j]=inf; &#125; dp[i][i]=0; &#125;//dp[i][j]表示区间[i,j]合并的最小代价，那么自己和自己合并dp[i][i]为0//把区间[i,j]分为两部分[i,k]和[k+1,j]，由最优子结构性质可知dp[i][j]=dp[i][k]+dp[k+1][j]//这样只要在每个长度区间下每次枚举k的位置就行了 for(int len=2;len&lt;=n;len++)&#123; for(int i=1;i+len-1&lt;=n;i++)&#123; int j=i+len-1; for(int k=i;k&lt;=j-1;k++)&#123; dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+cost(i,k,k+1,j)); &#125; &#125; &#125; printf("%lld\n",dp[1][n]); &#125;&#125; 模拟测试2 F-Split去年期末+补考原题 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3fusing namespace std;typedef long long ll;ll dp[55][55];ll a[55],sum[55];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); sum[i]=sum[i-1]+a[i]; &#125; //dp[i][j]表示前i个数分为j段的最大价值 //起始全部状态初始为负无穷大,dp[i][1]和dp[i][i]容易求得 dp[1][1]=a[1]; for(int i=2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; dp[i][j]=-inf; &#125; dp[i][1]=abs(a[i]-a[1])*i; dp[i][i]=sum[i]; &#125; //对于每个a[i]就两种情况,要么单独作为一段,要么和前面的最后一段合并 for(int i=2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; //i个数最多分为i段 //将a[i]单独作一段 dp[i][j]=max(dp[i][j],dp[i-1][j-1]+a[i]); //将a[i]与前面第j段合并 for(int k=j;k&lt;=i-1;k++)&#123; //枚举前i-1个数第j段的所有可能起始位置,这样就是[1,k-1]分为j-1段,[k-1,i]作为第j段 dp[i][j]=max(dp[i][j],dp[k-1][j-1]+abs(a[i]-a[k])*(i-k+1)); &#125; &#125; &#125; &#125;&#125; 期末考试 E给一个无向带权图，其中图中有k个点是救助站，问图中所有点到最近救助站路程的总和 其实是很简单的一道最短路模板题，稍微改改就行了，考试想复杂了，气气+2 首先我们把k个点看作一个超级源点，那么图中其他点到源点的最短路就也是这个源点到其他所有点的最短路 把这个超级源点和这k个救助站分别加上一条边权为0的边，从这个源点开始跑dij就相当于把这k个点同时丢到优先队列中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3ftypedef __int64 ll;using namespace std;const int maxn = 1e3+5;const int maxm = 1e4+5;int n,m,k;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct node&#123; int val,id; node(int id,int val):id(id),val(val) &#123;&#125; bool operator &lt;(const node &amp;hs)const&#123; return val&gt;hs.val; &#125;&#125;;struct edge&#123; int next,to,w;&#125;e[maxm*2];int head[maxn],cnt;void addedge(int u,int v,int w)&#123; e[++cnt]=edge&#123;head[u],v,w&#125;; head[u]=cnt;&#125;int dis[maxn],vis[maxn];void dijkstra(int from)&#123; for(int i=1;i&lt;=n+1;i++)&#123; dis[i]=INF; vis[i]=0; &#125; priority_queue&lt;node&gt;q; q.push(node(from,0)); dis[from]=0; while(!q.empty())&#123; int cur=q.top().id; q.pop(); if(vis[cur])continue; vis[cur]=true; for(int i=head[cur]; i ; i=e[i].next)&#123; int v=e[i].to; if(dis[cur]+e[i].w &lt; dis[v])&#123; dis[v]=dis[cur]+e[i].w; q.push(node(v,dis[v])); &#125; &#125; &#125;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; n=read(),m=read(),k=read(); cnt=0; for(int i=1;i&lt;=n+1;i++)&#123; head[i]=0; &#125; for(int i=0;i&lt;m;i++)&#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; int X=n+1; for(int i=0;i&lt;k;i++)&#123; int x=read(); addedge(X,x,0); addedge(x,X,0); &#125; dijkstra(X); ll sum=0; bool ok=true; for(int i=1;i&lt;=n;i++)&#123; if(dis[i]==INF)&#123; ok=false; break; &#125; sum+=dis[i]; &#125; if(ok) printf("%I64d\n",sum); else puts("-1"); &#125;&#125; 2019程序设计实践总结就到这，总的来说不是特别满意(还被ericxie点名批评了)，图论和动态规划不是特别掌握，毕竟我主数据结构的呀qwq 一门课程的结束不代表以后永远不会再接触，我觉得程设就是对之前所学的C语言、离散数学、数据结构、Java等课程结合的实践性特别强的一门课程，在职场也一样，面试要求的算法都是平时积累起来的，包括编程语言的掌握程度，所以如果你对算法和编程感兴趣，欢迎通过自己的努力加入湘潭大学ACM集训队。]]></content>
      <categories>
        <category>专业课程</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>模拟</tag>
        <tag>数学</tag>
        <tag>程序设计实践</tag>
        <tag>暴力</tag>
        <tag>动态规划</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[湖南大学第15届校赛 H-Longest Common Palindrome Substring]]></title>
    <url>%2Fposts%2F4b7358b7.html</url>
    <content type="text"><![CDATA[原题链接 题意：给两个1e5长的字符串，求两者最长公共回文子串长度 思路： manacher 分别求出s,t串的mp[]数组，同时也可以求出对应最长奇回文子串长度(a,c)和最长偶回文子串长度(c,d) 由于manacher求出的是以i为中心的最长回文半径，且长度为len的子串为回文子串,len-2的的子串也为回文子串 那么s,t的最长公共回文子串长度可能是[0,1,3,5,…min(a,c)]和[0,2,4,6,…,min(b,d)]这两个区间内的一个长度 hash预处理字符串，然后分别二分这两个区间，check的时候就要用到mp[]数组来判断二分的长度子串是否为回文子串，注意分奇偶讨论 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn = 1e5+5;char ma[maxn*2];int mp[2][maxn*2];void manacher(char s[],int len,int k)&#123; int l=0; ma[l++]='$'; ma[l++]='#'; for(int i=1;i&lt;=len;i++)&#123; ma[l++]=s[i]; ma[l++]='#'; &#125; ma[l]=0; int mx=0,id=0; for(int i=0;i&lt;l;i++)&#123; mp[k][i]=mx&gt;i?min(mp[k][2*id-i],mx-i):1; while(ma[i+mp[k][i]]==ma[i-mp[k][i]]) mp[k][i]++; if(i+mp[k][i]&gt;mx)&#123; mx=i+mp[k][i]; id=i; &#125; &#125;&#125;char s[maxn],t[maxn];int lens,lent;ull base=233;ull p[maxn],hs[maxn],ht[maxn];ull geths(int l,int r)&#123; return (ull)hs[r]-p[r-l+1]*hs[l-1];&#125;ull getht(int l,int r)&#123; return (ull)ht[r]-p[r-l+1]*ht[l-1];&#125;vector&lt;ull&gt;tmp;bool check(int k)&#123; tmp.clear(); ull ss,tt; for(int i=0;i&lt;2*lens+2;i++)&#123; if(mp[0][i]-1&gt;=k)&#123; if((mp[0][i]-1)&amp;1)&#123; ss=geths(i/2-k/2,i/2+k/2); &#125; else&#123; ss=geths(i/2-k/2+1,i/2+k/2); &#125; tmp.push_back(ss); &#125; &#125; sort(tmp.begin(),tmp.end()); for(int i=0;i&lt;2*lent+2;i++)&#123; if(mp[1][i]-1&gt;=k)&#123; if((mp[1][i]-1)&amp;1)&#123; tt=getht(i/2-k/2,i/2+k/2); &#125; else&#123; tt=getht(i/2-k/2+1,i/2+k/2); &#125; if(binary_search(tmp.begin(),tmp.end(),tt)) return true; &#125; &#125; return false;&#125;int main() &#123; //freopen("in.txt","r",stdin); p[0]=1; for(int i=1;i&lt;maxn;i++)&#123; p[i]=p[i-1]*base; &#125; vector&lt;int&gt;len; while(~scanf("%s%s",s+1,t+1))&#123; lens=strlen(s+1); lent=strlen(t+1); for(int i=1;i&lt;=lens;i++)&#123; hs[i]=hs[i-1]*base+s[i]-'a'; &#125; for(int i=1;i&lt;=lent;i++)&#123; ht[i]=ht[i-1]*base+t[i]-'a'; &#125; int a=0,b=0,c=0,d=0; manacher(s,lens,0); for(int i=0;i&lt;2*lens+2;i++)&#123; int k=mp[0][i]-1; if(k&amp;1) a=max(a,k); else b=max(b,k); &#125; manacher(t,lent,1); for(int i=0;i&lt;2*lent+2;i++)&#123; int k=mp[1][i]-1; if(k&amp;1) c=max(c,k); else d=max(d,k); &#125; int Maxodd=min(a,c),Maxeven=min(b,d); len.clear(); len.push_back(0); for(int i=1;i&lt;=Maxodd;i+=2)&#123; len.push_back(i); &#125; int l=0,r=len.size()-1,ans=0; while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(check(len[mid])) l=mid; else r=mid-1; &#125; ans=max(ans,len[l]); len.clear(); for(int i=0;i&lt;=Maxeven;i+=2)&#123; len.push_back(i); &#125; l=0,r=len.size()-1; while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(check(len[mid])) l=mid; else r=mid-1; &#125; ans=max(ans,len[l]); printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>hash</tag>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template of Algorithm]]></title>
    <url>%2Fposts%2Fc54c604d.html</url>
    <content type="text"><![CDATA[个人常用算法模板库 快读1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//C++关闭同步流 切记不要和C风格混用ios::sync_with_stdio(false);cin.tie(0);//正负整数inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;namespace FastIO &#123; const int SIZE = 1 &lt;&lt; 16; char buf[SIZE], obuf[SIZE], str[60]; int bi = SIZE, bn = SIZE, opt; int read(char *s) &#123; while (bn) &#123; for (; bi &lt; bn &amp;&amp; buf[bi] &lt;= ' '; bi++); if (bi &lt; bn) break; bn = fread(buf, 1, SIZE, stdin); bi = 0; &#125; int sn = 0; while (bn) &#123; for (; bi &lt; bn &amp;&amp; buf[bi] &gt; ' '; bi++) s[sn++] = buf[bi]; if (bi &lt; bn) break; bn = fread(buf, 1, SIZE, stdin); bi = 0; &#125; s[sn] = 0; return sn; &#125; bool read(int&amp; x) &#123; int n = read(str), bf; if (!n) return 0; int i = 0; if (str[i] == '-') bf = -1, i++; else bf = 1; for (x = 0; i &lt; n; i++) x = x * 10 + str[i] - '0'; if (bf &lt; 0) x = -x; return 1; &#125;&#125;;using namespace FastIO;//O2优化#pragma GCC optimize(2)//javaInputReader in = new InputReader();PrintWriter out = new PrintWriter(System.out); out.close();class InputReader &#123; BufferedReader buf; StringTokenizer tok; InputReader() &#123; buf = new BufferedReader(new InputStreamReader(System.in)); &#125; boolean hasNext() &#123; while (tok == null || !tok.hasMoreElements()) &#123; try &#123; tok = new StringTokenizer(buf.readLine()); &#125; catch (Exception e) &#123; return false; &#125; &#125; return true; &#125; String next() &#123; if (hasNext()) return tok.nextToken(); return null; &#125; int nextInt() &#123; return Integer.parseInt(next()); &#125; long nextLong() &#123; return Long.parseLong(next()); &#125; double nextDouble() &#123; return Double.parseDouble(next()); &#125; BigInteger nextBigInteger() &#123; return new BigInteger(next()); &#125; BigDecimal nextBigDecimal() &#123; return new BigDecimal(next()); &#125;&#125; STL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;ext/pb_ds/assoc_container.hpp&gt;#include&lt;ext/pb_ds/tree_policy.hpp&gt;//用tree#include&lt;ext/pb_ds/hash_policy.hpp&gt;//用hash#include&lt;ext/pb_ds/trie_policy.hpp&gt;//用trie#include&lt;ext/pb_ds/priority_queue.hpp&gt;//用priority_queueusing namespace __gnu_pbds;//hash表 用法类似map,时间复杂度O(n)cc_hash_table&lt;int,bool&gt; h; //拉链法gp_hash_table&lt;int,bool&gt; h; //探测法// 平衡树 以下操作时间复杂度均为O(logn)struct team&#123; int t,p,id; bool operator &lt;(const team&amp;hs)const&#123; return t!=hs.t?t&gt;hs.t:p!=hs.p?p&lt;hs.p:id&lt;hs.id; &#125;&#125;typedef tree&lt;team,null_type,less&lt;team&gt;,rb_tree_tag,tree_order_statistics_node_update&gt; rebtree;null_type //无映射(低版本g++为null_mapped_type)less&lt;T&gt; //从小到大排序rb_tree_tag //红黑树tree_order_statistics_node_update //更新方式tr.insert(x); //插入;tr.erase(x); //删除;tr.order_of_key(x); //求比x小的个数 rank=res+1tr.find_by_order(k-1); //找k小值,返回迭代器 k值非法，则会返回end()tr.join(b); //将b并入tr,前提是两棵树类型一样且没有重复元素tr.split(v,b); //分裂,key小于等于v的元素属于tr,其余的属于btr.lower_bound(x); //返回第一个&gt;=x的元素的迭代器 x的前驱 *--tr.lower_bound(x)tr.upper_bound(x); //返回第一个&gt;x的元素的迭代器 x的后继 *tr.lower_bound(x)//迭代器支持++,--操作//堆priority_queue&lt;int,greater&lt;int&gt;,TAG&gt; Q; //注意命名空间别和std中的那个重了/*其中的TAG为类型，有以下几种：pairing_heap_tag //最快thin_heap_tagbinomial_heap_tagrc_binomial_heap_tagbinary_heap_tag*/__gnu_pbds::priority_queue&lt;int&gt;::point_iterator it; //支持迭代器Q.push(x); //push()会返回迭代器,用一个迭代器数组保存所有进队列的元素的迭代器，就可以持久化操作Q.pop();Q.top();Q.join(b);Q.empty();Q.size();Q.modify(it,6);Q.erase(it);//rope 时间复杂度O(logN)#include &lt;ext/rope&gt;using namespace __gnu_cxx;rope&lt;int&gt; r;push_back(x) 在末尾添加xinsert(pos,x) 在pos插入xerase(pos,x) 从pos开始删除x个copy(pos,len,x) 从pos开始到pos+len为止用x代替replace(pos,x) 从pos开始换成xsubstr(pos,x) 提取pos开始x个at(x)/[x] 访问第x个元素//可持久化 O(1)复制根节点rope&lt;char&gt; *his[maxn];his[0] = new rope&lt;char&gt;();his[i] = new rope&lt;char&gt;(*his[i-1]);//list 合并操作void merge(list &lt;T&gt; &amp; x) //将链表x合并进来并清空x,要求链表自身和x都是有序的void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x ); //在position后把list&amp;x所有的元素到剪接到要操作的list对象void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x, iterator it ); //只会把it的值剪接到要操作的list对象中void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x, iterator first, iterator last ); //把first到last剪接到要操作的list对象中//O(n)查询第k大nth_element(a+1,a+k,a+1+n);//vector&amp;&amp;list指定位置插入vec.insert(vec.begin()+k,item); //平均O(n) 较慢iter = lst.begin();advance(iter, k); //迭代器向前移动k个 k为负则向后移动lst.insert(iter, item); ST表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//f[i][j]表示区间[i,i+2^j-1]的最值//一维void ST()&#123; for(int i=1;i&lt;=n;i++) f[i][0]=a[i]; int t=log(n)/log(2); for(int j=1;j&lt;=t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125;int querymax(int l,int r)&#123; int k=log(r-l+1)/log(2); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125;//二维void init() &#123; lo[0]=-1; for(int i=1;i&lt;maxn;++i) lo[i]=(i&amp;(i-1))?lo[i-1]:lo[i-1]+1; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; Min[i][j][0][0] = a[i][j]; Max[i][j][0][0] = a[i][j]; &#125; for (int i = 0; i &lt;= lo[n]; i++) &#123; for (int j = 0; j &lt;= lo[m]; j++) &#123; if (i == 0 &amp;&amp; j == 0) continue; for (int row = 1; row + (1 &lt;&lt; i) - 1 &lt;= n; row++) for (int col = 1; col + (1 &lt;&lt; j) - 1 &lt;= m; col++) &#123; if (i) &#123; Min[row][col][i][j] = min(Min[row][col][i-1][j],Min[row+(1&lt;&lt;(i-1))][col][i-1][j]); Max[row][col][i][j] = max(Max[row][col][i-1][j],Max[row+(1&lt;&lt;(i-1))][col][i-1][j]); &#125; else &#123; Min[row][col][i][j] = min(Min[row][col][i][j-1], Min[row][col+(1&lt;&lt;(j-1))][i][j-1]); Max[row][col][i][j] = max(Max[row][col][i][j-1], Max[row][col+(1&lt;&lt;(j-1))][i][j-1]); &#125; &#125; &#125; &#125;&#125;int askmin(int x1, int y1, int x2, int y2) &#123; int kx = lo[x2-x1+1], ky = lo[y2-y1+1]; int m1 = Min[x1][y1][kx][ky]; int m2 = Min[x2-(1&lt;&lt;kx)+1][y1][kx][ky]; int m3 = Min[x1][y2-(1&lt;&lt;ky)+1][kx][ky]; int m4 = Min[x2-(1&lt;&lt;kx)+1][y2-(1&lt;&lt;ky)+1][kx][ky]; return min(min(m1,m2),min(m3,m4));&#125;int askmax(int x1, int y1, int x2, int y2) &#123; int kx = lo[x2-x1+1], ky = lo[y2-y1+1]; int m1 = Max[x1][y1][kx][ky]; int m2 = Max[x2-(1&lt;&lt;kx)+1][y1][kx][ky]; int m3 = Max[x1][y2-(1&lt;&lt;ky)+1][kx][ky]; int m4 = Max[x2-(1&lt;&lt;kx)+1][y2-(1&lt;&lt;ky)+1][kx][ky]; return max(max(m1,m2),max(m3,m4));&#125; KMP123456789101112131415161718192021222324//next[i] 表示t[i-next[i]...i-1]=t[0...next[i]-1]//循环节len=m%(m-next[m])==0?m-next[m]:1void getNext(char t[],int m)&#123; int i,j; j=Next[0]=-1; i=0; while(i&lt;m)&#123; while(j!=-1&amp;&amp;t[i]!=t[j]) j=Next[j]; Next[++i]=++j; //if(t[++i]==t[++j]) Next[i]=Next[j]; //优化 //else Next[i]=j; &#125;&#125;int kmp(char s[],int n,char t[],int m)&#123; getNext(t,m); int i=0,j=0; while(i&lt;n)&#123; while(j!=-1&amp;&amp;s[i]!=t[j]) j=Next[j]; i++,j++; if(j&gt;=m)&#123; //匹配成功 ; &#125; &#125;&#125; ExtendKMP12345678910111213141516171819202122232425262728293031323334353637383940//next[i]表示t[i...m-1]与t[0...m-1]的最长公共前缀//extend[i]表示s[i...n-1]与t[0...m-1]的最长公共前缀int Next[maxn],extend[maxn];void getNext(char t[],int m)&#123; Next[0]=m; int j=0; while(j+1&lt;m&amp;&amp;t[j]==t[j+1]) j++; Next[1]=j; int k=1; for(int i=2;i&lt;m;i++)&#123; int p=Next[k]+k-1; int L=Next[i-k]; if(i+L&lt;p+1) Next[i]=L; else &#123; j=max(0,p-i+1); while(i+j&lt;m&amp;&amp;t[i+j]==t[j]) j++; Next[i]=j; k=i; &#125; &#125;&#125;void extendkmp(char t[],int m,char s[],int n)&#123; getNext(t,m); int j=0; while(j&lt;n&amp;&amp;j&lt;m&amp;&amp;t[j]==s[j]) j++; extend[0]=j; int k=0; for(int i=1;i&lt;n;i++)&#123; int p=extend[k]+k-1; int L=Next[i-k]; if(i+L&lt;p+1) extend[i]=L; else &#123; j=max(0,p-i+1); while(i+j&lt;n&amp;&amp;j&lt;m&amp;&amp;s[i+j]==t[j]) j++; extend[i]=j; k=i; &#125; &#125;&#125; 最小表示法12345678910111213141516//取得最小表示法下标的开始位置int getmin(char *s,int n) &#123; int n=strlen(s); int i=0,j=1,k=0,t; while(i&lt;n &amp;&amp; j&lt;n &amp;&amp; k&lt;n) &#123; t=s[(i+k)%n]-s[(j+k)%n]; if (!t) k++; else &#123; if (t&gt;0) i+=k+1; else j+=k+1; if (i==j) j++; k=0; &#125; &#125; return i&lt;j?i:j;&#125; 手写Hash1234567891011121314151617181920212223struct Hash &#123; static const int MOD = 1999997; static const int N = 1e6; int head[MOD + 10], nx[N], top; int hs[N], id[N]; void init() &#123; memset(head, -1, sizeof head); top = 0; &#125; void insert(int x, int y) &#123; int k = x % MOD; hs[top] = x; id[top] = y; nx[top] = head[k]; head[k] = top++; &#125; int find(int x) &#123; int k = x % MOD; for (int i = head[k]; i != -1; i = nx[i]) &#123; if (hs[i] == x) &#123; return id[i]; &#125; &#125; return -1; &#125;&#125;hs; 字符串Hash123456789101112131415161718192021//这里为ull自然溢出取模,手动取模模数可取998244353,1004535809,1e9+7,1e9+9...typedef unsigned long long ull;char s[maxn],t[maxn];int lens,lent;ull base=233; //冲突可换其它素数ull p[maxn],hs[maxn];ull geths(int l,int r)&#123; return (ull)hs[r]-p[r-l+1]*hs[l-1];&#125;p[0]=1;for(int i=1;i&lt;maxn;i++)&#123; p[i]=p[i-1]*base;&#125;scanf("%s%s",s+1,t+1);lens=strlen(s+1);lent=strlen(t+1);for(int i=1;i&lt;=lens;i++)&#123; hs[i]=hs[i-1]*base+s[i];&#125; Manacher1234567891011121314151617181920212223//mp[i]-1表示以i为中心的最长回文的长度//mp[1...2*n+1]/2 求和即为所有子串中回文子串个数char ma[maxn*2];int mp[maxn*2];void manacher(char s[],int len)&#123; int l=0; ma[l++]='$'; ma[l++]='#'; for(int i=0;i&lt;len;i++)&#123; ma[l++]=s[i]; ma[l++]='#'; &#125; ma[l]=0; int mx=0,id=0; for(int i=1;i&lt;l;i++)&#123; mp[i]=mx&gt;i?min(mp[2*id-i],mx-i):1; while(ma[i+mp[i]]==ma[i-mp[i]]) mp[i]++; if(i+mp[i]&gt;mx)&#123; mx=i+mp[i]; id=i; &#125; &#125;&#125; Trie1234567891011121314151617181920212223struct trie &#123; int nex[maxn][26],cnt; bool exist[maxn]; // 该结点结尾的字符串是否存在 void Insert(char s[], int len) &#123; int p = 0; for (int i = 0; i &lt; len; i++) &#123; int c = s[i] - 'a'; if (!nex[p][c]) nex[p][c] = ++cnt; p = nex[p][c]; &#125; exist[p] = 1; &#125; bool Find(char s[], int len) &#123; int p = 0; for (int i = 0; i &lt; len; i++) &#123; int c = s[i] - 'a'; if (!nex[p][c]) return 0; p = nex[p][c]; &#125; return exist[p]; &#125;&#125;; 后缀数组SA123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262struct SuffixArray&#123; // S下标从1开始,S[n+1]为0，S[1...n]非零 //sa:字典序中排第i位的起始位置在str中第sa[i] //rank:就是str第i个位置的后缀是在字典序排第几 //height：字典序排i和i-1的后缀的最长公共前缀 int s[N&lt;&lt;1],t[N&lt;&lt;1],ht[N],sa[N],rk[N],p[N],c[N],w[N]; inline int trans(int n,const char* S)&#123; int m=*max_element(S+1,S+1+n); memset(rk,0,(m+1)&lt;&lt;2); // for(int i=1;i&lt;=n;++i) rk[S[i]]=1; for(int i=1;i&lt;=m;++i) rk[i]+=rk[i-1]; for(int i=1;i&lt;=n;++i) s[i]=rk[S[i]]; return rk[m]; &#125; #define ps(x) sa[w[s[x]]--]=x #define pl(x) sa[w[s[x]]++]=x inline void radix(int* v,int* s,int* t,int n,int m,int n1)&#123; memset(sa,0,(n+1)&lt;&lt;2); memset(c,0,(m+1)&lt;&lt;2); for(int i=1;i&lt;=n;++i) ++c[s[i]]; for(int i=1;i&lt;=m;++i) w[i]=c[i]+=c[i-1]; for(int i=n1;i;--i) ps(v[i]); for(int i=1;i&lt;=m;++i) w[i]=c[i-1]+1; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;1 &amp;&amp; t[sa[i]-1]) pl(sa[i]-1); for(int i=1;i&lt;=m;++i) w[i]=c[i]; for(int i=n;i;--i) if(sa[i]&gt;1 &amp;&amp; !t[sa[i]-1]) ps(sa[i]-1); &#125; inline void SAIS(int n,int m,int* s,int* t,int* p)&#123; int n1=0,ch=rk[1]=0,*s1=s+n; t[n]=0; for(int i=n-1;i;--i) t[i]=s[i]==s[i+1]?t[i+1]:s[i]&gt;s[i+1]; for(int i=2;i&lt;=n;++i) rk[i]=t[i-1]&amp;&amp;!t[i]?(p[++n1]=i,n1):0; radix(p,s,t,n,m,n1); for(int i=1,x,y;i&lt;=n;++i) if(x=rk[sa[i]])&#123; if(ch&lt;=1 || p[x+1]-p[x]!=p[y+1]-p[y]) ++ch; else for(int j=p[x],k=p[y];j&lt;=p[x+1];++j,++k) if((s[j]&lt;&lt;1|t[j])^(s[k]&lt;&lt;1|t[k]))&#123; ++ch; break; &#125; s1[y=x]=ch; &#125; if(ch&lt;n1) SAIS(n1,ch,s1,t+n,p+n1); else for(int i=1;i&lt;=n1;++i) sa[s1[i]]=i; for(int i=1;i&lt;=n1;++i) s1[i]=p[sa[i]]; radix(s1,s,t,n,m,n1); &#125; inline void init(int n,const char* S)&#123; int m=trans(++n,S); SAIS(n,m,s,t,p); for(int i=1;i&lt;n;++i) rk[sa[i]=sa[i+1]]=i; for(int i=1,j,k=0;i&lt;n;++i) if(rk[i]&gt;1)&#123; for(j=sa[rk[i]-1];S[i+k]==S[j+k];++k); if(ht[rk[i]]=k) --k; &#125; &#125;&#125;SA;int mn[25][N],lg[N];void ST_init(int n)&#123; lg[0]=-1; for(int i=1;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;1]+1; for(int i=1;i&lt;=n;i++) mn[0][i]=ht[i]; for(int j=1;j&lt;=lg[n];j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) mn[j][i]=min(mn[j-1][i],mn[j-1][i+(1&lt;&lt;(j-1))]);&#125;int query(int l,int r)&#123;//通过rk[l]到rk[r]之间的 min(lcp[i]) 即为两后缀的最长lcp //l=rk[l],r=rk[r]; // l r为下标 if(l&gt;r) swap(l,r);l++; int k=lg[r-l+1]; return min(mn[k][l],mn[k][r-(1&lt;&lt;k)+1]);&#125;char S[N];//注意如果S为char只能放0-127，否则改intint main()&#123; //注意输入和传参 while(scanf("%s",S+1)&amp;&amp;strcmp(S+1,".")!=0)&#123; int n=strlen(S+1); SA.init(n,S); &#125;&#125;//SA应用int get_lcs(int n,int mid)&#123; //mid为两串分隔位置，n为拼接后总长 int ans=0; for(int i=2;i&lt;=n;i++)&#123; if(ht[i]&gt;ans)&#123; if(sa[i]&gt;=1&amp;&amp;sa[i]&lt;=mid&amp;&amp;sa[i-1]&gt;=mid+1) ans=max(ans,ht[i]); if(sa[i-1]&gt;=1&amp;&amp;sa[i-1]&lt;=mid&amp;&amp;sa[i]&gt;=mid+1) ans=max(ans,ht[i]); &#125; &#125; return ans;&#125;ll get_subcnt(int n)&#123; //不同子串个数 ll ans=0; for(int i=1;i&lt;=n;i++)&#123; ans += n-sa[i]+1-ht[i]; &#125; return ans;&#125;int get_looplen(int n)&#123; //循环节长度 for(int i=1;i&lt;=n;i++)&#123; if(n%i) continue; //不能整除的话，一定不能构成循环节 if(rk[1] != rk[i+1]+1) continue; //rank数组必须要相邻才能构成循环节 if(ht[rk[1]] != n-i) continue; //若第一个和第二个的最长公共前缀不符合条件 return n/i; &#125; return 1;&#125;bool pd1(int k)&#123; int mx=SA.sa[1],mm=SA.sa[1]; for(int i=2; i&lt;=n; ++i)&#123; if(SA.ht[i]&gt;=k)&#123; mm=min(mm,min(SA.sa[i],SA.sa[i-1])); mx=max(mx,max(SA.sa[i],SA.sa[i-1])); if(mx-mm&gt;=k) return 1; // &#125;else&#123; mx=SA.sa[i],mm=SA.sa[i]; &#125; &#125; return 0;&#125;int get1()&#123; //不可重叠最长子串长度 int l=1,r=n/2; while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(pd1(mid)) l=mid; else r=mid-1; &#125; return l;&#125;bool pd2(int x)&#123; int cnt=1; for(int i=2; i&lt;=n; ++i)&#123; if(SA.ht[i]&gt;=x)&#123; cnt++; if(cnt==k) return 1; &#125; else cnt=1; &#125; return 0;&#125;int get2()&#123; //可重叠 出现k次最长子串长度 int l=0,r=n; while(l&lt;r)&#123; int mid = (l+r+1)&gt;&gt;1; if(pd(mid)) l=mid; else r=mid-1; &#125; return l;&#125;//可重叠最长子串长度 = max(ht[i])// 最长连续循环重复子串出现次数int sum=0;for(int j=1;j&lt;=n;++j)&#123;//对于长度为j的循环节,sum记录循环次数 for(int i=1;i+j&lt;=n;i+=j)&#123; if(S[i]==S[i+j])&#123; int len=query(i,i+j);//向后匹配 int num=len/j+1; int k=i-(j-len%j); if(k&gt;=1 &amp;&amp; len%j &amp;&amp; query(k,k+j)&gt;=len)++num;//向前匹配 if(num==sum) L.push_back(j);//L记录得到最多循环次数的可能的子串长度 else if(num&gt;sum) sum=num,L.clear(),L.push_back(j); &#125; &#125;&#125;//接上 输出字典序最小的子串int x=SA.sa[1],y=SA.sa[1]+1;sum--;//printf("%d\n",sum);for(int i=1;i&lt;=n &amp;&amp; sum;++i)&#123;//求哪个子串可以循环sum次 for(int j=0;j&lt;L.size();++j)&#123; if(SA.sa[i]+L[j]&gt;=n)continue; int len=query(SA.sa[i],SA.sa[i]+L[j]); if(len/L[j] == sum)&#123;x=SA.sa[i],y=SA.sa[i]+(sum+1)*L[j],sum=0;break;&#125; &#125;&#125;printf("Case %d: ",++Case);for(int i=x;i&lt;y;++i)printf("%c",S[i]);//n个串中出现在至少k个不同的串中的最长公共子串//二分出长度，pd()和下面求起点类似；连接多个串时用不一样的隔开符while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(pd(mid)) l=mid; else r=mid-1;&#125;if(l==0)&#123; puts("?\n"); continue;&#125;vector&lt;int&gt;st;int cnt=0;for(int i=1;i&lt;=n;i++) vis[i]=0;for(int i=2;i&lt;=all;i++)&#123; if(SA.ht[i]&gt;=l)&#123; int id1 = fin(SA.sa[i-1]),id2 = fin(SA.sa[i]); if(!vis[id1]) cnt++; vis[id1]=1; if(!vis[id2]) cnt++; vis[id2]=1; &#125; else&#123; if(cnt&gt;=k) st.push_back(SA.sa[i-1]); //至少出现k个不同的串中 cnt=0; for(int i=1;i&lt;=n;i++) vis[i]=0; &#125;&#125;if(cnt&gt;=k) st.push_back(SA.sa[all]);for(int i=0;i&lt;st.size();i++)&#123; for(int j=st[i];j&lt;st[i]+l;j++) printf("%c",S[j]); puts("");&#125;//两串长度不小于k的公共子串个数 mid表示分隔符位置 n表示拼接总长int top=0;ll tot=0,sum=0;for(int i=1;i&lt;=n;i++)&#123; if(ht[i]&lt;k) top=tot=0; else&#123; int cnt=0; if(sa[i-1]&lt;mid) cnt++,tot+=ht[i]-k+1; while(top&gt;0&amp;&amp;ht[i]&lt;=st[top-1][0])&#123; top--; tot-=st[top][1]*(st[top][0]-ht[i]); cnt+=st[top][1]; &#125; st[top][0]=ht[i];st[top++][1]=cnt; if(sa[i]&gt;mid) sum+=tot; &#125;&#125;tot=top=0;for(int i=1;i&lt;=n;i++)&#123; if(ht[i]&lt;k) top=tot=0; else&#123; int cnt=0; if(sa[i-1]&gt;mid) cnt++,tot+=ht[i]-k+1; while(top&gt;0&amp;&amp;ht[i]&lt;=st[top-1][0])&#123; top--; tot-=st[top][1]*(st[top][0]-ht[i]); cnt+=st[top][1]; &#125; st[top][0]=ht[i];st[top++][1]=cnt; if(sa[i]&lt;mid) sum+=tot; &#125;&#125;printf("%lld\n",sum);//重复出现子串计数问题 求一个字符串中有多少个至少出现两次的子串Ans=∑max(Height[i]−Height[i−1],0)//包含指定字符的所有不同子串个数void solve(char *S,char ch)&#123; nxt[n+1]=0; for(int i=n;i&gt;=1;i--)&#123; nxt[i]=nxt[i+1]; if(S[i]==ch) nxt[i]=i; &#125; ll ans=0; for(int i=1;i&lt;=n;i++)&#123; if(nxt[sa[i]]) ans += n-max(sa[i]+ht[i],nxt[sa[i]])+1; &#125; printf("%lld\n",ans);&#125; 后缀自动机SAM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108const int maxn = 1e6 + 5;const int N = 26;struct SAM&#123; int tot, last, ch[maxn &lt;&lt; 1][N], fa[maxn &lt;&lt; 1], len[maxn &lt;&lt; 1]; int sum[maxn &lt;&lt; 1], tp[maxn &lt;&lt; 1], cnt[maxn &lt;&lt; 1]; //sum,tp用于拓扑排序，tp为排序后的数组 int right[maxn &lt;&lt; 1]; int Tr(char c)&#123;return c - 'a';&#125; int val(int c)&#123;return len[c] - len[fa[c]];&#125; void init() &#123; last = tot = 1; len[1] = 0; memset( ch[1], 0, sizeof ch[1]); &#125; void add(int x) &#123; int p = last, np = last = ++tot; len[np] = len[p] + 1, cnt[last] = 1; memset( ch[np], 0, sizeof ch[np]); while( p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = fa[p]; if( p == 0) fa[np] = 1; else &#123; int q = ch[p][x]; if( len[q] == len[p] + 1) fa[np] = q; else &#123; int nq = ++tot; memcpy( ch[nq], ch[q], sizeof ch[q]); len[nq] = len[p] + 1, fa[nq] = fa[q], fa[q] = fa[np] = nq; while( p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = fa[p]; &#125; &#125; &#125; void build(char s[]) &#123; int lens = strlen(s + 1); for(int i = 1; i &lt;= lens; i++) add(Tr(s[i])); memset(sum, 0, sizeof(int) * (tot + 1)); memset(right, 0, sizeof(int) * (tot + 1)); for(int i = 1; i &lt;= tot; i++) sum[len[i]]++; for(int i = 1; i &lt;= lens; i++) sum[i] += sum[i - 1]; for(int i = 1; i &lt;= tot; i++) tp[sum[len[i]]--] = i; for(int i = tot; i; i--) cnt[fa[tp[i]]] += cnt[tp[i]]; for(int i = 1, p = 1; i &lt;= lens; i++) p = ch[p][Tr(s[i])], right[p]++; for(int i = tot; i; i--) right[fa[tp[i]]] += right[tp[i]]; &#125; ll calc()//洛谷P3804 &#123; ll ans = 0; for(int i = tot; i; i--) &#123; if(cnt[tp[i]] &gt; 1) ans = max(ans, 1LL * cnt[tp[i]] * len[tp[i]]); &#125; return ans; &#125; ll getsubnum() //不同本质子串数 &#123; ll ans = 0; for(int i = tot; i; i--) &#123; ans += val(i); &#125; return ans; &#125; ll get_ab(int a, int b) //出现次数介于[a,b]的子串数 &#123; ll ans = 0; for(int i = 1; i &lt;= tot; i++) &#123; if(a &lt;= right[tp[i]] &amp;&amp; right[tp[i]] &lt;= b) ans += val(tp[i]); &#125; return ans; &#125; int getlcs(char t[]) //最长公共子串长度 &#123; int p = 1, num = 0, ans = 0; for (int i = 1; t[i]; i++) &#123; int c = Tr(t[i]); if (ch[p][c]) p = ch[p][c], num++; else &#123; for(; p &amp;&amp; !ch[p][c]; p = fa[p]); if (!p) p = 1, num = 0; else num = len[p] + 1, p = ch[p][c]; &#125; ans = max(ans, num); &#125; return ans; &#125;&#125; sam;char s[maxn], t[maxn];int main()&#123; while(~scanf("%s",s+1)) &#123; sam.init(); sam.build(s); &#125;&#125; 回文自动机PAM12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*1.求串S前缀0~i内本质不同回文串的个数（两个串长度不同或者长度相同且至少有一个字符不同便是本质不同）2.求串S内每一个本质不同回文串出现的次数3.求串S内回文串的个数（其实就是1和2结合起来） p-24.求以下标i结尾的回文串的个数*/#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 300005 ;const int N = 26 ;struct PAM &#123; int next[maxn][N] ;//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成 int fail[maxn] ;//fail指针，失配后跳转到fail指针指向的节点 int cnt[maxn] ; //在最后统计后它可以表示形如以i为结尾的回文串中最长的那个串个数 int num[maxn] ; //表示以i结尾的回文串的种类数 int len[maxn] ;//len[i]表示节点i表示的回文串的长度 int S[maxn] ;//存放添加的字符 int last ;//指向上一个字符所在的节点，方便下一次add int n ;//字符数组指针 int p ;//节点指针 int newnode ( int l ) &#123; for ( int i = 0 ; i &lt; N ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123;//初始化 p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1 ; &#125; int get_fail ( int x ) &#123;//和KMP一样，失配后找一个尽量最长的 while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; void add ( int c ) &#123; c -= 'a' ; S[++ n] = c ; int cur = get_fail ( last ) ;//通过上一个回文串找这个回文串的匹配位置 if ( !next[cur][c] ) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode ( len[cur] + 2 ) ;//新建节点 fail[now] = next[get_fail ( fail[cur] )][c] ;//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; &#125; last = next[cur][c] ; cnt[last] ++ ; &#125; void Count () &#123; for ( int i = p - 1 ; i &gt;= 0 ; -- i ) cnt[fail[i]] += cnt[i] ; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！ &#125;&#125; pam;char s[maxn];int main()&#123; scanf("%s",s); pam.init(); int lens=strlen(s); for(int i=0;i&lt;lens;i++)&#123; pam.add(s[i]); &#125; pam.Count();&#125; 二维树状数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//单点修改+区间查询/*求(x1,y1)~(x2,y2)的sumsum=sum(x2,y2)-sum(x1-1,y2)-sum(x2,y1-1)+sum(x1-1,y1-1)*/void add(int x,int y,int v) &#123; while(x&lt;=n) &#123; int ty=y; while(ty&lt;=n) c[x][ty]+=v,ty+=lowbit(ty); x+=lowbit(x); &#125;&#125;int sum(int x,int y) &#123; int res=0; while(x) &#123; int ty=y; while(ty) res+=c[x][ty],ty-=lowbit(ty); x-=lowbit(x); &#125; return res;&#125;//区间修改+单点查询void add(int x,int y,int v) &#123; while(x&lt;=n) &#123; int ty=y; while(ty&lt;=n) c[x][ty]+=v,ty+=lowbit(ty); x+=lowbit(x); &#125;&#125;void real_add(int x1,int y1,int x2,int y2,int v) &#123; add(x1,y1,v); add(x1,y2+1,-v); add(x2+1,y1,-v); add(x2+1,y2+1,v);&#125;int sum(int x, int y) &#123; int res=0; while(x) &#123; int ty=y; while(ty) res+=c[x][ty],ty-=lowbit(ty); x-=lowbit(x); &#125; return res;&#125;//区间修改+区间查询void add(int x,int y,int v) &#123; for(int i=x; i&lt;=n; i+=lowbit(i)) for(int j=y; j&lt;=m; j+=lowbit(j)) &#123; t1[i][j]+=v; t2[i][j]+=v*x; t3[i][j]+=v*y; t4[i][j]+=v*x*y; &#125;&#125;void real_add(int x1,int y1,int x2,int y2,int v) &#123; add(x1,y1,v); add(x1,y2+1,-v); add(x2+1,y1,-v); add(x2+1,y2+1,v);&#125;int sum(int x, int y) &#123; int res=0; for(int i=x; i; i-=lowbit(i)) for(int j=y; j; j-=lowbit(j)) res+=(x+1)*(y+1)*t1[i][j]-(y+1)*t2[i][j]-(x+1)*t3[i][j]+t4[i][j]; return res;&#125;int real_sum(int x1,int y1,int x2,int y2) &#123; return sum(x2,y2)-sum(x2,y1-1)-sum(x1-1,y2)+sum(x1-1,y1-1);&#125; 树链剖分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202//点权版#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1const int maxn = 1e5+10;const int maxm = 1e5+10;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct edge&#123; int next,to;&#125;e[maxm*2];int head[maxn],cnt;void addedge(int u,int v)&#123; e[++cnt]=edge&#123;head[u],v&#125;; head[u]=cnt;&#125;int n,m,root,P;int w[maxn];int fa[maxn],deep[maxn],siz[maxn],son[maxn],rk[maxn],top[maxn],id[maxn];void dfs1(int u,int pre,int dep)&#123; fa[u]=pre;deep[u]=dep;siz[u]=1; for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v==pre)continue; dfs1(v,u,dep+1); siz[u]+=siz[v]; if(siz[v]&gt;siz[son[u]])son[u]=v; &#125;&#125;void dfs2(int u,int t)&#123; top[u]=t;id[u]=++cnt;rk[cnt]=u; if(!son[u])return; dfs2(son[u],t); for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v!=son[u]&amp;&amp;v!=fa[u])dfs2(v,v); &#125;&#125;/*************************************/int sum[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2];void push_up(int o)&#123; sum[o]=sum[o&lt;&lt;1]+sum[o&lt;&lt;1|1];&#125;void push_down(int ls,int rs,int o)&#123; if(lazy[o])&#123; sum[o&lt;&lt;1]=(sum[o&lt;&lt;1]+lazy[o]*ls)%P; sum[o&lt;&lt;1|1]=(sum[o&lt;&lt;1|1]+lazy[o]*rs)%P; lazy[o&lt;&lt;1]=(lazy[o&lt;&lt;1]+lazy[o])%P; lazy[o&lt;&lt;1|1]=(lazy[o&lt;&lt;1|1]+lazy[o])%P; lazy[o]=0; &#125;&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; sum[o]=w[rk[l]]; //重新编号后的 return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;void update(int L,int R,int v,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; sum[o]=(sum[o]+v*(r-l+1))%P; lazy[o]=(lazy[o]+v)%P; return; &#125; int mid=(l+r)&gt;&gt;1; push_down(mid-l+1,r-mid,o); if(L&lt;=mid) update(L,R,v,lson); if(R&gt;mid) update(L,R,v,rson); push_up(o);&#125;int querysum(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return sum[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=0; push_down(mid-l+1,r-mid,o); if(L&lt;=mid) ret=(ret+querysum(L,R,lson))%P; if(R&gt;mid) ret=(ret+querysum(L,R,rson))%P; return ret;&#125;void PathUpdate(int x,int y,int v)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); update(id[top[x]],id[x],v,1,n,1); x=fa[top[x]]; &#125; if(id[x]&gt;id[y]) swap(x,y); update(id[x],id[y],v,1,n,1);&#125;int PathQuery(int x,int y)&#123; int ret=0; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); ret=(ret+querysum(id[top[x]],id[x],1,n,1))%P; x=fa[top[x]]; &#125; if(id[x]&gt;id[y])swap(x,y); ret=(ret+querysum(id[x],id[y],1,n,1))%P; return ret;&#125;int main()&#123; n=read(),m=read(),root=read(),P=read(); for(int i=1;i&lt;=n;i++)&#123; w[i]=read(); &#125; cnt=0; for(int i=1;i&lt;=n;i++) head[i]=0; for(int i=0;i&lt;n-1;i++)&#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; cnt=0; dfs1(root,0,1); //注意根节点不一定是1 dfs2(root,root); build(1,n,1); while(m--)&#123; int op=read(),x,y,z; if(op==1)&#123; //更新x-y最短路径上所有点 x=read(),y=read(),z=read(); PathUpdate(x,y,z); &#125; else if(op==2)&#123; //查询x-y最短路径上所有点 x=read(),y=read(); printf("%d\n",PathQuery(x,y)); &#125; else if(op==3)&#123; //更新以x为根节点的子树 x=read(),z=read(); update(id[x],id[x]+siz[x]-1,z,1,n,1); &#125; else&#123; //查询以x为根节点的子树 x=read(); printf("%d\n",querysum(id[x],id[x]+siz[x]-1,1,n,1)); &#125; &#125;&#125;//边权版int fa[maxn],deep[maxn],siz[maxn],son[maxn],rk[maxn],top[maxn],id[maxn];int dis[maxn],w[maxn];void dfs1(int u,int pre,int dep)&#123; fa[u]=pre;deep[u]=dep;siz[u]=1; for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v==pre)continue; dis[v]=dis[u]+e[i].v; dfs1(v,u,dep+1); siz[u]+=siz[v]; if(siz[v]&gt;siz[son[u]])son[u]=v; &#125;&#125;void dfs2(int u,int t)&#123; top[u]=t;id[u]=++cnt;rk[cnt]=u; if(!son[u])return; dfs2(son[u],t); for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v!=son[u]&amp;&amp;v!=fa[u])dfs2(v,v); &#125;&#125;int PathQuery(int x,int y)&#123; int ans=0; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); ans=max(ans,query(id[top[x]],id[x],1,n,1)); x=fa[top[x]]; &#125; if(x==y)return ans; if(deep[x]&gt;deep[y]) swap(x,y); ans=max(ans,query(id[son[x]],id[y],1,n,1)); return ans;&#125;void PathUpdate(int x,int y,int v)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); update(id[top[x]],id[x],v,1,n,1); x=fa[top[x]]; &#125; if(x==y)return; if(deep[x]&gt;deep[y]) swap(x,y); update(id[son[x]],id[y],v,1,n,1);&#125;for(int i=0;i&lt;n-1;i++)&#123; if(deep[E[i].u]&lt;deep[E[i].v]) swap(E[i].u,E[i].v); w[E[i].u]=E[i].w; //边权放在下面结点上变为点权&#125; 最近公共祖先LCA123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//倍增法int deep[maxn],f[maxn],dis[maxn],p[maxn][30];void dfs(int x,int pre,int d)&#123; deep[x]=d; f[x]=pre; for(int i=head[x];i;i=e[i].next)&#123; int to=e[i].to; if(to!=pre)&#123; dis[to]=dis[x]+e[i].w; dfs(to,x,d+1); &#125; &#125;&#125;void init()&#123; //p[i][j]表示i结点的第2^j祖先 for(int j=0;(1&lt;&lt;j)&lt;=n;j++) for(int i=1;i&lt;=n;i++) p[i][j]=-1; for(int i=1;i&lt;=n;i++)p[i][0]=f[i]; for(int j=1;(1&lt;&lt;j)&lt;=n;j++) for(int i=1;i&lt;=n;i++) if(p[i][j-1]!=-1) p[i][j]=p[p[i][j-1]][j-1];//i的第2^j祖先就是i的第2^(j-1)祖先的第2^(j-1)祖先&#125;int LCA(int a,int b)&#123; int i,j; if(deep[a]&lt;deep[b])swap(a,b); for(i=0;(1&lt;&lt;i)&lt;=deep[a];i++); i--; //使a,b两点的深度相同 for(j=i;j&gt;=0;j--) if(deep[a]-(1&lt;&lt;j)&gt;=deep[b]) a=p[a][j]; if(a==b)return a; //倍增法，每次向上进深度2^j，找到最近公共祖先的子结点 for(j=i;j&gt;=0;j--)&#123; if(p[a][j]!=-1&amp;&amp;p[a][j]!=p[b][j])&#123; a=p[a][j]; b=p[b][j]; &#125; &#125; return f[a];&#125;//树链剖分int query_lca(int x,int y)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]])swap(x,y); x=fa[top[x]]; &#125;return deep[x]&lt;deep[y]?x:y;&#125; 线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233//线段树区间合并//根据题意修改条件void pushup(int l,int r,int o)&#123; tree[o].ls=tree[lc].ls; //左端点最长连续 tree[o].rs=tree[rc].rs; //右端点最长连续 tree[o].ms=max( tree[lc].rs+tree[rc].ls,max( tree[lc].ms,tree[rc].ms) ); //区间最长连续 int mid=(l+r)&gt;&gt;1; if(tree[lc].ls==mid-l+1) tree[o].ls+=tree[rc].ls; if(tree[rc].rs==r-mid) tree[o].rs+=tree[lc].rs;&#125; //对于query()也要考虑mid两侧的情况,一般分三种情况 全左,全右,左右相交,左右端点完全一致才return//区间最长连续LCISvoid push_up(int l,int r,int o)&#123; int mid = (l+r)&gt;&gt;1; lmax[o]=lmax[lc]; rmax[o]=rmax[rc]; mmax[o]=max(mmax[lc],mmax[rc]); if(a[mid]&lt;a[mid+1])&#123; if(lmax[o]==mid-l+1) lmax[o]+=lmax[rc]; if(rmax[o]==r-mid) rmax[o]+=rmax[lc]; mmax[o]=max(mmax[o],rmax[lc]+lmax[rc]); &#125;&#125;int query(int L,int R,int l,int r,int o)&#123; if(L==l&amp;&amp;r==R)&#123; return mmax[o]; &#125; int mid = (l+r)&gt;&gt;1; if(R&lt;=mid) return query(L,R,lson); if(L&gt;mid) return query(L,R,rson); int x = query(L,mid,lson); int y = query(mid+1,R,rson); if(a[mid]&lt;a[mid+1])&#123; int z = min(mid-L+1,rmax[lc]) + min(R-mid,lmax[rc]); return max(max(x,y),z); &#125; else &#123; return max(x,y); &#125;&#125;//区间最大子段和ll sum[maxn&lt;&lt;2],lsum[maxn&lt;&lt;2],rsum[maxn&lt;&lt;2],msum[maxn&lt;&lt;2];void push_up(int o)&#123; sum[o] = sum[ls] + sum[rs]; msum[o] = max(max(msum[ls],msum[rs]),rsum[ls]+lsum[rs]); lsum[o] = max(lsum[ls],sum[ls]+lsum[rs]); rsum[o] = max(rsum[rs],sum[rs]+rsum[ls]);&#125;void build(int l,int r,int o)&#123; sum[o]=lsum[o]=rsum[o]=msum[o]=0; if(l==r) return; int mid = (l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;void update(int p,int v,int l,int r,int o)&#123; if(l==r)&#123; sum[o]+=v; lsum[o]=rsum[o]=msum[o]=sum[o]; return; &#125; int mid = (l+r)&gt;&gt;1; if(p&lt;=mid) update(p,v,lson); else update(p,v,rson); push_up(o);&#125;//query() 区间查询与push_up同理，如果包含两个区间需要比较//区间离散化,每个结点维护[ v[l],v[l+1] )for(int i=1;i&lt;=n;i++)&#123; r[i]++; v.push_back(l[i]);v.push_back(r[i]);&#125;sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());m=v.size();for(int i=1;i&lt;=n;i++)&#123; l[i] = lower_bound(v.begin(),v.end(),l[i])-v.begin()+1; r[i] = lower_bound(v.begin(),v.end(),r[i])-v.begin()+1; r[i]--;&#125;build(1,m-1,1);update(l[i],r[i],1,m-1,1);//矩形面积并/交#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1#define N 205using namespace std;int cnt[N&lt;&lt;2]; //记录cnt[i]表示区间是否被覆盖 为-1时表示其左右区间状态不一致,需要下推double len[N&lt;&lt;2]; //储存区间被覆盖长度 注意数据类型,每个结点维护的是 [ X[l],X[r+1] ]的区间数double X[N&lt;&lt;1];struct edge&#123; double l,r,h; int f; edge()&#123;&#125; edge(double l,double r,double h,int f):l(l),r(r),h(h),f(f)&#123;&#125; bool operator &lt; (const edge &amp;b) const &#123; return h&lt;b.h; &#125;&#125;e[N&lt;&lt;1];//void push_up(int o)//&#123;// //左右节点区间有状态不一致或者两者状态不一致则该节点区间cnt也为-1// if(cnt[o&lt;&lt;1]==-1 || cnt[o&lt;&lt;1|1]==-1) cnt[o]=-1;// else if(cnt[o&lt;&lt;1]!=cnt[o&lt;&lt;1|1]) cnt[o]=-1;// else cnt[o]=cnt[o&lt;&lt;1];//// len[o]=len[o&lt;&lt;1]+len[o&lt;&lt;1|1];//&#125;void push_up(int l, int r, int o) &#123; if(cnt[o]) len[o] = X[r + 1] - X[l]; else if(l == r) len[o] = 0; else len[o] = len[o&lt;&lt;1] + len[o&lt;&lt;1|1];&#125;//void push_down(int l,int r,int o)//&#123;// if(cnt[o]!=-1) //当状态一致时才下推// &#123;// int mid=l+r&gt;&gt;1;// cnt[o&lt;&lt;1]=cnt[o&lt;&lt;1|1]=cnt[o];// len[o&lt;&lt;1]=(cnt[o] ? X[mid+1]-X[l] :0);// len[o&lt;&lt;1|1]=(cnt[o] ? X[r+1]-X[mid+1] :0);// &#125;//&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; cnt[o]=0; len[o]=0.0; return; &#125; int mid=l+r&gt;&gt;1; build(lson); build(rson); push_up(l,r,o);&#125;void update(int L,int R,int v,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;// if(cnt[o]!=-1)// &#123;// cnt[o]+=v;// len[o]=(cnt[o] ? X[r+1]-X[l]:0); //改动覆盖次数条件求面积交// return;// &#125; cnt[o] += v; push_up(l,r,o); return; &#125; //push_down(l,r,o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) update(L,R,v,lson); if(R&gt;mid) update(L,R,v,rson); push_up(l,r,o);&#125;int main()&#123; int n,ca=1; while(scanf("%d",&amp;n),n)&#123; double x1,y1,x2,y2; for(int i=1;i&lt;=n;i++)&#123; scanf("%lf%lf%lf%lf",&amp;x1,&amp;y1,&amp;x2,&amp;y2); X[i]=x1,X[i+n]=x2; e[i]=edge(x1,x2,y1,1); e[i+n]=edge(x1,x2,y2,-1); &#125; sort(e+1,e+1+2*n); sort(X+1,X+1+2*n); int m=unique(X+1,X+1+2*n)-X-1; //build(1,m-1,1); //m个不同的点分成m-1个区间 memset(len,0,sizeof(len)); memset(cnt,0,sizeof(cnt)); double ans=0.0; for(int i=1;i&lt;2*n;i++)&#123; int l=lower_bound(X+1,X+1+m,e[i].l)-X; int r=lower_bound(X+1,X+1+m,e[i].r)-X-1; //printf("%d %d\n",l,r); update(l,r,e[i].f,1,m-1,1); //printf("%f %f %f\n",len[1],e[i+1].h-e[i].h,ans); ans+=len[1]*(e[i+1].h-e[i].h); &#125; printf("Test case #%d\n",ca++); printf("Total explored area: %.2f\n",ans); puts(""); &#125;&#125;//单点修改字符,区间查询是否为回文串//多项式hash,维护正反串的hash值//h[l,r] = s[l]*p[l]+s[l+1]*p[l+1]+...+s[r]*p[r],区间查询后要移位修正同等幂void build(int l,int r,int o)&#123; if(l==r)&#123; sum[0][o]=(ull)s[l]*p[l]; sum[1][o]=(ull)s[n-l+1]*p[l]; return; &#125; int mid = (l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;while(m--)&#123; scanf("%s",op); if(op[0]=='c')&#123; scanf("%d%s",&amp;x,ch); update(0,x,ch[0],1,n,1); update(1,n-x+1,ch[0],1,n,1); &#125; else&#123; scanf("%d%d",&amp;l,&amp;r); if(l&gt;r) swap(l,r); ull ss = query(0,l,r,1,n,1); ull tt = query(1,n-r+1,n-l+1,1,n,1); int llen = l-1,rlen=n-r; if(llen&gt;rlen) tt*=p[llen-rlen]; else ss*=p[rlen-llen]; if(ss==tt) puts("Yes"); else puts("No"); &#125;&#125; 主席树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295//静态区间第k小const int maxn=1e5+10;const int maxm=maxn*40;int T[maxn],L[maxm],R[maxm],sum[maxm];int sz[maxn],h[maxn]; //sz为原序列,h为离散化之后的序列int n,q,ql,qr,k,tot;void build(int&amp; rt,int l,int r)&#123; rt=++tot; sum[rt]=0; if(l == r) return ; int mid=(l+r)&gt;&gt;1; build(L[rt],l,mid); build(R[rt],mid+1,r);&#125;void update(int&amp; rt,int l,int r,int pre,int x)&#123; rt=++tot; L[rt]=L[pre]; R[rt]=R[pre]; sum[rt]=sum[pre]+1; if(l == r) return ; int mid=(l+r)&gt;&gt;1; if(x &lt;= mid) update(L[rt],l,mid,L[pre],x); else update(R[rt],mid+1,r,R[pre],x);&#125;int query(int s,int e,int l,int r,int k)&#123; if(l == r) return l; int mid=(l+r)&gt;&gt;1; int res=sum[L[e]]-sum[L[s]]; if(k &lt;= res) return query(L[s],L[e],l,mid,k); else return query(R[s],R[e],mid+1,r,k-res);&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;q); tot=0; for(int i=1; i&lt;=n; i++)&#123; scanf("%d",&amp;sz[i]); h[i]=sz[i]; &#125; sort(h+1,h+1+n); int num=unique(h+1,h+1+n)-(h+1); build(T[0],1,num); for(int i=1; i&lt;=n; i++) update(T[i],1,num,T[i-1],lower_bound(h+1,h+1+num,sz[i])-(h)); while(q--)&#123; scanf("%d %d %d",&amp;ql,&amp;qr,&amp;k); printf("%d\n",h[query(T[ql-1],T[qr],1,num,k)]); &#125;&#125;//动态区间第k小const int maxn = 6e4+5;const int maxm = 1e4+5;int T[maxn],S[maxn],L[maxn*32],R[maxn*32],sum[maxn*32];int sz[maxn],h[maxn];int ul[maxn],ur[maxn];int tot,num,n,q;struct node&#123; int l,r,k; bool flag; //ture代表Q，false代表C&#125;Q[maxm]; //存储询问void build(int&amp; rt,int l,int r)&#123; rt = ++tot; sum[rt]=0; if(l==r) return; int mid = (l+r)&gt;&gt;1; build(L[rt],l,mid); build(R[rt],mid+1,r);&#125;void update(int&amp; rt,int pre,int l,int r,int x,int val)&#123; rt = ++tot; L[rt] = L[pre]; R[rt] = R[pre]; sum[rt] = sum[pre]+val; if(l==r) return; int mid = (l+r)&gt;&gt;1; if(x&lt;=mid) update(L[rt],L[pre],l,mid,x,val); else update(R[rt],R[pre],mid+1,r,x,val);&#125;int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int val)&#123; int res = lower_bound(h+1,h+1+num,sz[x])-h; while(x&lt;=n)&#123; update(S[x],S[x],1,num,res,val); x += lowbit(x); &#125;&#125;int Sum(int x,bool flag)&#123; int res=0; while(x&gt;0)&#123; if(flag) res += sum[L[ur[x]]]; else res += sum[L[ul[x]]]; x -= lowbit(x); &#125; return res;&#125;int query(int s,int e,int ts,int te,int l,int r,int k)&#123; if(l==r) return l; int mid = (l+r)&gt;&gt;1; int res = Sum(e,true)-Sum(s,false)+sum[L[te]]-sum[L[ts]]; if(k&lt;=res)&#123; for(int i=e;i;i-=lowbit(i)) ur[i] = L[ur[i]]; for(int i=s;i;i-=lowbit(i)) ul[i] = L[ul[i]]; return query(s,e,L[ts],L[te],l,mid,k); &#125; else&#123; for(int i=e;i;i-=lowbit(i)) ur[i] = R[ur[i]]; for(int i=s;i;i-=lowbit(i)) ul[i] = R[ul[i]]; return query(s,e,R[ts],R[te],mid+1,r,k-res); &#125;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; char str[5]; num=0; scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) scanf("%d",sz+i),h[++num]=sz[i]; for(int i=1;i&lt;=q;i++)&#123; scanf("%s",str); if(str[0]=='Q')&#123; scanf("%d%d%d",&amp;Q[i].l,&amp;Q[i].r,&amp;Q[i].k); Q[i].flag=true; &#125; else&#123; scanf("%d%d",&amp;Q[i].l,&amp;Q[i].r); Q[i].flag=false; h[++num]=Q[i].r; &#125; &#125; sort(h+1,h+1+num); int tmp = unique(h+1,h+1+num)-h-1; num = tmp; tot=0; build(T[0],1,num); for(int i=1;i&lt;=n;i++) update(T[i],T[i-1],1,num,lower_bound(h+1,h+1+num,sz[i])-h,1); for(int i=1;i&lt;=n;i++) S[i] = T[0]; for(int i=1;i&lt;=q;i++)&#123; if(Q[i].flag)&#123; for(int j=Q[i].r;j;j-=lowbit(j)) ur[j] = S[j]; for(int j=Q[i].l-1;j;j-=lowbit(j)) ul[j] = S[j]; printf("%d\n",h[query(Q[i].l-1,Q[i].r,T[Q[i].l-1],T[Q[i].r],1,num,Q[i].k)]); &#125; else&#123; add(Q[i].l,-1); sz[Q[i].l] = Q[i].r; add(Q[i].l,1); &#125; &#125; &#125; return 0;&#125;//可持久化单点修改单点查询#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;struct node &#123; int l, r, val; &#125;;node tr[maxn * 20];int cnt, root[maxn];int n, m;int a[maxn];int clone(int p)&#123; tr[++cnt] = tr[p]; return cnt;&#125;int build(int p, int l, int r)&#123; p = ++cnt; if(l == r) &#123; tr[p].val = a[l]; return p; &#125; int mid = (l + r) &gt;&gt; 1; tr[p].l = build(tr[p].l, l, mid); tr[p].r = build(tr[p].r, mid + 1, r); return p; &#125;int update(int p, int l, int r, int pos, int val)&#123; p = clone(p); if(l == r) tr[p].val = val; else &#123; int mid = (l + r) &gt;&gt; 1; if(pos &lt;= mid) tr[p].l = update(tr[p].l, l, mid, pos, val); else tr[p].r = update(tr[p].r, mid + 1, r, pos, val); &#125; return p;&#125;int query(int p, int l, int r, int pos)&#123; if(l == r) return tr[p].val; int mid = (l + r) &gt;&gt; 1; if(pos &lt;= mid) return query(tr[p].l, l, mid, pos); else return query(tr[p].r, mid + 1, r, pos);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1; i &lt;= n; ++i) scanf("%d",&amp;a[i]); root[0] = build(0, 1, n); for(int i = 1; i &lt;= m; ++i) &#123; int v,op,x,y;scanf("%d%d%d",&amp;v,&amp;op,&amp;x); if(op == 1) &#123; scanf("%d",&amp;y); root[i] = update(root[v], 1, n, x, y); &#125; else &#123; printf("%d\n", query(root[v], 1, n, x)); root[i] = root[v]; &#125; &#125;&#125;//可持久化区间修改区间查询#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define dlson l,mid,lson[nrt]#define drson mid+1,r,rson[nrt]const int maxn = 1e5+5;int n,m;int T[maxn],tot,lson[maxn*20],rson[maxn*20];ll c[maxn*20],cur[maxn*20];void push_up(int rt)&#123; c[rt]=c[lson[rt]]+c[rson[rt]];&#125;void build(int l,int r,int &amp;nrt)&#123; nrt=tot++;cur[nrt]=0; if(l==r)&#123; scanf("%lld",c+nrt);return; &#125;int mid=l+r&gt;&gt;1; build(dlson);build(drson);push_up(nrt);&#125;void update(int L,int R,ll val,int l,int r,int &amp;nrt,int rt)&#123; nrt=tot++; lson[nrt]=lson[rt]; rson[nrt]=rson[rt]; c[nrt]=c[rt]+(R-L+1)*val; cur[nrt]=cur[rt]; if(L==l&amp;&amp;R==r)&#123; cur[nrt]+=val;return; &#125; int mid=l+r&gt;&gt;1; if(R&lt;=mid)update(L,R,val,dlson,lson[rt]); else if(L&gt;mid)update(L,R,val,drson,rson[rt]); else update(L,mid,val,dlson,lson[rt]),update(mid+1,R,val,drson,rson[rt]);&#125;ll query(int L,int R,int l,int r,int nrt,ll add)&#123; if(L==l&amp;&amp;R==r)return c[nrt]+(R-L+1)*add; int mid=l+r&gt;&gt;1; if(R&lt;=mid)return query(L,R,dlson,add+cur[nrt]); else if(L&gt;mid)return query(L,R,drson,add+cur[nrt]); return query(L,mid,dlson,add+cur[nrt])+query(mid+1,R,drson,add+cur[nrt]);&#125;int main()&#123; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; tot=0; build(1,n,T[0]); int time=0; char op[2]; int l,r,d,t; for(int i=1;i&lt;=m;i++)&#123; scanf("%s",op); if(op[0]=='C')&#123; scanf("%d%d%d",&amp;l,&amp;r,&amp;d); update(l,r,d,1,n,T[time+1],T[time]);time++; &#125; else if(op[0]=='Q')&#123; scanf("%d%d",&amp;l,&amp;r); printf("%lld\n",query(l,r,1,n,T[time],0)); &#125; else if(op[0]=='H')&#123; scanf("%d%d%d",&amp;l,&amp;r,&amp;t); printf("%lld\n",query(l,r,1,n,T[t],0)); &#125; else&#123; scanf("%d",&amp;t); tot=T[t+1]; time=t; &#125; &#125; &#125;&#125; 素数筛12345678910111213int p[maxn],cnt=0;bool isp[maxn];void getprime()&#123; memset(isp,true,sizeof(isp)); isp[0]=isp[1]=false; isp[2]=true; for(int i=2;i&lt;maxn;i++)&#123; if(isp[i]) p[cnt++]=i; for(int j=0;j&lt;cnt&amp;&amp;p[j]*i&lt;maxn;j++)&#123; isp[p[j]*i]=false; &#125; &#125;&#125; 快速幂/快速乘12345678910111213141516171819202122232425262728293031323334353637383940414243444546//a^b%pll qpow(ll a,ll b,ll p)&#123; ll res=1; while(b)&#123; if(b&amp;1) res=(res*a)%p; a=(a*a)%p; b&gt;&gt;=1; &#125; return res;&#125;//a*b%pll qmul(ll a,ll b,ll p)&#123; ll res=0; while(b)&#123; if(b&amp;1) res=(res+a)%p; a=(a+a)%p; b&gt;&gt;=1; &#125; return res;&#125;long long ans=((__int128)x*y)%pll qmul(ll x,ll y,ll p)&#123; ll z=(ld)x/p*y; ll res=(ull)x*y-(ull)z*p; return (res+p)%p;&#125;//十进制快速幂 a^ss % modll pow2(ll a,int n)&#123; ll ans=1; for(ll sum=a%mod;n;n&gt;&gt;=1,sum=sum*sum%mod) if(n&amp;1) ans=ans*sum%mod; return ans;&#125;ll pow10(ll a,ll b)&#123; ll sum=a,ans=1; while(b)&#123; int x = b%10; b/=10; ans=ans*pow2(sum,x)%mod; sum=pow2(sum,10); &#125; return ans;&#125; 矩阵快速幂12345678910111213141516171819202122232425262728293031323334//以求fib数列为例const int mod = 1000000007;struct Matrix &#123; ll a[3][3]; Matrix() &#123; memset(a, 0, sizeof a); &#125; // 构造函数，矩阵初始化全零 Matrix operator*(const Matrix &amp;b) const &#123; Matrix res; for (int i = 1; i &lt;= 2; ++i) for (int j = 1; j &lt;= 2; ++j) for (int k = 1; k &lt;= 2; ++k) res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j]) % mod; return res; &#125;&#125; ans,base;void init() &#123; base.a[1][1] = base.a[1][2] = base.a[2][1] = 1; ans.a[1][1] = ans.a[2][1] = 1;&#125;ll qpow(ll b) &#123; while (b) &#123; if (b&amp;1) ans =ans*base; base = base*base; b &gt;&gt;= 1; &#125; return ans.a[1][1];&#125;int main() &#123; ll n; cin&gt;&gt;n; init(); cout&lt;&lt;qpow(n-1)&lt;&lt;'\n';&#125; Crt/Excrt12345678910111213141516171819202122232425262728293031323334353637383940//n个方程：x=a[i](mod m[i]) (0&lt;=i&lt;n)LL china(int n, LL *a, LL *m)&#123; LL M = 1, ret = 0; for(int i = 0; i &lt; n; i ++) M *= m[i]; for(int i = 0; i &lt; n; i ++)&#123; LL w = M / m[i]; ret = (ret + w * inv(w, m[i]) * a[i]) % M; &#125; return (ret + M) % M;&#125;void ex_gcd(LL a, LL b, LL &amp;x, LL &amp;y, LL &amp;d)&#123; if (!b) &#123;d = a, x = 1, y = 0;&#125; else&#123; ex_gcd(b, a % b, y, x, d); y -= x * (a / b); &#125;&#125; LL inv(LL t, LL p)&#123;//如果不存在，返回-1 LL d, x, y; ex_gcd(t, p, x, y, d); return d == 1 ? (x % p + p) % p : -1; &#125;typedef pair&lt;LL, LL&gt; PLL;PLL linear(LL A[], LL B[], LL M[], int n) &#123;//求解A[i]x = B[i] (mod M[i]),总共n个线性方程组 LL x = 0, m = 1; for(int i = 0; i &lt; n; i ++) &#123; LL a = A[i] * m, b = B[i] - A[i]*x, d = __gcd(M[i], a); if(b % d != 0) return PLL(-1, -1);//答案不存在，返回-1 LL t = b/d * inv(a/d, M[i]/d)%(M[i]/d); x = x + m*t; m *= M[i]/d; &#125; x = (x % m + m ) % m; if(x==0) x = m; return PLL(x, m);//返回的x就是答案，m是最后的lcm值 //如果x==0，那么ans为m&#125; Lucas组合数取模12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//求解C(n,m)%P//杨辉三角void get_C()&#123; C[0][0] = 1; for(int i=1;i&lt;=maxn;i++)&#123; C[i][0] = 1; for(int j=1;j&lt;=i;j++) C[i][j] = C[i-1][j]+C[i-1][j-1]; //C[i][j] = (C[i-1][j]+C[i-1][j-1])%MOD; &#125;&#125;//P为素数且较小可以阶乘打表ll fac[maxn];ll C(ll n,ll m,ll p)&#123; if(m&gt;n) return 0; return fac[n]*qpow(fac[m]*fac[n-m],p-2,p)%p;&#125;ll Lucas(ll n,ll m,ll p)&#123; if(m==0) return 1; else return (C(n%p,m%p,p)*Lucas(n/p,m/p,p))%p;&#125;//P为素数且较大ll inv(ll x, ll p)&#123; return qpow(x,p-2,p);&#125;ll C(ll n,ll m,ll p)&#123; if(m&gt;n)return 0; ll up=1,down=1; for(int i=n-m+1;i&lt;=n;i++) up=up*i%p; for(int i=1;i&lt;=m;i++)down=down*i%p; return up*inv(down,p)%p;&#125;ll Lucas(ll n,ll m,ll p)&#123; if(m==0) return 1; return C(n%p,m%p,p)*Lucas(n/p,m/p,p)%p;&#125;//P不为素数ll extgcd(ll a,ll b,ll&amp; x,ll&amp; y)&#123; ll d = a; if(b)&#123; d=extgcd(b,a%b,y,x); y-=(a/b)*x; &#125; else x=1,y=0; return d;&#125;ll mod_inverse(ll a,ll m)&#123; ll x,y; ll d=extgcd(a,m,x,y); return d==1?(m+x%m)%m:-1;&#125;ll Mul(ll n,ll pi,ll pk)&#123; if(!n) return 1; ll ans=1; if(n/pk)&#123; for(ll i=2;i&lt;=pk;i++) if(i%pi)ans=ans*i%pk; ans=qpow(ans,n/pk,pk); &#125; for(ll i=2;i&lt;=n%pk;i++) if(i%pi) ans=ans*i%pk; return ans*Mul(n/pi,pi,pk)%pk;&#125;ll C(ll n,ll m,ll p,ll pi,ll pk)&#123; if(m&gt;n)return 0; ll a=Mul(n,pi,pk),b=Mul(m,pi,pk),c=Mul(n-m,pi,pk); ll k=0,ans; for(ll i=n;i;i/=pi) k+=i/pi; for(ll i=m;i;i/=pi) k-=i/pi; for(ll i=n-m;i;i/=pi) k-=i/pi; ans=a*mod_inverse(b,pk)%pk*mod_inverse(c,pk)%pk*qpow(pi,k,pk)%pk; ans=ans*(p/pk)%p*mod_inverse(p/pk,pk)%p; return ans;&#125;ll Lucas(ll n,ll m,ll p)&#123; ll x=p; ll ans=0; for(ll i=2;i&lt;=p;i++)&#123; if(x%i==0)&#123; ll pk=1; while(x%i==0) pk*=i,x/=i; ans=(ans+C(n,m,p,i,pk))%p; &#125; &#125; return ans;&#125; Miller_Pabin 素数判定12345678910111213141516171819202122232425262728293031323334353637383940// 18位素数：154590409516822759// 19位素数：2305843009213693951 (梅森素数)// 19位素数：4384957924686954497LL prime[6] = &#123;2, 3, 5, 233, 331&#125;;LL qmul(LL x, LL y, LL mod) &#123; // 乘法防止溢出， 如果p * p不爆LL的话可以直接乘； O(1)乘法或者转化成二进制加法 //return (x * y - (long long)(x / (long double)mod * y + 1e-3) *mod + mod) % mod; LL ret = 0; while(y) &#123; if(y &amp; 1) ret = (ret + x) % mod; x = x * 2 % mod; y &gt;&gt;= 1; &#125; return ret;&#125;LL qpow(LL a, LL n, LL mod) &#123; LL ret = 1; while(n) &#123; if(n &amp; 1) ret = qmul(ret, a, mod); a = qmul(a, a, mod); n &gt;&gt;= 1; &#125; return ret;&#125;bool Miller_Rabin(LL p) &#123; if(p &lt; 2) return 0; if(p != 2 &amp;&amp; p % 2 == 0) return 0; LL s = p - 1; while(! (s &amp; 1)) s &gt;&gt;= 1; for(int i = 0; i &lt; 5; ++i) &#123; if(p == prime[i]) return 1; LL t = s, m = qpow(prime[i], s, p); while(t != p - 1 &amp;&amp; m != 1 &amp;&amp; m != p - 1) &#123; m = qmul(m, m, p); t &lt;&lt;= 1; &#125; if(m != p - 1 &amp;&amp; !(t &amp; 1)) return 0; &#125; return 1;&#125; 大数质因数分解Pollard_rho123456789101112131415161718192021222324252627282930ll gcd(ll x,ll y) &#123; if (!x) return 1; if (x&lt;0) return gcd(-x,y); return y?gcd(y,x%y):x;&#125;ll Pollard_rho(ll n,ll t) &#123; int i=1,k=2; ll x0=rand()%n,y=x0; while (1) &#123; i++; x0=(qmul(x0,x0,n)+t)%n; ll d=gcd(y-x0,n); if(d!=1&amp;&amp;d!=n) return d; if(y==x0) return n; if(i==k) y=x0,k&lt;&lt;=1; &#125; &#125;int tot;ll fac[1005];void findfac(ll n) &#123; if (n==1) return; if (Miller_Rabin(n)) &#123; fac[tot++]=n; return; &#125; ll p=n; while (p&gt;=n) p=Pollard_rho(p,rand()%(n-1)+1); findfac(p);findfac(n/p);&#125; BM递推123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include &lt;bits/stdc++.h&gt; using namespace std;#define rep(i,a,n) for (long long i=a;i&lt;n;i++)#define per(i,a,n) for (long long i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((long long)(x).size())typedef vector&lt;long long&gt; VI;typedef long long ll;typedef pair&lt;long long,long long&gt; PII;const ll mod=1e9+7;ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;// head long long _,n;namespace linear_seq&#123; const long long N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;long long&gt; Md; void mul(ll *a,ll *b,long long k) &#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (long long i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; long long solve(ll n,VI a,VI b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+...// printf("%d\n",SZ(b)); ll ans=0,pnt=0; long long k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (long long p=pnt;p&gt;=0;p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (long long i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; &#125; VI BM(VI s) &#123; VI C(1,1),B(1,1); long long L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; long long gao(VI a,ll n) &#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); &#125;&#125;; int main()&#123; while(~scanf("%I64d", &amp;n)) &#123; printf("%I64d\n",linear_seq::gao(VI&#123;1,5,11,36,95,281,781,2245,6336,18061, 51205&#125;,n-1)); &#125;&#125;#include&lt;bits/stdc++.h&gt;#define ll long long#define VI vector&lt;ll&gt;using namespace std;//BM:求线性递推数列第n项，请保证模数的平方不会爆long longclass Linear_Seq&#123;public: static const int N = 50010;//多项式系数项数最大值 ll res[N],c[N],vis[N],Mod,COEF[N];//COEF是多项式系数 vector&lt;int&gt; md; inline static ll exgcd(ll a,ll b, ll &amp;x,ll &amp;y) &#123; if(!b) &#123; x = 1,y = 0; return a; &#125; ll ret = exgcd(b,a%b,y,x); y -= a/b*x; return ret; &#125; inline static ll getInv(ll a,ll mod)//求a在mod下的逆元，不存在时输出-1 &#123; ll x,y; ll d = exgcd(a,mod,x,y); return d == 1?(x%mod+mod)%mod:-1; &#125; inline void mul(ll *a,ll *b,int k) &#123; fill(c,c+2*k,0); for(int i = 0;i &lt; k;++i) if(a[i]) for(int j = 0;j &lt; k;++j) c[i+j] = (c[i+j]+a[i]*b[j])%Mod; for(int i = 2*k-1;i &gt;= k;--i) if(c[i]) for(size_t j = 0;j &lt; md.size();++j) c[i-k+md[j]] = (c[i-k+md[j]]-c[i]*vis[md[j]])%Mod; copy(c,c+k,a); &#125; int solve(ll n,VI a,VI b)//a系数,b初值b[n+1] = a[0]*b[n]+... &#123; ll ans = 0,cnt = 0; int k = a.size(); for(int i = 0;i &lt; k;++i) vis[k-i-1] = -a[i]; vis[k] = 1;md.clear(); for(int i = 0;i &lt; k;++i) &#123; res[i] = 0; if(vis[i]) md.push_back(i); &#125; res[0] = 1; while((1LL&lt;&lt;cnt) &lt;= n) ++cnt; for(int p = cnt;~p;--p) &#123; mul(res,res,k); if((n&gt;&gt;p)&amp;1) &#123; copy(res,res+k,res+1) ; res[0]=0; for(size_t j = 0;j &lt; md.size();++j) res[md[j]] = (res[md[j]]-res[k]*vis[md[j]])%Mod; &#125; &#125; for(int i = 0;i &lt; k;++i) ans = (ans + res[i]*b[i]) % Mod; return ans + (ans&lt;0?Mod:0); &#125; ///1-st***********模数是质数用这里*******************/ VI BM(VI val) //BM算法求模数是质数的递推式子的通项公式,可以单独用 &#123; VI ans(1,1),lst(1,1); int len = 0,m = 1,fail = 1; for(size_t n = 0;n &lt; val.size();++n) &#123; ll delta = 0; for(int i = 0;i &lt;= len;++i) delta = (delta+(ll)ans[i]*val[n-i])%Mod; if(!delta) ++m; else &#123; VI tmp = ans; ll div = Mod-delta*getInv(fail,Mod)%Mod; while(ans.size() &lt; lst.size()+m) ans.push_back(0); for(size_t i = 0;i &lt; lst.size();++i) ans[i+m] = (ans[i+m]+div*lst[i])%Mod; if(2*len&lt;=(int)n) &#123; len=n+1-len; lst=tmp; fail=delta; m=1; &#125; else ++m ; &#125; &#125; //下边这样写能够输出递推式的系数. printf("F[n] = ") ; for(size_t i(0);i&lt;ans.size();++i) &#123; COEF[i+1] = min(ans[i],Mod-ans[i]) ; if(i&gt;0) &#123; if(i != 1) printf(" + ") ; printf("%lld*F[n-%d]",COEF[i+1],i) ; putchar(i+1==ans.size()?'\n':' ') ; &#125; &#125; return ans; &#125; ///1-ed*************模数是质数用这里*******************/ ///2-st*************模数非质数用这里*******************/ inline static void extand(VI &amp;a,size_t d,ll value = 0) &#123; if(d &lt;= a.size()) return; a.resize(d,value); &#125; inline static ll CRT(const VI &amp;a,const VI &amp;m) &#123; int n = a.size(); ll ans = 0,lcm = 1,x,y; for(int i = 0;i &lt; n;++i) lcm *= m[i]; for(int i = 0;i &lt; n;++i) &#123; ll tp = lcm/m[i]; exgcd(tp,m[i],x,y); x = (x%m[i]+m[i])%m[i]; ans = (ans+tp*x*a[i])%lcm; &#125; return (ans+lcm)%lcm; &#125; static VI ReedsSloane(const VI &amp;s,ll Mod) &#123; auto L = [](const VI &amp;a,const VI &amp;b) &#123; int da = (a.size() &gt; 1 || (a.size() == 1 &amp;&amp; a[0]))?a.size()-1:-1000; int db = (b.size() &gt; 1 || (b.size() == 1 &amp;&amp; b[0]))?b.size()-1:-1000; return max(da,db+1); &#125;; auto prime_power = [&amp;](const VI &amp; s,ll Mod,ll p,ll e) &#123; vector&lt;VI&gt; a(e),b(e),an(e),bn(e),ao(e),bo(e); VI t(e),u(e),r(e),to(e,1),uo(e),pw(e+1); pw[0] = 1; for(int i = 1;i &lt;= e;++i) pw[i] = pw[i-1] * p; for(ll i = 0;i &lt; e;++i) &#123; a[i] = &#123;pw[i]&#125;;an[i] = &#123;pw[i]&#125;; b[i] = &#123;0&#125;,bn[i] = &#123;s[0]*pw[i]%Mod&#125;; t[i] = s[0] * pw[i] %Mod; if(!t[i]) t[i] = 1,u[i] = e; else for(u[i] = 0;t[i] % p == 0;t[i] /= p,++u[i]); &#125; for(size_t k = 1;k &lt; s.size();++k) &#123; for(int g = 0;g &lt; e;++g) &#123; if(L(an[g],bn[g]) &gt; L(a[g],b[g])) &#123; ao[g] = a[e-1-u[g]],bo[g] = b[e-1-u[g]]; to[g] = t[e-1-u[g]],uo[g] = u[e-1-u[g]]; r[g] = k - 1; &#125; &#125; a = an,b = bn; for(int o = 0;o &lt; e;++o) &#123; ll d = 0; for(size_t i = 0;i &lt; a[o].size() &amp;&amp; i &lt;= k;++i) d = (d+a[o][i] * s[k-i])%Mod; if(d == 0) t[o] = 1,u[o] = e; else &#123; for(u[o] = 0,t[o] = d;!(t[o]%p);t[o] /= p,++u[o]); int g(e-1-u[o]); if(!L(a[g],b[g])) &#123; extand(bn[o],k+1); bn[o][k] = (bn[o][k]+d)%Mod; &#125; else &#123; ll coef = t[o]*getInv(to[g],Mod)%Mod*pw[u[o]-uo[g]]%Mod; int m = k-r[g]; extand(an[o],ao[g].size()+m); extand(bn[o],bo[g].size()+m); auto fun = [&amp;](vector&lt;VI&gt; &amp;vn,vector&lt;VI&gt; &amp;vo,bool f) &#123; for (size_t i(0);i &lt; vo[g].size();++i) &#123; vn[o][i+m] -= coef*vo[g][i]%Mod; if (vn[o][i + m]&lt;0) vn[o][i+m] += Mod*(f?1:-1); &#125; while (vn[o].size() &amp;&amp; !vn[o].back()) vn[o].pop_back(); &#125;; fun(an,ao,1),fun(bn,bo,-1); &#125; &#125; &#125; &#125; return make_pair(an[0],bn[0]); &#125;; vector&lt;tuple&lt;ll,ll,int&gt; &gt; fac;//tuple相当于结构体 for(ll i = 2;i * i &lt;= Mod;++i) if(!(Mod% i)) &#123; ll cnt = 0,pw = 1; while(!(Mod%i)) &#123; Mod /= i; ++cnt; pw *= i; &#125; fac.emplace_back(pw,i,cnt);//emplace_back作用同push_back,但直接调用构造函数,相对较快 &#125; if(Mod &gt; 1) fac.emplace_back(Mod,Mod,1); vector&lt;VI&gt; as; size_t n = 0; for(auto &amp;&amp;x: fac) &#123; ll Mod,p,e; VI a,b; std::tie(Mod,p,e) = x; auto ss = s; for(auto &amp;&amp;x: ss) x %= Mod; std::tie(a,b) = prime_power(ss,Mod,p,e); as.emplace_back(a); n = max(n,a.size()); &#125; VI a(n),c(as.size()),m(as.size()); for(size_t i = 0;i &lt; n;++i) &#123; for(size_t j = 0;j &lt; as.size();++j) &#123; m[j] = std::get&lt;0&gt;(fac[j]); c[j] = i &lt; as[j].size()?as[j][i]:0; &#125; a[i] = CRT(c,m); &#125; return a; &#125; ///2-ed***********模数非质数用这里*******************/ ll solve(VI a,ll n,ll Mod,bool prime = true) &#123; VI c; this -&gt; Mod = Mod; if(prime) c = BM(a);//如果已经知道系数了，直接输入到c就行了 else c = ReedsSloane(a,Mod); c.erase(c.begin()); for(size_t i = 0;i &lt; c.size(); ++i) c[i] = (Mod-c[i]) % Mod; return solve(n,c,VI(a.begin(),a.begin() + c.size())); &#125;&#125;BMEX;//BMEX.solve(初始值vector[从0开始],要得到的项数,模数,模数是不是质数)ll qpow(ll a,ll b,ll mod)&#123; ll ans = 1; while(b) &#123; if(b &amp; 1) ans = a * ans %mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans;&#125;ll n;vector&lt;ll&gt; ve;int main()&#123; while(~scanf("%lld",&amp;n))&#123; ve.clear(); ll MOD = 1000000007; ve.push_back(0),ve.push_back(1),ve.push_back(1); for(int i = 3;i &lt; 50;++i) ve.push_back((ve[i-1]+ve[i-2])%MOD); ll ans = BMEX.solve(ve,n,MOD,true); printf("%lld\n",ans); &#125; return 0;&#125; 莫队123456789101112131415161718192021int len = sqrt(n);struct Query&#123; int L,R,id,block; Query()&#123;&#125; Query(int l, int r, int id):L(l), R(r), id(id)&#123; block = L/len; &#125; bool operator &lt; (const Query &amp;hs) const &#123; if(block == hs.block) return R &lt; hs.R; return block &lt; hs.block; &#125;&#125;q[maxm];int L=0,R=0;for(int i=1;i&lt;=m;i++)&#123; while(R &lt; q[i].R) Insert(A[++R]); while(L &gt; q[i].L) Insert(A[--L]); while(R &gt; q[i].R) Erase(A[R--]); while(L &lt; q[i].L) Erase(A[L++]); ans[q[i].id]= ?;&#125; 二分/三分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//找a[]中&gt;=x最小的那个while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(a[mid]&gt;=x) r=mid; else l=mid+1;&#125;return a[l];//找a[]中&lt;=x最大的那个while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(a[mid]&lt;=x) l=mid; else r=mid-1;&#125;return a[l];//普通写法int l=1,r=n,ans;while(l&lt;=r)&#123; int mid = (l+r)&gt;&gt;1; if(pd(b[mid])) l=mid+1,ans=b[mid]; else r=mid-1;&#125;//实数域二分 eps=10^-(k+2)while(l+eps&lt;r)&#123; double mid=(l+r)/2; if(calc(mid)) r=mid;else l=mid;&#125;for(int i=0;i&lt;100;i++)&#123; double mid=(l+r)/2; if(calc(mid)) r=mid;else l=mid;&#125;//三分//doublewhile(l+eps&lt;r)&#123; double lmid = (2*l+r)/3; //l+(r-l)/3 , (l+r)/2 double rmid = (l+2*r)/3; //r-(r-l)/3 , (lmid+r)/2 if(f(lmid)&gt;=f(rmid)) r=rmid; else l=lmid;&#125;//intwhile(l&lt;r)&#123; int lmid = l+(r-l)/3; int rmid = r-(r-l)/3; if(calc(lmid)&lt;calc(rmid)) r=rmid-1; else l=lmid+1;&#125; 最大子矩阵和123456789101112131415161718//枚举子矩阵的上下边界，即将第i行到第j行压缩成一行，然后求一维的最大连续子段和，左右边界就可以确定了// 时间复杂度O(n^3)for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; scanf("%lld",&amp;sum[i][j]); sum[i][j] += sum[i-1][j]; &#125;&#125;ll ans=-1e18;for(int i=1;i&lt;=n;i++)&#123; for(int j=i;j&lt;=n;j++)&#123; for(int k=1;k&lt;=m;k++) tmp[k] = sum[j][k]-sum[i-1][k]; ll mx=tmp[1],res=tmp[1]; for(int k=2;k&lt;=m;k++) mx = max(mx+tmp[k],tmp[k]), res=max(res,mx); ans = max(ans,res); &#125;&#125; 最长上升子序列LIS12345678910111213141516171819//nlogn 求LIS长度以及输出其中一种int len=0;for(int i=1;i&lt;=n;i++)&#123; if(len==0||a[i]&gt;dp[len])&#123; dp[++len]=a[i]; pos[i]=len; &#125; else&#123; *(lower_bound(dp+1,dp+1+len,a[i])) = a[i]; pos[i] = lower_bound(dp+1,dp+1+len,a[i]) - dp; &#125;&#125;int t=len;for(int i=n;i&gt;=1;i--)&#123; if(pos[i]==t)&#123; seq[t--]=a[i]; &#125; if(!t) break;&#125; 拓扑排序12345678910111213141516171819//求有向图顺序或判有环bool topu()&#123; queue&lt;int&gt;q; //要求字典序改优先队列 for(int i=1;i&lt;=n;i++)&#123; if(in[i]==0) q.push(i); &#125; int cnt=0; while(!q.empty())&#123; int x=q.front(); q.pop(); cnt++; for(int i=0;i&lt;V[x].size();i++)&#123; int next=V[x][i]; if(--in[next]==0) q.push(next); Rank[next]=Rank[x]+1; &#125; &#125; return cnt==n;&#125; Dijkstra1234567891011121314151617181920212223242526272829303132333435363738394041//求由form到图中其他点的最短路径struct node&#123; int val,id; node(int id,int val):id(id),val(val) &#123;&#125; bool operator &lt;(const node &amp;hs)const&#123; return val&gt;hs.val; &#125;&#125;;struct edge&#123; int next,to,w;&#125;e[maxm*2];int head[maxn],cnt;void addedge(int u,int v,int w)&#123; e[++cnt]=edge&#123;head[u],v,w&#125;; head[u]=cnt;&#125;int dis[maxn],vis[maxn];void dijkstra(int from)&#123; for(int i=1;i&lt;=n;i++)&#123; dis[i]=INF; vis[i]=0; &#125; priority_queue&lt;node&gt;q; q.push(node(from,0)); dis[from]=0; while(!q.empty())&#123; int cur=q.top().id; q.pop(); if(vis[cur])continue; vis[cur]=true; for(int i=head[cur]; i ; i=e[i].next)&#123; int v=e[i].to; if(dis[cur]+e[i].w &lt; dis[v])&#123; dis[v]=dis[cur]+e[i].w; q.push(node(v,dis[v])); &#125; &#125; &#125;&#125; Floyd12345678//dis[i][i]=0,dis[i][j]表示i到j的最短路径for(int k=1;k&lt;=n;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); &#125; &#125;&#125; 树的直径1234567891011121314//两遍dfspii dfs(int x,int pre)&#123; int mx=0,id=x; for(int i=0;i&lt;v[x].size();i++)&#123; int to = v[x][i].first, w = v[x][i].second; if(to == pre) continue; pii tmp = dfs(v[x][i].first,x); if(tmp.first+w &gt; mx)&#123; mx = tmp.first+w; id = tmp.second; &#125; &#125; return make_pair(mx,id);&#125; Java大数开方1234567891011121314151617181920//判断是否为完全平方数public static boolean check(BigInteger now) &#123; if (now.compareTo(BigInteger.ZERO) == 0 || now.compareTo(BigInteger.ONE) == 0) return true; if (now.mod(BigInteger.valueOf(3)).compareTo(BigInteger.valueOf(2)) == 0) return false; String s = now.toString(); if (s.length() % 2 == 0) s = s.substring(0, s.length() / 2 + 1); else s = s.substring(0, (1 + s.length()) / 2); BigInteger res = BigInteger.ZERO; BigInteger m = new BigInteger(s); BigInteger two = new BigInteger("2"); if (s == "1") res = BigInteger.ONE; else &#123; while (now.compareTo(m.multiply(m)) &lt; 0) &#123; m = (m.add(now.divide(m))).divide(two); &#125; res = m; &#125; if (res.multiply(res).compareTo(now) == 0) return true; return false;&#125; 计算几何1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL ;const int N = 100000+7;#define abs(x) (((x)&gt;0)?(x):-(x))/***************************************/const double PI = acos(-1.0);const double eps = 1e-8;const double INF = 1e18;#define pb push_back#define mp make_pair///*************基础***********/double torad(double deg) &#123; return deg / 180 * PI; &#125;inline int dcmp(double x)&#123; if(fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125;struct Point&#123; double x, y; Point(double x=0, double y=0):x(x),y(y) &#123; &#125; inline void read() &#123; scanf("%lf%lf", &amp;x, &amp;y); &#125;&#125;;typedef vector&lt;Point&gt; Polygon;typedef Point Vector;inline Vector operator+ (Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y); &#125;inline Vector operator- (Point A, Point B) &#123; return Vector(A.x - B.x, A.y - B.y); &#125;inline Vector operator* (Vector A, double p) &#123; return Vector(A.x * p, A.y * p); &#125;inline Vector operator/ (Vector A, double p) &#123; return Vector(A.x / p, A.y / p); &#125;inline bool operator &lt; (Point a, Point b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y); &#125;inline bool operator == (Point a, Point b) &#123; return dcmp(a.x - b.x) == 0 &amp;&amp; dcmp(a.y - b.y) == 0; &#125;inline double Dot(Vector A, Vector B)&#123; return A.x * B.x + A.y * B.y;&#125;double msqrt(double x) &#123; if(x&lt;0) return 0; else return sqrt(x);&#125;double Length(Vector A) &#123; return msqrt(Dot(A, A)); &#125;double Length2(Vector A) &#123; return Dot(A, A); &#125;inline double Angle(Vector A, Vector B) &#123; return acos(Dot(A, B) / Length(A) / Length(B)); &#125;inline double angle(Vector v) &#123; return atan2(v.y, v.x); &#125;inline double Cross(Vector A, Vector B) &#123; return A.x * B.y - A.y * B.x; &#125;//A x B &gt; 0表示A在B的顺时针方向上inline Vector Unit(Vector x) &#123; return x / Length(x); &#125; //单位向量inline Vector Normal(Vector x) &#123; return Point(-x.y, x.x) / Length(x); &#125; //垂直法向量inline double Area2(Point A, Point B, Point C) &#123; return Cross(B - A, C - A); &#125;double Cross3(Point p0,Point p1,Point p2) &#123;return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125;///返回结果为正说明p0p1在p0p2的顺时针方向，正说明p2在向量p0p1的左边（三点构成逆时针方向） ///也可以说明p0在向量p1p2的左边（三点构成逆时针方向）,为负则相反,为0则三点共线(叉积的性质很重要)inline Vector Rotate(Vector A, double rad)&#123; return Vector(A.x * cos(rad) - A.y*sin(rad), A.x*sin(rad) + A.y * cos(rad));&#125;/****************直线与线段**************///求直线p+tv和q+tw的交点 Cross(v, w) == 0无交点Point GetLineIntersection(Point p, Vector v, Point q, Vector w)&#123; Vector u = p - q; double t = Cross(w, u) / Cross(v, w); return p + v * t;&#125;//线段到直线的方位int SegToLine(Point a,Point b,Point c,Point d) &#123;///Seg:ab Line:cd 已验证 int x = dcmp(Cross3(a,c,d)); int y = dcmp(Cross3(b,c,d)); if(x==y&amp;&amp;y==0) return 0;//线上 if(x+y==2) return 1;//同侧 左边 if(x+y==-2) return 2;//同侧 右边 if(x+y==0) return -1;//异侧 if(x+y==1) return -2;//一点在线上，另一点左边 return -3;//一点在线上，另一点右边&#125;//直线ab与直线cd的交点Point LineToLine(Point a,Point b,Point c,Point d) &#123; ///已验证 double x = Cross3(a,c,d),y = Cross3(b,c,d); int xx=dcmp(x),yy=dcmp(y); if(xx==yy&amp;&amp;xx==0) return &#123;-1e10,1e10&#125;;//重合 else if(dcmp(x-y)==0) return &#123;-1e10,-1e10&#125;;//平行 else &#123; Vector u = a-c; Vector v = (b-a)/Length((b-a)); Vector w = (d-c)/Length((d-c)); return a + (Point)(v*(Cross(w,u)/Cross(v,w))); &#125;&#125;//点p在直线ab的投影inline Point GetLineProjection(Point P, Point A, Point B) &#123; ///已验证 Vector v = B - A; return A + v * (Dot(v, P - A) / Dot(v, v));&#125;//点到直线距离inline double DistanceToLine(Point P, Point A, Point B) ///已验证&#123; Vector v1 = B - A, v2 = P - A; return fabs(Cross(v1, v2)) / Length(v1); // 如果不取绝对值，得到的是有向距离&#125;//点在p线段上(包括端点)inline bool OnSegment(Point p, Point a1, Point a2)&#123; return dcmp(Cross(a1-p, a2-p)) == 0 &amp;&amp; dcmp(Dot(a1-p, a2-p)) &lt;= 0;&#125;// 过两点p1, p2的直线一般方程ax+by+c=0// (x2-x1)(y-y1) = (y2-y1)(x-x1)inline void getLineGeneralEquation(Point p1, Point p2, double&amp; a, double&amp; b, double &amp;c) ///已验证&#123; a = p2.y - p1.y; b = p1.x - p2.x; c = -a * p1.x - b * p1.y;&#125;//点到线段距离double DistanceToSegment(Point p, Point a, Point b) ///已验证&#123; if(a == b) return Length(p - a); Vector v1 = b - a, v2 = p - a, v3 = p - b; if(dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if(dcmp(Dot(v1, v3)) &gt; 0) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1);&#125;//两线段最近距离inline double dis_pair_seg(Point p1, Point p2, Point p3, Point p4)&#123; return min(min(DistanceToSegment(p1, p3, p4), DistanceToSegment(p2, p3, p4)), min(DistanceToSegment(p3, p1, p2), DistanceToSegment(p4, p1, p2)));&#125;//线段相交判定inline bool SegmentProperIntersection(Point a, Point b, Point c, Point d)&#123; if(max(a.x , b.x) &lt; min(c.x , d.x)) return false; if(max(a.y , b.y) &lt; min(c.y , d.y)) return false; if(max(c.x , d.x) &lt; min(a.x , b.x)) return false; if(max(c.y , d.y) &lt; min(a.y , b.y)) return false; return dcmp(Cross(b-a,c-a))*dcmp(Cross(b-a,d-a))&lt;=0 &amp;&amp; dcmp(Cross(d-c,a-c))*dcmp(Cross(d-c,b-c))&lt;=0;&#125;// 有向直线。它的左边就是对应的半平面struct Line&#123; Point p, q; // 直线上任意一点,p作为起点 Vector v; // 方向向量 double ang; // 极角，即从x正半轴旋转到向量v所需要的角（弧度） Line() &#123;&#125;// Line(Point P, Vector v):p(P),v(v)// &#123;// ang = atan2(v.y, v.x);// &#125; Line(Point P, Point Q):p(P), q(Q) &#123; v = q - p; ang = atan2(v.y, v.x); &#125; inline bool operator &lt; (const Line&amp; L) const &#123; return ang &lt; L.ang; &#125; inline Point point(double t) &#123; return p + v * t; &#125; inline Line move(double d) &#123; return Line(p + Normal(v) * d, v); &#125; inline void read() &#123; Point q; p.read(), q.read(); v = q - p; ang = atan2(v.y, v.x); &#125;&#125;;//两直线交点inline Point GetLineIntersection(Line a, Line b) ///已验证&#123; return GetLineIntersection(a.p, a.v, b.p, b.v);&#125;// 点p在有向直线L的左边（线上不算）bool OnLeft(const Line&amp; L, const Point&amp; p) ///已验证&#123; return Cross(L.v, p - L.p) &gt; 0;&#125;int PointToLine(Point p,Point a,Point b) &#123;///1:左 -1:右 0:线上 已验证 return dcmp(Cross3(p, a, b));&#125;//// 二直线交点，假定交点惟一存在//Point GetLineIntersection(const Line&amp; a, const Line&amp; b) &#123;// Vector u = a.P-b.P;// double t = Cross(b.v, u) / Cross(a.v, b.v);// return a.P+a.v*t;//&#125;// 半平面交主过程vector&lt;Point&gt; HalfplaneIntersection(vector&lt;Line&gt; L) ///已验证&#123; int n = L.size(); sort(L.begin(), L.end()); // 按极角排序 int first, last; // 双端队列的第一个元素和最后一个元素的下标 vector&lt;Point&gt; p(n); // p[i]为q[i]和q[i+1]的交点 vector&lt;Line&gt; q(n); // 双端队列 vector&lt;Point&gt; ans; // 结果 q[first=last=0] = L[0]; // 双端队列初始化为只有一个半平面L[0] for(int i = 1; i &lt; n; i++) &#123; while(first &lt; last &amp;&amp; !OnLeft(L[i], p[last-1])) last--; while(first &lt; last &amp;&amp; !OnLeft(L[i], p[first])) first++; q[++last] = L[i]; if(fabs(Cross(q[last].v, q[last-1].v)) &lt; eps) // 两向量平行且同向，取内侧的一个 &#123; last--; if(OnLeft(q[last], L[i].p)) q[last] = L[i]; &#125; if(first &lt; last) p[last-1] = GetLineIntersection(q[last-1], q[last]); &#125; while(first &lt; last &amp;&amp; !OnLeft(q[first], p[last-1])) last--; // 删除无用平面 if(last - first &lt;= 1) return ans; // 空集 p[last] = GetLineIntersection(q[last], q[first]); // 计算首尾两个半平面的交点 // 从deque复制到输出中 for(int i = first; i &lt;= last; i++) ans.push_back(p[i]); return ans;&#125;/***********多边形**************///求多边形面积double PolygonArea(vector&lt;Point&gt; p) &#123; ///已验证 int n = p.size(); double area = 0; for(int i = 1; i &lt; n - 1; i++) area += Cross(p[i]-p[0], p[i+1]-p[0]); return area / 2;&#125;//判断点是否在多边形内int isPointInPolygon(Point p, Polygon poly) /// 已验证&#123; int wn = 0; int n = poly.size(); for (int i = 0; i &lt; n; i++) &#123; if (OnSegment(p, poly[i], poly[(i + 1) % n])) return -1; //边界 int k = dcmp(Cross(poly[(i + 1) % n] - poly[i], p - poly[i])); int d1 = dcmp(poly[i].y - p.y); int d2 = dcmp(poly[(i + 1) % n].y - p.y); if (k &gt; 0 &amp;&amp; d1 &lt;= 0 &amp;&amp; d2 &gt; 0) wn++; if (k &lt; 0 &amp;&amp; d2 &lt;= 0 &amp;&amp; d1 &gt; 0) wn--; &#125; if (wn != 0) return 1; //内部 return 0; //外部&#125;//多边形重心 点集逆时针给出Point PolyGravity(Point *p, int n) &#123; Point tmp, g = Point(0, 0); double sumArea = 0, area; for (int i=2; i&lt;n; ++i) &#123; area = Cross(p[i-1]-p[0], p[i]-p[0]); sumArea += area; tmp.x = p[0].x + p[i-1].x + p[i].x; tmp.y = p[0].y + p[i-1].y + p[i].y; g.x += tmp.x * area; g.y += tmp.y * area; &#125; g.x /= (sumArea * 3.0); g.y /= (sumArea * 3.0); return g;&#125;//多边形重心计算模板Point bcenter(vector&lt;Point&gt; pnt) ///已验证&#123; int n = pnt.size(); Point p, s; double tp, area = 0, tpx = 0, tpy = 0; p.x = pnt[0].x; p.y = pnt[0].y; //FE(i, 1, n) for(int i=1;i&lt;=n;i++) &#123; s.x = pnt[(i == n) ? 0 : i].x; s.y = pnt[(i == n) ? 0 : i].y; tp = (p.x * s.y - s.x * p.y); area += tp / 2; tpx += (p.x + s.x) * tp; tpy += (p.y + s.y) * tp; p.x = s.x; p.y = s.y; &#125; s.x = tpx / (6 * area); s.y = tpy / (6 * area); return s;&#125;// 点集凸包// 如果希望在凸包的边上有输入点，把两个 &lt;= 改成 &lt;// 注意：输入点集会被修改vector&lt;Point&gt; ConvexHull(vector&lt;Point&gt;&amp; p) /// 已验证&#123; // 预处理，删除重复点 sort(p.begin(), p.end()); p.erase(unique(p.begin(), p.end()), p.end()); int n = p.size(); int m = 0; vector&lt;Point&gt; ch(n+1); for(int i = 0; i &lt; n; i++) &#123; while(m &gt; 1 &amp;&amp; Cross(ch[m-1]-ch[m-2], p[i]-ch[m-2]) &lt;= 0) m--; ch[m++] = p[i]; &#125; int k = m; for(int i = n-2; i &gt;= 0; i--) &#123; while(m &gt; k &amp;&amp; Cross(ch[m-1]-ch[m-2], p[i]-ch[m-2]) &lt;= 0) m--; ch[m++] = p[i]; &#125; if(n &gt; 1) m--; ch.resize(m); return ch;&#125;inline double Dist2(Point a, Point b)&#123; return msqrt(a.x - b.x) + msqrt(a.y - b.y);&#125;// 返回点集直径的平方double diameter2(vector&lt;Point&gt;&amp; points)&#123; vector&lt;Point&gt; p = ConvexHull(points); int n = p.size(); if(n == 1) return 0; if(n == 2) return Dist2(p[0], p[1]); p.push_back(p[0]); // 免得取模 double ans = 0; for(int u = 0, v = 1; u &lt; n; u++) &#123; // 一条直线贴住边p[u]-p[u+1] for(;;) &#123; // 当Area(p[u], p[u+1], p[v+1]) &lt;= Area(p[u], p[u+1], p[v])时停止旋转 // 即Cross(p[u+1]-p[u], p[v+1]-p[u]) - Cross(p[u+1]-p[u], p[v]-p[u]) &lt;= 0 // 根据Cross(A,B) - Cross(A,C) = Cross(A,B-C) // 化简得Cross(p[u+1]-p[u], p[v+1]-p[v]) &lt;= 0 int diff = Cross(p[u+1]-p[u], p[v+1]-p[v]); if(diff &lt;= 0) &#123; ans = max(ans, Dist2(p[u], p[v])); // u和v是对踵点 if(diff == 0) ans = max(ans, Dist2(p[u], p[v+1])); // diff == 0时u和v+1也是对踵点 break; &#125; v = (v + 1) % n; &#125; &#125; return ans;&#125;//两凸包最近距离double RC_Distance(Point *ch1, Point *ch2, int n, int m)&#123; int q=0, p=0; //REP(i, n) for(int i=1;i&lt;=n;i++) if(ch1[i].y-ch1[p].y &lt; -eps) p=i; //REP(i, m) for(int i=1;i&lt;=m;i++) if(ch2[i].y-ch2[q].y &gt; eps) q=i; ch1[n]=ch1[0]; ch2[m]=ch2[0]; double tmp, ans=1e100; //REP(i, n) for(int i=1;i&lt;=n;i++) &#123; while((tmp = Cross(ch1[p+1]-ch1[p], ch2[q+1]-ch1[p]) - Cross(ch1[p+1]-ch1[p], ch2[q]- ch1[p])) &gt; eps) q=(q+1)%m; if(tmp &lt; -eps) ans = min(ans,DistanceToSegment(ch2[q],ch1[p],ch1[p+1])); else ans = min(ans,dis_pair_seg(ch1[p],ch1[p+1],ch2[q],ch2[q+1])); p=(p+1)%n; &#125; return ans;&#125;//两凸包最近距离//使用vectordouble RC_Distance(vector&lt;Point&gt; ch1, vector&lt;Point&gt; ch2)&#123; int q = 0, p = 0, n = ch1.size(), m = ch2.size(); //REP(i, n) for(int i=1;i&lt;=n;i++) if(ch1[i].y-ch1[p].y &lt; -eps) p=i; //REP(i, m) for(int i=1;i&lt;=m;i++) if(ch2[i].y-ch2[q].y &gt; eps) q=i; ch1.push_back(ch1[0]), ch2.push_back(ch2[0]); double tmp, ans=1e100; //REP(i, n) for(int i=1;i&lt;=n;i++) &#123; while((tmp = Cross(ch1[p+1]-ch1[p], ch2[q+1]-ch1[p]) - Cross(ch1[p+1]-ch1[p], ch2[q]- ch1[p])) &gt; eps) q=(q+1)%m; if(tmp &lt; -eps) ans = min(ans,DistanceToSegment(ch2[q],ch1[p],ch1[p+1])); else ans = min(ans,dis_pair_seg(ch1[p],ch1[p+1],ch2[q],ch2[q+1])); p=(p+1)%n; &#125; return ans;&#125;//凸包最大内接三角形double RC_Triangle(Point* res,int n)&#123; if(n &lt; 3) return 0; double ans = 0, tmp; res[n] = res[0]; int j, k; //REP(i, n) for(int i=1;i&lt;=n;i++) &#123; j = (i+1)%n; k = (j+1)%n; while((j != k) &amp;&amp; (k != i)) &#123; while(Cross(res[j] - res[i], res[k+1] - res[i]) &gt; Cross(res[j] - res[i], res[k] - res[i])) k= (k+1)%n; tmp = Cross(res[j] - res[i], res[k] - res[i]); if(tmp &gt; ans) ans = tmp; j = (j+1)%n; &#125; &#125; return ans;&#125;//凸包最大内接三角形double RC_Triangle(vector&lt;Point&gt; res, Point&amp; a, Point&amp; b, Point&amp; c)&#123; int n = res.size(); if(n &lt; 3) return 0; double ans=0, tmp; res.push_back(res[0]); int j, k; //REP(i, n) for(int i=1;i&lt;=n;i++) &#123; j = (i+1)%n; k = (j+1)%n; while((j != k) &amp;&amp; (k != i)) &#123; while(Cross(res[j] - res[i], res[k+1] - res[i]) &gt; Cross(res[j] - res[i], res[k] - res[i])) k= (k+1)%n; tmp = Cross(res[j] - res[i], res[k] - res[i]); if(tmp &gt; ans) &#123; a = res[i], b = res[j], c = res[k]; ans = tmp; &#125; j = (j+1)%n; &#125; &#125; return ans;&#125;//判断两凸包是否有交点bool ConvexPolygonDisjoint(const vector&lt;Point&gt; ch1, const vector&lt;Point&gt; ch2)&#123; int c1 = ch1.size(); int c2 = ch2.size(); for(int i = 0; i &lt; c1; i++) if(isPointInPolygon(ch1[i], ch2) != 0) return false; // 内部或边界上 for(int i = 0; i &lt; c2; i++) if(isPointInPolygon(ch2[i], ch1) != 0) return false; // 内部或边界上 for(int i = 0; i &lt; c1; i++) for(int j = 0; j &lt; c2; j++) if(SegmentProperIntersection(ch1[i], ch1[(i+1)%c1], ch2[j], ch2[(j+1)%c2])) return false; return true;&#125;inline double dist(Point a, Point b)&#123; return Length(a - b);&#125;////模拟退火求费马点 保存在ptres中//double fermat_point(Point *pt, int n, Point&amp; ptres)//&#123;// Point u, v;// double step = 0.0, curlen, explen, minlen;// int i, j, k;// bool flag;// u.x = u.y = v.x = v.y = 0.0;// //REP(i, n)// for(int i=1;i&lt;=n;i++)// &#123;// step += fabs(pt[i].x) + fabs(pt[i].y);// u.x += pt[i].x;// u.y += pt[i].y;// &#125;// u.x /= n;// u.y /= n;// flag = 0;// while(step &gt; eps)// &#123;// for(k = 0; k &lt; 10; step /= 2, ++k)// for(i = -1; i &lt;= 1; ++i)// for(j = -1; j &lt;= 1; ++j)// &#123;// v.x = u.x + step*i;// v.y = u.y + step*j;// curlen = explen = 0.0;// //REP(i, n)// for(int i=1;i&lt;=n;i++)// &#123;// curlen += dist(u, pt[idx]);// explen += dist(v, pt[idx]);// &#125;// if(curlen &gt; explen)// &#123;// u = v;// minlen = explen;// flag = 1;// &#125;// &#125;// &#125;// ptres = u;// return flag ? minlen : curlen;//&#125;//多边形费马点//到所有顶点的距离和最小Point Fermat(int np, Point* p)&#123; double nowx = 0, nowy = 0; double nextx = 0, nexty = 0; //REP(i, np) for(int i=1;i&lt;=np;i++) &#123; nowx += p[i].x; nowy += p[i].y; &#125; for (nowx /= np, nowy /= np;; nowx = nextx, nowy = nexty) &#123; double topx = 0, topy = 0, bot = 0; //REP(i, np) for(int i=1;i&lt;=np;i++) &#123; double d = msqrt(msqrt(nowx - p[i].x) + msqrt(nowy - p[i].y)); topx += p[i].x / d; topy += p[i].y / d; bot += 1 / d; &#125; nextx = topx / bot; nexty = topy / bot; if (dcmp(nextx - nowx) == 0 &amp;&amp; dcmp(nexty - nowy) == 0) break; &#125; Point fp; fp.x = nowx; fp.y = nowy; return fp;&#125;//最近点对//使用前先对输入的point进行排序,使用cmpxy函数Point point[N];int tmpt[N];inline double dist(int x, int y)&#123; Point&amp; a = point[x]; Point&amp; b = point[y]; return msqrt(msqrt(a.x - b.x) + msqrt(a.y - b.y));&#125;inline bool cmpxy(Point a, Point b)&#123; if(a.x != b.x) return a.x &lt; b.x; return a.y &lt; b.y;&#125;inline bool cmpy(int a, int b)&#123; return point[a].y &lt; point[b].y;&#125;double Closest_Pair(int left, int right)&#123; double d = INF; if(left==right) return d; if(left + 1 == right) return dist(left, right); int mid = (left+right)&gt;&gt;1; double d1 = Closest_Pair(left,mid); double d2 = Closest_Pair(mid+1,right); d = min(d1,d2); int k=0; //分离出宽度为d的区间 //FE(i, left, right) for(int i=left;i&lt;=right;i++) &#123; if(fabs(point[mid].x-point[i].x) &lt;= d) tmpt[k++] = i; &#125; sort(tmpt,tmpt+k,cmpy); //线性扫描 //REP(i, k) for(int i=0;i&lt;k;i++) &#123; for(int j = i+1; j &lt; k &amp;&amp; point[tmpt[j]].y-point[tmpt[i]].y&lt;d; j++) &#123; double d3 = dist(tmpt[i],tmpt[j]); if(d &gt; d3) d = d3; &#125; &#125; return d;&#125;/************圆************/struct Circle&#123; Point c; double r; Circle() &#123;&#125; Circle(Point c, double r):c(c), r(r) &#123;&#125; inline Point point(double a) //根据圆心角求点坐标 &#123; return Point(c.x+cos(a)*r, c.y+sin(a)*r); &#125; inline void read() &#123; scanf("%lf%lf%lf", &amp;c.x, &amp;c.y, &amp;r); &#125;&#125;;//求a点到b点(逆时针)在的圆上的圆弧长度double DisOnCircle(Point a, Point b, Circle C) ///已验证&#123; double ang1 = angle(a - C.c); double ang2 = angle(b - C.c); if (ang2 &lt; ang1) ang2 += 2 * PI; return C.r * (ang2 - ang1);&#125;//直线与圆交点 返回个数int LineCircle(Point p1,Point p2,Circle c ,vector&lt;Point&gt;&amp; p) &#123; /// 已验证 Point m = GetLineProjection(c.c, p1, p2); double h2 = Length2(c.c-m); int fg = dcmp(c.r*c.r-h2); double len = Length(p2-p1); if(!fg)&#123; p.push_back(m); return 1; &#125;else if(fg&gt;0) &#123; double rate = msqrt(c.r*c.r-h2)/len; p.push_back(m-(p2-p1)*rate); p.push_back(m+(p2-p1)*rate); return 2; &#125;else return 0;&#125;//两圆交点 返回个数int getCircleCircleIntersection(Circle C1, Circle C2, vector&lt;Point&gt;&amp; sol) &#123; ///已验证 double d = Length(C1.c - C2.c); if(dcmp(d) == 0) &#123; if(dcmp(C1.r - C2.r) == 0) return -1; // 重合，无穷多交点 return 0; &#125; if(dcmp(C1.r + C2.r - d) &lt; 0) return 0; if(dcmp(fabs(C1.r-C2.r) - d) &gt; 0) return 0; double a = angle(C2.c - C1.c); double da = acos((C1.r*C1.r + d*d - C2.r*C2.r) / (2*C1.r*d)); Point p1 = C1.point(a-da), p2 = C1.point(a+da); sol.push_back(p1); if(p1 == p2) return 1; sol.push_back(p2); return 2;&#125;//两圆的公切线, -1表示无穷条切线//返回切线的条数, -1表示无穷条切线//a[i]和b[i]分别是第i条切线在圆A和圆B上的切点int getTangents(Circle A, Circle B, Point* a, Point* b) ///已验证&#123; int cnt = 0; if (A.r &lt; B.r) swap(A, B), swap(a, b); ///**************************** long long d2 = (A.c.x - B.c.x) * (A.c.x - B.c.x) + (A.c.y - B.c.y) * (A.c.y - B.c.y); long long rdiff = A.r - B.r; long long rsum = A.r + B.r; if (d2 &lt; rdiff * rdiff) return 0; //内含 ///*************************************** double base = atan2(B.c.y - A.c.y, B.c.x - A.c.x); if (d2 == 0 &amp;&amp; A.r == B.r) return -1; //无线多条切线 if (d2 == rdiff * rdiff) //内切, 1条切线 &#123; ///********************** a[cnt] = A.point(base); b[cnt] = B.point(base); cnt++; return 1; &#125; //有外公切线 double ang = acos((A.r - B.r) / msqrt(d2 * 1.0)); a[cnt] = A.point(base + ang); b[cnt] = B.point(base + ang); cnt++; a[cnt] = A.point(base - ang); b[cnt] = B.point(base - ang); cnt++; if (d2 == rsum * rsum) //一条内公切线 &#123; a[cnt] = A.point(base); b[cnt] = B.point(PI + base); cnt++; &#125; else if (d2 &gt; rsum * rsum) //两条内公切线 &#123; double ang = acos((A.r + B.r) / msqrt(d2 * 1.0)); a[cnt] = A.point(base + ang); b[cnt] = B.point(PI + base + ang); cnt++; a[cnt] = A.point(base - ang); b[cnt] = B.point(PI + base - ang); cnt++; &#125; return cnt;&#125;// 过点p到圆C的切线。v[i]是第i条切线的向量。返回切线条数int getTangents(Point p,Circle c,vector&lt;Point&gt;&amp; v) &#123;//存入的向量 Vector u = c.c - p; double dist = Length(u); if(dist &lt; c.r) return 0; else if(dcmp(dist - c.r) == 0)&#123; // p在圆上，只有一条切线 v.push_back(Rotate(u, PI/2)); return 1; &#125;else&#123; double ang = asin(c.r / dist); v.push_back(Rotate(u, -ang)); v.push_back(Rotate(u, ang)); return 2; &#125;&#125;// 过点p到圆C的切点int getTangentPoints(Point p, Circle C, vector&lt;Point&gt;&amp; v) /// 已验证&#123; Vector u = C.c - p; double dist = Length(u); if(dist &lt; C.r) return 0; else if(dcmp(dist - C.r) == 0) // p在圆上，只有一条切线 &#123; v.push_back(p); return 1; &#125; else &#123; double ang = asin(C.r / dist); double d = msqrt(dist * dist - C.r * C.r); v.push_back(p + Unit(Rotate(u, -ang)) * d); v.push_back(p + Unit(Rotate(u, +ang)) * d); return 2; &#125;&#125;//圆A与圆B的切点void getTangentPoints(Circle A, Circle B, vector&lt;Point&gt;&amp; a)&#123; if (A.r &lt; B.r) swap(A, B); ///**************************** long long d2 = msqrt(A.c.x - B.c.x) + msqrt(A.c.y - B.c.y); long long rdiff = A.r - B.r, rsum = A.r + B.r; if (d2 &lt; rdiff * rdiff) return; //内含 ///*************************************** double base = atan2(B.c.y - A.c.y, B.c.x - A.c.x); if (d2 == 0 &amp;&amp; A.r == B.r) return; //无线多条切线 if (d2 == rdiff * rdiff) //内切, 1条切线 &#123; ///********************** a.push_back(A.point(base)); a.push_back(B.point(base)); return; &#125; //有外公切线 double ang = acos((A.r - B.r) / msqrt(d2 * 1.0)); a.push_back(A.point(base + ang)); a.push_back(B.point(base + ang)); a.push_back(A.point(base - ang)); a.push_back(B.point(base - ang)); if (d2 == rsum * rsum) //一条内公切线 &#123; a.push_back(A.point(base)); a.push_back(B.point(PI + base)); &#125; else if (d2 &gt; rsum * rsum) //两条内公切线 &#123; double ang = acos((A.r + B.r) / msqrt(d2 * 1.0)); a.push_back(A.point(base + ang)); a.push_back(B.point(PI + base + ang)); a.push_back(A.point(base - ang)); a.push_back(B.point(PI + base - ang)); &#125;&#125;//三角形外接圆Circle CircumscribedCircle(Point p1, Point p2, Point p3) /// 已验证&#123; double Bx = p2.x-p1.x, By = p2.y-p1.y; double Cx = p3.x-p1.x, Cy = p3.y-p1.y; double D = 2*(Bx*Cy-By*Cx); double cx = (Cy*(Bx*Bx+By*By) - By*(Cx*Cx+Cy*Cy))/D + p1.x; double cy = (Bx*(Cx*Cx+Cy*Cy) - Cx*(Bx*Bx+By*By))/D + p1.y; Point p = Point(cx, cy); return Circle(p, Length(p1-p));&#125;//三角形内切圆Circle InscribedCircle(Point p1, Point p2, Point p3) /// 已验证&#123; double a = Length(p2-p3); double b = Length(p3-p1); double c = Length(p1-p2); Point p = (p1*a+p2*b+p3*c)/(a+b+c); return Circle(p, DistanceToLine(p, p1, p2));&#125;//半径为r 与a b两直线相切的圆心vector&lt;Point&gt; CircleTangentToLinesGivenRadius(Line a, Line b, double r)&#123; vector&lt;Point&gt; ans; Line L1 = a.move(-r), L2 = a.move(r); Line L3 = b.move(-r), L4 = b.move(r); ans.push_back(GetLineIntersection(L1, L3)); ans.push_back(GetLineIntersection(L1, L4)); ans.push_back(GetLineIntersection(L2, L3)); ans.push_back(GetLineIntersection(L2, L4)); return ans;&#125;//与两圆相切 半径为r的所有圆心vector&lt;Point&gt; CircleTangentToTwoDisjointCirclesWithRadius(Circle c1, Circle c2, double r)&#123; vector&lt;Point&gt; ans; Vector v = c2.c - c1.c; double dist = Length(v); int d = dcmp(dist - c1.r -c2.r - r*2); if(d &gt; 0) return ans; getCircleCircleIntersection(Circle(c1.c, c1.r+r), Circle(c2.c, c2.r+r), ans); return ans;&#125;//多边形与圆相交面积Point GetIntersection(Line a, Line b) //线段交点&#123; Vector u = a.p-b.p; double t = Cross(b.v, u) / Cross(a.v, b.v); return a.p + a.v*t;&#125;inline bool InCircle(Point x, Circle c)&#123; return dcmp(c.r - Length(c.c - x)) &gt;= 0;&#125;inline bool OnCircle(Point x, Circle c)&#123; return dcmp(c.r - Length(c.c - x)) == 0;&#125;//线段与圆的交点int getSegCircleIntersection(Line L, Circle C, Point* sol)&#123; Vector nor = Normal(L.v); Line pl = Line(C.c, nor); Point ip = GetIntersection(pl, L); double dis = Length(ip - C.c); if (dcmp(dis - C.r) &gt; 0) return 0; Point dxy = Unit(L.v) * msqrt(msqrt(C.r) - msqrt(dis)); int ret = 0; sol[ret] = ip + dxy; if (OnSegment(sol[ret], L.p, L.point(1))) ret++; sol[ret] = ip - dxy; if (OnSegment(sol[ret], L.p, L.point(1))) ret++; return ret;&#125;//线段切割圆double SegCircleArea(Circle C, Point a, Point b)&#123; double a1 = angle(a - C.c); double a2 = angle(b - C.c); double da = fabs(a1 - a2); if (da &gt; PI) da = PI * 2.0 - da; return dcmp(Cross(b - C.c, a - C.c)) * da * msqrt(C.r) / 2.0;&#125;//多边形与圆相交面积double PolyCiclrArea(Circle C, Point *p, int n)&#123; double ret = 0.0; Point sol[2]; p[n] = p[0]; //REP(i, n) for(int i=1;i&lt;=n;i++) &#123; //double t1, t2; int cnt = getSegCircleIntersection(Line(p[i], p[i+1]-p[i]), C, sol); if (cnt == 0) &#123; if (!InCircle(p[i], C) || !InCircle(p[i+1], C)) ret += SegCircleArea(C, p[i], p[i+1]); else ret += Cross(p[i+1] - C.c, p[i] - C.c) / 2.0; &#125; if (cnt == 1) &#123; if (InCircle(p[i], C) &amp;&amp; !InCircle(p[i+1], C)) ret += Cross(sol[0] - C.c, p[i] - C.c) / 2.0, ret += SegCircleArea(C, sol[0], p[i+1]); else ret += SegCircleArea(C, p[i], sol[0]), ret += Cross(p[i+1] - C.c, sol[0] - C.c) / 2.0; &#125; if (cnt == 2) &#123; if ((p[i] &lt; p[i + 1]) ^ (sol[0] &lt; sol[1])) swap(sol[0], sol[1]); ret += SegCircleArea(C, p[i], sol[0]); ret += Cross(sol[1] - C.c, sol[0] - C.c) / 2.0; ret += SegCircleArea(C, sol[1], p[i+1]); &#125; &#125; return fabs(ret);&#125;double area(vector&lt;Point&gt;p) //计算凸包的面积&#123; double ans = 0; int sz = p.size(); for (int i = 1; i &lt; sz - 1; i++) ans += Cross(p[i] - p[0], p[i + 1] - p[0]); return ans / 2.0;&#125;double seg(Point o, Point a, Point b)&#123; if (dcmp(b.x - a.x) == 0) return (o.y - a.y) / (b.y - a.y); return (o.x - a.x) / (b.x - a.x);&#125;vector&lt;Point&gt; pp[110];pair&lt;double, int&gt; s[2200];double polyunion(vector&lt;Point&gt;*p, int n)//求n个多凸包的面积交&#123; double ret = 0; for (int i = 0; i &lt; n; i++) &#123; int sz = p[i].size(); for (int j = 0; j &lt; sz; j++) &#123; int m = 0; s[m++] = mp(0, 0); s[m++] = mp(1, 0); Point a = p[i][j], b = p[i][(j + 1) % sz]; for (int k = 0; k &lt; n; k++) &#123; if (i != k) &#123; int siz = p[k].size(); for (int ii = 0; ii &lt; siz; ii++) &#123; Point c = p[k][ii], d = p[k][(ii + 1) % siz]; int c1 = dcmp(Cross(b - a, c - a)); int c2 = dcmp(Cross(b - a, d - a)); if (c1 == 0 &amp;&amp; c2 == 0) &#123; if (dcmp(Dot(b - a, d - c)) &gt; 0 &amp;&amp; i &gt; k) &#123; s[m++] = mp(seg(c, a, b), 1); s[m++] = mp(seg(d, a, b), -1); &#125; &#125; else &#123; double s1 = Cross(d - c, a - c); double s2 = Cross(d - c, b - c); if (c1 &gt;= 0 &amp;&amp; c2 &lt; 0) s[m++] = mp(s1 / (s1 - s2), 1); else if (c1 &lt; 0 &amp;&amp; c2 &gt;= 0) s[m++] = mp(s1 / (s1 - s2), -1); &#125; &#125; &#125; &#125; sort(s, s + m); double pre = min(max(s[0].first, 0.0), 1.0), now; double sum = 0; int cov = s[0].second; for (int j = 1; j &lt; m; j++) &#123; now = min(max(s[j].first, 0.0), 1.0); if (!cov) sum += now - pre; cov += s[j].second; pre = now; &#125; ret += Cross(a, b)*sum; &#125; &#125; return ret / 2;&#125;int main()&#123; return 0;&#125; 其他 输出保留c位小数点 1printf("%.*f\n", c, (double)a/b); 平方和公式$1^2+2^2+3^2+…+n^2 = n(n+1)(2n+1)/6$ $2^2+4^2+6^2+…+(2n)^2=2n(n+1)(2n+1)/3$ 立方和公式$1^3+2^3+3^3+…+n^3=（n(n+1)/2)^2$ 等差数列求和公式$S_n=n(a_1+a_n)/2$ 等比数列求和公式:$S_n=a_1(1-q^n)/(1-q)$ 组合数性质 $C_n^0+C_n^1+…+C_n^n=2^n$ 错排公式：$D(1)=0,D(2)=1;D(n)=(n-1)[D(n-2)+D(n-1)]$ 等价类划分 $S_0=1,S_n=C(n-1,0)*S_{n-1}+C(n-1,1)*S_{n-2}+…+C(n-1,n-1)*S_0$ 斐波那契数列的性质 三角形面积 $S = \frac{1}{2}absin(\theta )$ $p = \frac{1}{2}(a+b+c),S=\sqrt{p(p-a)(p-b)(p-c)}$ 基姆拉尔森公式 12345678910int m[15]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;if( (year%4==0&amp;&amp;year%100!=0) || year%400==0 ) m[2]=29; //闰年else m[2]=28; //平年int larson(int year,int month,int day)&#123; if(month == 1 || month == 2)&#123; year -= 1; month += 12; &#125; return (day+2*month+3*(month+1)/5+year+(year/4)-(year/100)+(year/400)+1)%7;&#125; 两矩形相交部分(a,c) - (b,d) 12345int a,b,c,d;a=max(min(x1,x2),min(x3,x4));b=min(max(x1,x2),max(x3,x4));c=max(min(y1,y2),min(y3,y4));d=min(max(y1,y2),max(y3,y4)); 浮点数判断大小 123int sgn(double a)&#123; return a &lt; -eps ? -1 : a &lt; eps ? 0 : 1;&#125; 勾股数构造 当a为大于1的奇数2n+1时，b=2n²+2n, c=2n²+2n+1 当a为大于4的偶数2n时，b=n²-1, c=n²+1 希尔伯特曲线坐标与编号相互转换 123456789101112131415161718192021222324252627282930313233343536void rot(int n, int* x, int* y, int rx, int ry)&#123; if (ry == 0)&#123; if (rx == 1)&#123; *x = n - 1 - *x; *y = n - 1 - *y; &#125; int t = *x; *x = *y; *y = t; &#125;&#125;//convert (x,y) to d // 1&lt;&lt;k==n,x,y从0开始,注意方向ll xy2d(int n, int x, int y)&#123; int rx, ry, s; ll d = 0; for (s = n / 2; s &gt; 0; s /= 2)&#123; rx = (x &amp; s) &gt; 0; ry = (y &amp; s) &gt; 0; d += s * s * ((3 * rx) ^ ry); rot(n, &amp;x, &amp;y, rx, ry); &#125; return d;&#125;//convert d to (x,y)void d2xy(int n, int d, int* x, int* y)&#123; int rx, ry, s, t = d; *x = *y = 0; for (s = 1; s &lt; n; s *= 2)&#123; rx = 1 &amp; (t / 2); ry = 1 &amp; (t ^ rx); rot(s, x, y, rx, ry); *x += s * rx; *y += s * ry; t /= 4; &#125;&#125; 快排partition 1234567891011int partition(vector&lt;int&gt;&amp; a,int l,int h)&#123; int pivot = a[l]; while (l&lt;h) &#123; while(l&lt;h &amp;&amp; a[h]&gt;=pivot) h--; a[l]=a[h]; while(l&lt;h &amp;&amp; a[l]&lt;=pivot) l++; a[h]=a[l]; &#125; a[l]=pivot; return l;&#125; 约瑟夫环数学递推 123456scanf("%d%d", &amp;n, &amp;m); //总人数[1...n] 每次跳m步int s = 0;for (i = 2; i &lt;= n; i++)&#123; s = (s + m) % i;&#125;return s+1; 快速统计二进制中1的个数 1234while (n != 0) &#123; cnt++; n &amp;= (n - 1); //依次消掉低位第一个1&#125; 判断是否为2的次幂 1return x&gt;0 &amp;&amp; x&amp;(x-1)==0; 不需额外变量交换两整数 12345a ^= b ^= a ^= b;a = a + b;b = a - b;a = a - b; 根据前序中序遍历结果构造二叉树 123456789101112TreeNode* reConstructBinaryTree(vector&lt;int&gt; &amp;pre,vector&lt;int&gt; &amp;in) &#123; for(int i=0;i&lt;in.size();i++) pos[in[i]]=i; return dfs(pre,0,pre.size()-1,0);&#125;TreeNode* dfs(vector&lt;int&gt; &amp;pre,int preL,int preR,int inL)&#123; if(preL &gt; preR) return NULL; int val = pre[preL],Lsize = pos[val]-inL; TreeNode* root = new TreeNode(val); root-&gt;left = dfs(pre,preL+1,preL+Lsize,inL); root-&gt;right = dfs(pre,preL+Lsize+1,preR,inL+Lsize+1); return root;&#125; O(n)求二叉树中所有路径和为target的路径数 1234567891011121314151617unordered_map&lt;int,int&gt;presum;//根节点到所有父节点的路径和及其个数int ans;int pathSum(TreeNode* root, int target) &#123; ans=0; presum[0]=1; dfs(root,0,target); return ans;&#125;void dfs(TreeNode* root,int cursum,int target)&#123; if(!root) return; cursum += root-&gt;val; if(presum.count(cursum-target)) ans += presum[cursum-target]; presum[cursum]++; dfs(root-&gt;left,cursum,target); dfs(root-&gt;right,cursum,target); presum[cursum]--; //回溯注意减掉&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARM嵌入式系统 学习笔记]]></title>
    <url>%2Fposts%2F2dcb219.html</url>
    <content type="text"><![CDATA[[TOC] 第1章 嵌入式系统概述 嵌入式系统定义：嵌入到对象体系中的专用计算机应用系统。 应用举例：手机、MP3、打印机、DV等。 嵌入式系统 分类 ①嵌入式微处理器（EMPU，基础是CPU，应用于专门设计的电路板上，满足嵌入式应用的特殊要求，在其工作温度、抗电磁干扰、可靠性等方面做了增强） ②微控制器（MCU，整个计算机系统集成到一块芯片中，适用于控制） ③DSP处理器（DSP，应用目标是大批量的消费类产品） ④片上系统（SOC，分通用和专用，专用芯片可用于互联网安全方面） 特点：嵌入性、专用性、计算机 嵌入式处理器：为了完成特殊的应用而设计的特殊目的处理器。 嵌入式最小系统：提供嵌入式处理器运行所必须的条件的电路与嵌入式处理器共同组成的系统。 嵌入式系统基本概念： 实时操作系统（RTOS）：一段在嵌入式系统启动后首先执行的背景程序，用户的应用程序是运行于RTOS之上的各个任务，RTOS根据各个任务的要求，进行资源管理、消息管理、任务调度及异常处理等工作。 资源：程序运行时可使用的软、硬件环境。 共享资源：被一个以上任务使用的资源。 任务：一个线程。 任务切换：保存当前运行任务的工作状态并入栈，把下一个要运行任务的当前状态从栈中装回CPU寄存器并开始运行。 内核：负责管理各个任务，提供任务切换的基本服务。 非占先式内核：中断后回到中断了的任务。 占先式内核：中断后让进入就绪态优先级最高的开始运行。 任务优先级：表示任务被调度的优先程度。 中断：一种硬件机制，用于通知CPU有个异步事件发生了。 常见嵌入式实时操作系统 μClinux：开源 Windows CE：开放 VxWorks：实时性卓越 μC/OS - ΙΙ：开源、抢占式 第2章 ARM7体系结构 ARM简介 ARM公司是一家知识产权(IP)供应商，它与一般的半导体公司最大的不同就是不制造芯片且不向终端用户出售芯片，而是通过转让设计方案，由合作伙伴生产出各具特色的芯片。 ARM架构是ARM公司面向市场设计的第一款低成本RISC微处理器。 ARM7后缀含义： 带M：64位乘法指令 带D：支持片上调试 带T：高密度16位Thumb指令集扩展 带I：Embedded ICE硬件仿真功能模块 ARM处理器使用冯·诺依曼结构，指令数据共用一条32位总线；直接支持8位字节(2^32)，16位半字(2^31)或者32位字(2^30)的数据类型。 如果一个数据是以字方式存储的，那么它就是字对齐的，否则就是非字对齐的；特征：bit0=bit1=0,其他任意。 如果一个数据是以半字方式存储的，那么它就是半字对齐的，否则就是非半字对齐的；特征：bit0=0,其他任意。 流水线 三级：①取指：从存储器装载一条指令 ②译码：识别将要执行的指令 ③执行：处理指令并将结果写回寄存器 ARM处理器状态 ARM指令集为32位长度，效率高，代码密度低，都是有条件执行，具有最完整的功能；Thumb指令集为16位长度，代码密度较高，只有一条具备有条件执行，能实现ARM指令集的大部分功能。在功能上可以认为Thumb是ARM的子集。 当前程序状态寄存器CPSR中的控制位T反映处理器正在操作的状态，T=0，处理器处于ARM状态，T=1，处理器处于Thumb状态。 从一个ARM例程调用另一个Thumb例程时，内核必须切换状态，反之亦然。BX分支将ARM内核的操作状态在ARM和Thumb之间进行切换。 &nbsp;&nbsp;&nbsp;&nbsp;7. ARM处理器模式 除了用户模式以外，其余所有6种模式称之为非用户模式 特权模式中除去系统模式外的5种模式称之为异常模式 用户(usr)、系统(sys)、管理(svc)、中止(abt)、未定义(und)、中断(irq)、快速中断(fiq) &nbsp;&nbsp;&nbsp;&nbsp;8. ARM内部寄存器 ARM处理器内部共有37个用户可访问的32位寄存器，其中有6个32位状态寄存器目前只使用了其中12位；31个通用寄存器+6个状态寄存器(1个CPSR+5个SPSR)；不可同时访问，对其访问取决于处理器状态和处理器模式。 堆栈指针R13(SP)，保存堆栈的出入口地址、待使用寄存器内容 链接寄存器R14(LR)，保存子程序和子程序的返回地址 程序计数器R15(PC)，总是指向“正在取指”的指令 所有模式共享一个程序状态寄存器CPSR，ARM通过此寄存器监视和控制内部操作的。SPSR为异常模式中保存CPSR当前值的备份程序寄存器。 程序状态寄存器格式 N Z C V … I F T M4 M3 M2 M1 M0 负 0 进位 溢出 保留 irq禁止 fiq禁止 状态位 模式位 . . . . &nbsp;&nbsp;&nbsp;&nbsp;9. 模式控制位 M[4:0] 模式 10000 用户 10001 快速中断 10010 中断 10011 管理 10111 中止 11011 未定义 11111 系统 &nbsp;&nbsp;&nbsp;&nbsp;10. 异常向量表 地址 异常 模式 0x0000 0000 复位 管理 0x0000 0004 未定义指令 未定义 0x0000 0008 软件中断 管理 0x0000 000C 中止（预取） 中止 0x0000 0010 中止（数据） 中止 0x0000 0014 保留 保留 0x0000 0018 IRQ 中断 0x0000 001C FIQ 快速中断 &nbsp;&nbsp;&nbsp;&nbsp;11. 中断优先级 优先级 异常 1 复位 2 数据中止 3 FIQ 4 IRQ 5 预取指中止 6 未定义指令 6 软件中断SWI &nbsp;&nbsp;&nbsp;&nbsp;12. ARM体系的储存系统 &nbsp;&nbsp;&nbsp;&nbsp;位于地址A的字包含的字节位于A、A+1、A+2、A+3； 小端格式：一个字中的最低地址被看作是最低位字节，最高地址的字节被看作是最高位字节，储存器系统字节0连接到数据线7~0； 大端格式：一个字中的最高位字节保存在最低地址，最低位字节保存在最高位地址，储存器系统字节0连接到数据线31~24； 第3章 ARM7TDMI（-S）指令系统 ARM处理器寻址方式 寄存器寻址： 寄存器编号 MOV R1,R2 ；将R2的值存入R1 SUB R0,R1,R2；将R1的值减R2的值结果存入R0 立即寻址： 操作数 SUBS R0,R0,#1；R0-1存入R0 MOV R0,#0xFF000；将立即数0xFF000装入R0 寄存器移位寻址： ASR(1-32)、LSL(1-31)、LSR(1-32)、ROR(1-31)、RRX(1) MOV R0,R2,LSL #3 ；R2的值左移3位结果存入R0 ANDS R1,R1,R2,LSL R3 ；R2的值左移R3位，结果与R1相与后存入R1 寄存器间接寻址： [] LDR R1,[R2] ；将R2指向的储存单元的数据读出存入R1 //加载字数据 SWP R1,R1,[R2]；将R2指向的储存单元的数据与R1的值交换 基址寻址 STR R1,[R0,#-4]！；将R1的值存入R0-4指定的储存单元 //存储字数据 多寄存器寻址：！，{ } LDMIA R1!,{R2-R7,R12}；将R1指向的单元中的数据读出到R2-R7,R12中，R1++；//多寄存器加载 STMIA R0!,{R2-R7,R12}；将R2-R7,R12的值保存到R0指向的存储单元中，R0++; //多寄存器存储 堆栈寻址 满堆栈：指向最后压入栈的有效数据项，向移动指针再写数据； 空堆栈：指向下一个待压入数据的空位置，先写入数据在移动指针； X递增：增大地址向上增长；X递减：减小地址向下增长。 相对寻址 程序计数器PC提供基准地址，地址码字段作为偏移量 第4章 LPC2000系列ARM硬件结构 为存储器分配地址的过程称为存储器映射；但为了增加系统的灵活性，系统中有部分存储单元（主要包括引导块(Boot Block)和用于保存向量表的少量存储单元）可以同时出现在不同地址上，则称为存储器重映射。 存储器重映射并不是对映射单元的内容进行了复制，只是将多个地址指向了同一个存储单元，通过“存储器管理部件”实现。即一个物理地址对应多个逻辑地址。 Boot Block是芯片设计厂家在LPC2000系列ARM内部固化的一段代码，用户无法对其修改或删除。这段代码在芯片复位后被首先运行，其功能主要是判断运行哪个存储器上的程序，检查用户代码是否有效，判断芯片是否被加密，芯片的在应用编程(IAP)以及在系统编程功能(ISP)。 系统启动代码(Boot Loader)：大部分由汇编指令构成，可以实现向量表定义、堆栈初始化、系统变量初始化、中断系统初始化、I/O初始化、外围初始化、地址重映射等操作。启动顺序：Boot Block-&gt;Boot Loader-&gt;操作系统 时钟系统概述：时钟是计算机系统的脉搏，处理器核在一拍接一拍的时钟驱动下完成指令执行、状态变换等动作。外设部件在时钟的驱动下进行着各种工作，比如串口数据的收发、A/D转换、定时器计数等。因此时钟对于一个计算机系统是至关重要的，通常时钟系统出现问题也是最致命的，比如振荡器不起振、振荡不稳、停振等。组成：晶体振荡器、唤醒定时器、锁相环（PLL）和VPB分频器。 晶体振荡器的两个模式：使用外部时钟源时，称为“从属模式”；使用外部晶体时，称为“振荡模式”。 LPC2000系列ARM两个复位源： 外部复位：通过把芯片的$\overline{RESET}$引脚拉为低电平使芯片复位。$\overline{RESET}$引脚为施密特触发输入引脚，带有一个额外的干扰滤波器，可以滤除非常短促的脉冲信号，使处理器不会被干扰脉冲意外复位，或者被不稳定的复位信号复位多次。 $\overline{RESET}$需要保持一段时间的低电平，必须在晶振稳定运行之后才能撤除。 在系统编程(ISP)：是一种非常实用的片内Flash烧写方式。ISP工作时，通过UART0使用约定协议与计算机上的ISP软件进行通信，并按用户的操作要求，调用内部的IAP代码实现各种功能。 看门狗复位：内置看门狗部件，可以利用此部件来复位处理器。 锁相环PLL 作用：将振荡器产生的时钟频率$F_{OSC}$进行升频。 LPC2000系列ARM是基于ARM7内核的，该内核的工作频率基本在100Mhz以下，所以LPC2000系列ARM大部分支持最高60MHz的内核时钟，少部分支持70MHz的内核时钟。 PLL频率计算：$F_{OSC}$经流控振荡器CCO得到$F_{CCO}$，$F_{CCO}$经过2P分频后得$F_{CCLK}=F_{CCO}/(2*P)$，$F_{CCO}/(2*P)$经M分频后得到$F_{CCO}/(2*P*M) = F_{OSC}$ PLL设置 参考链接 $F_{CCO}$取值必须在156～320MHz内 M取值1-32，将M-1放在PLLCFG[4:0] P取值1,2,4,8，将$log_2P$放在PLLCFG[6:5] PLLCON寄存器:包涵使能连接PLL的位,也就是控制PLL是否进行连接,这个连接需要在向PLLFEED发送正确的信息(馈送序列)的时候才生效,否则及时将使能位置位,PLL也不会连接到电路中。PLLCON必须在PLL开始连接之前就设置好,否则会造成系统不可预知的错误,先设置1后设置3。 PLLSTAT寄存器:从里面可以读出PLLCON,PLLCFG的值,但必须是在PLLFEED的馈送序列被发送,PLLCON,PLLCFG生效以后才可以读到正确的值(while(PLLSTAT &amp; (1&lt;&lt;10) == 0) ;) PLLFEED寄存器:向此寄存器以连续的VPB总线周期写入0xaa,0x55,即馈送序列，在正确的序列被写入PLLFEED之后,PLLCON,PLLCFG才生效,PLL电路才能正确的连接到电路中 12345678PLLCON = 1;PLLCFG = (M-1)|（log2(P)&lt;&lt;5）;PLLFEED = 0xaa;PLLFEED = 0x55;while(PLLSTAT &amp; (1&lt;&lt;10) == 0);PLLCON = 3;PLLFEED = 0xaa;PLLFEED = 0x55; &nbsp;&nbsp;9. VPB分频器 作用：将$F_{CCLK}$分频，方便外设工作、降低系统功耗 &nbsp;&nbsp;10. 两种节电模式： 空闲模式：处理器停止执行指令，使功耗最低降至1～2mA电流 掉电模式：振荡器关闭，芯片没有任何内部时钟，功耗降低到几乎为零 &nbsp;&nbsp;11. bank0~bank3的片选信号分别是CS0~CS3。 &nbsp;&nbsp;12. 外部存储器接口 LPC2200的外部存储器宽度可设定为8位，16位和32位 宽度为8位时，有效数据线D7~D0，只有BLS0有效 宽度为16位时，有效数据线D15~D0，BLS0、BLS1都有效 操作16位存储器时，需将LPC2200的地址线A1连接到存储器地址A0处 &nbsp;&nbsp;13. PSRAM读写数据 写入16位 123456789int main(void)&#123; uint16 *point16; uint16 data16 = 0x00; point16 = (uint16 *)0x80001020; while(1)&#123; *point16 = data16++; //循环向地址0x80001020处写入数据 &#125; return 0;&#125; 写入低8位 123456789int main(void)&#123; uint8 *point8; uint8 data8 = 0x00; point8 = (uint8 *)0x80001010; while(1)&#123; *point8 = data8++;//循环向地址0x80001010处写入数据 &#125; return 0;&#125; 写入高8位 123456789int main(void)&#123; uint8 *point8; uint8 data8 = 0x00; point8 = (uint8 *)0x80001011; while(1)&#123; *point8 = data8++;//循环向地址0x80001011处写入数据 &#125; return 0;&#125; 读取8位 1234567891011121314uint8 RcvDate8;int main(void)&#123; uint8 *point8; point8 = (uint*)0x80001010; while(1)&#123; RcvDate8 = *point8++;//读取0x80001010处的数据 RcvDate8 = *point8++;//读取0x80001011处的数据 RcvDate8 = *point8++;//读取0x80001012处的数据 RcvDate8 = *point8--;//读取0x80001013处的数据 point8--; point8--; &#125; return 0;&#125; &nbsp;&nbsp;14. ARM的大部分引脚都具有多种功能，即引脚复用。但是一个引脚在同一时刻只能使用其中一个功能，通过配置相关寄存器控制多路开关与片内外设。 &nbsp;&nbsp;15. GPIO的特性 可以独立控制每个GPIO口的方向（输入/输出模式） 可以独立设置每个GPIO口的输出状态（高/低电平） 所有GPIO口在复位后默认为输入状态 &nbsp;&nbsp;16. GPIO应用示例 ​ 设置P0.0为输出高电平 123PINSEL0 &amp;= 0xFFFFFFFC; //设置引脚连接模块，将P0.0设置为GPIO功能IO0DIR |= 0x00000001; //将P0.0设置为输出IOSET = 0x00000001; //设置P0.0输出高电平 使用GPIO控制蜂鸣器 123456789101112#define BEEPCON 0x00000080 //P0.7控制B1，低电平蜂鸣int main(void)&#123; PINSEL0 = 0x00000000; //设置引脚连接GPIO IO0DIR = BEEPCON; //设置I/O为输出 while(1)&#123; IO0SET = BEEPCON; //BEEPCON=1 Delay(10); IO0CLR = BEEPCON; //BEEPCON=0 Delay(10); &#125; reuturn 0;&#125; 读取P0.0引脚的电平状态 1234uint32 PinStat; //定义存放I/O状态的变量PINSEL0 &amp;= 0xFFFFFFFC; //设置引脚连接模块，将P0.0设置为GPIO功能IO0DIR &amp;= 0xFFFFFFFE; //将P0.0设置为输入PinStat = IO0PIN&amp;0x01; //通过IP0PIN寄存器获取P0.0当前电平状态 读取按键状态 12345678910111213#define BEEPCON 0x00000080#define PIN_P014 0x00004000 //定义P0.14屏蔽字int main(void)&#123; uint32 i; PINSEL0 = 0x00000000; //设置引脚连接GPIO IO0DIR = BEEPCON; //设置B1控制口为输出，其他I/O为输入 while(1)&#123; if((IO0DIR&amp;PIN_P014)!=0) IO0SET = BEEPCON; else IO0CLR = BEEPCON; Delay(10); &#125; return 0;&#125; 在多个I/O口线上输出数据 12345#define DataBus 0xFFPINSEL0 &amp;= 0xFFFF0000；//设置引脚连接模块，将P0.0~P0.7设置为GPIO功能IO0DIR |= DataBus; //将所有I/O口设置为输出IO0CLR = DataBus; //将所有I/O口设置为低电平输出IO0SET = Data; //将输出的数据从I/O口输出 &nbsp;&nbsp;17. 中断分类 快速中断请求（FIQ）：优先级最高 向量IRQ：中等优先级，16个优先级，每个中断源分别设置服务程序入口 非向量IRQ：优先级最低，支持一个非向量中断，所有中断共用一个服务程序入口 &nbsp;&nbsp;18. VIC可以管理32路中断请求。 &nbsp;&nbsp;19. 中断触发方式 边沿触发：上升沿触发、下降沿触发 电平触发：高电平触发、低电平触发 &nbsp;&nbsp;20. 外部中断应用示例 EINT0低电平中断初始化 12345678PINSEL1 = (PINSEL1&amp;0xFFFFFFFC)|0x01; //选择P0.16为EINT0EXTMODE = EXTMODE&amp;0x0E; //电平触发EXTPOLAR = EXTPOLAR&amp;0x0E; //低电平中断/*设置向量中断控制器*/VICIntSelect = VICIntSelect&amp;(~(1&lt;&lt;14)); //EINT0分配为IRQ中断VICVectCntl0 = 0x20|14; //EINT分配为向量IRQ通道0VICVectAddr0 = (uint32)EINT0_ISR; //向量IRQ通道0的中断服务程序地址为EINT0_ISRVICIntEnable = (1&lt;&lt;14); //EINT0中断使能 EINT0下降沿中断初始化 123PINSEL1 = (PINSEL1&amp;0xFFFFFFFC)|0x01;EXTMODE = EXTMODE|0x01;EXTPOLAR = EXTPOLAR&amp;0x0E; &nbsp;&nbsp;21. SPI总线系统是一种同步串行外设接口，允许MCU与各种外围设备一串行方式进行通信、数据交换。 &nbsp;&nbsp;22. $I^2C$BUS是NXP半导体公司推出的芯片间串行传输总线，它以2根连线实现了完善的双向数据传送，可以极方便的构成多机系统和外围器件拓展系统。 &nbsp;&nbsp;23. LPC2000系列ARM7微控制器包含有2个符合16C550工业标准的异步串行口（UART）：UART0和UART1。其中UART0只提供TXD（发送）和RXD（接受）信号引脚，而UART1增加了一个调制解调器（Modem）接口。 &nbsp;&nbsp;24. UART应用示例 UART0初始化 12345678910#define UART_BPS 115200void UART0_Ini(void)&#123; uint16 Fdiv; U0LCR = 0x83; //DLAB=1,可设置波特率 Fdiv = (Fpclk/16)/UART_BPS; //设置波特率 U0DLM = Fdiv/256; //除数锁存高位寄存器 U0DLL = Fdiv%256; //除数锁存低位寄存器 U0LCR = 0x03;&#125; UART0查询方式接受数据 123456uint8 UART0_RcvByte(void)&#123; uint8 rcv_data; while((U0LSR&amp;0x01)==0); //状态 rcv_data = U0RBR; //接受缓存 return rcv_data;&#125; UART0中断方式接受数据 12345678910111213141516171819void __irq UART_Exception(void)&#123; ... switch(U0IIR&amp;0x0f)&#123; case 0x04: //发生RDA中断 //从接受FIFO中读取数据 break; case 0x0c: //发生字符超时中断——CTI while((U0LSR&amp;0x01)==1)&#123; //如果接受FIFO中含有的有效数据，就读取UnRBR寄存器 RcvData[i++]=U0RBR; &#125; break; ... default: break; &#125; VICVectAddr = 0;&#125; &nbsp;&nbsp;25. 看门狗 带内部预分频器的可编程32位定时器]]></content>
      <categories>
        <category>专业课程</category>
      </categories>
      <tags>
        <tag>嵌入式系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法设计与分析 学习笔记]]></title>
    <url>%2Fposts%2Fecab3815.html</url>
    <content type="text"><![CDATA[第一章 算法概述算法的定义：是对特定问题求解步骤的一种描述，包含操作的有限规则和操作的有限序列 算法的性质：确定性（指令无歧义）、有限性（无死循环）、输入、输出 程序的定义：是算法用某种程序设计语言的具体实现 程序和算法的区别：程序不一定满足有限性，比如操作系统 算法复杂性决定于：(1)求解问题的规模；(2)具体的输入数据；(3)算法本身的设计 O(1)&lt;O(logn)&lt;O(n)&lt;O($n^c$)&lt;O($c^n$)&lt;O(n!) 如果存在正的常数c和自然数n0，使得n&gt;=n0时有f(n)&lt;=cg(n)，则称f(n)当n充分大时有上界，且g(n)是它的一个上界，记为f(n)=O(g(n))，还说f(n)的阶不高于f(n)的阶。 求上下界函数： \lim_{n\rightarrow\infty} \frac{f(n)}{g(n)} = \begin{cases}0, & \text{f(n)=O(g(n))}\\\infty, & \text{f(n)= $\Omega$(g(n))}\\c,& \text{f(n)=$\Theta$(g(n))} \end{cases}第二章 递归与分治一般递归方程时间复杂度分析 T(n)1} \end{cases}其中，a是子问题的个数，b是递减的步长，|表示递减方式，D(n)是合成子问题的开销 当|为减法： T(n)1}\\ O(n),&\text{a=1} \end{cases}当|为除法： $p=log_ba$ ①D(n)为常数 T(n)1}\\ O(log_bn),&\text{a=1} \end{cases}②D(n)为线性函数cn T(n)]]></content>
      <categories>
        <category>专业课程</category>
      </categories>
      <tags>
        <tag>算法设计与分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物联网概论 学习笔记]]></title>
    <url>%2Fposts%2F2887108d.html</url>
    <content type="text"><![CDATA[物联网（IoT）：Internet of Things 物联网是具有自我标示、感知和智能的物理实体基于通信技术相互连接形成的网络，这些物理设备可以在无需人工干预的条件下实现协同和互动，为人们提供智慧和集约的服务，传感网是物联网的基础，是物联网的组成部分 物联网三层体系结构：感知层、网络层和应用层 感知层是物联网的皮肤和五官——识别物体，采集信息； 网络层是物联网的神经中枢和大脑——信息传递和处理； 应用层是物联网的“社会分工”——与行业需求结合，实现广泛智能化 RFID全称：Radio Frequency Identification 射频识别 RFID系统的基本组成： ①硬件组成：RFID标签、识读器、天线和主机 ②软件组成：RFID系统软件、中间件和应用软件 RFID系统结构通过空中接口将电子标签与读写器连接 RFID系统的原理： ①耦合(Coupling)：根据需求和成本可利用电磁波和磁感应 ②磁耦合 ③电磁波耦合(反向散射原理) RFID频段分布 低频：125.124KHz 恶劣环境下使用 高频：13.56MHz 门禁卡、公交卡等 （ISO/IEC 14443标准 非接触集成电路接近卡） 超高频：433.92Mhz / 868-960Mhz 微波：2.45GHz 一般传感器的定义：测量装置、输入与输出有对应关系、有一定的精确度 一般传感器的组成： ①敏感元件：直接感受被测量、并输出与被测量成确定关系的某一物理量的元件 ②转换元件：敏感元件的输出就是它的输入，将感受到的非电量直接转换为电量的元件 ③测量电路：将转换元件输出的电量变换为便于显示、记录、控制、处理的有用电信号 传感器的静态特性： ①线性度：指其输出量与输入量之间的实际关系曲线(即静态特征曲线)偏离直线的程度，又称为非线性误差 ②灵敏度：指传感器在稳态下的输出变化量△y与引起变化的输入变化△x之比 ③迟滞：传感器在正(输入量增大)和反(输入量减小)行程期间，其输出-输入特性曲线不重合的现象 ④重复性：在输入按同一方向连续多次变动时得到特性曲线不一致的程度 ⑤分辨率：在测量方向内所能测量输入量的最小变化量△x ⑥漂移：在外界的干扰下，输出量发生与输入量无关的变化 应变效应：金属导体或者半导体在受外力作用时，会产生相应的应变，其阻值也随之发生变化 。 应变片式传感器——电桥 ①直流电桥（单臂电桥、惠斯通电桥）：$K_{u} = U/4$ ②半差动电桥(双臂电桥)：$K_{u} = U/2$ ③全桥电路（全臂电桥）：$K_{u} = U$ 变磁阻式(自感)传感器： 电感：在电路中电流发生变化时能产生电动势的性质成为电感，分为自感和互感 自感：当线圈中有电流通过时，线圈的周围就会产生磁场。当线圈中电流发生变化时，其周围的磁场也产生相应的变化，此变化的磁场可使线圈自身产生感应电动势。 互感：两个电感线圈相互靠近时，一个电感线圈的磁场变化将影响另一个电感线圈，这种影响就是互感。互感的大小取决于电感线圈的自感与两个电感线圈耦合的程度 。 应用范畴：微位移 分类： 变气隙式 &nbsp;&nbsp;工作原理：气隙厚度的改变，使得磁路中磁阻值变化，从而导致电路电感值变化 变截面式 螺管式 电容式传感器：$c_0 = \frac{\epsilon_0\epsilon_rS}{d_0}$ 分类：①变极距型②变面积型③变介质型（油箱测油位） 应用：手机指纹识别 ps:实验箱指纹识别模块使用的是光电式传感器 磁电式传感器-霍尔传感器 霍尔效应：置于磁场中的静止载流导体, 当它的电流方向与磁场方向不一致时, 载流导体上垂直于电流和磁场方向产生电动势。该电势称霍尔电势。 霍尔电势与控制电流和磁感应强度成正比 霍尔电势的灵敏度与霍尔常数RH正比而与霍尔片厚度成反比 应用：微位移、测转速(汽车轮胎)、测电流、计数、开关等 压电式传感器 压电效应：某些电介质,当沿着一定方向对其施力而使它变形时,其内部就产生极化现象,同时在它的两个表面上便产生符号相反的电荷,当外力去掉后,其又重新恢复到不带电状态。 Z为光轴，X为电轴，Y为机械轴 压电效应称为纵向压电效应，沿Y方向产生的为横向压电效应，沿Z轴不产生 侧压力时线性度不好，需要在力传递系统中加入预加力，称预载 光电式传感器 光电效应：光的频率越高，其光子能量就越大。当具有一定能量的光子作用到某些物体上转化为该物体中一些电子的能量而产生电效应。 分类： 外光电效应（光线照到某些物体上造成表面电子逸出的现象） 光电导效应、光生伏特效应(内光电效应) （物体受光照后，内部原子释放出电子不能逸出表面，使物体电阻率发生变化或产生光电动势的现象） 光电倍增管：对光电流放大以提高灵敏度,阳极最后收集到的电子数是阴极发射的$10^5～10^6$倍 应用：亮度传感器、烟雾报警器、光电鼠标等 无线传感器 定义：是大量的静止或移动的传感器以自组织和多跳的方式构成的无线网络，目的是协作地采集、处理、传输网络覆盖地域内感知对象的检测信息，并报告用户。 传感器节点 -&gt; 汇聚节点 -&gt; 管理节点 网络节点组成：传感模块—计算模块—通信模块——存储模块 无线传感网：WSN(Wireless sensor network) 电池供电，能量有限（耗能排序：发送&gt;接受&gt;空闲&gt;睡眠 短距离通讯（距离增加一倍，功耗增加三倍 节点生命周期 自适应网络 路由的性质： 路由策略分析：最大PA、最小能量消耗、最少跳转、最大最小PA节点 定向扩散路由：①兴趣扩散（洪泛方式）②梯度建立③加强路径 GPSR绕过路由空洞的步骤： 构造全网连接平面图 通过删边处理，变成可平面图（GG、RNG算法 通过右手法则，绕过路由空洞（每经过一个面，顺时针到的第一条边 MAC协议： 分类：时分复用无竞争接入方式(分配型）、随机竞争接入方式（竞争型）、竞争与固定分配相结合的接入方式（混合型） S-MAC协议： 优点： 周期性的侦听/睡眠的低占空比方式 虚拟簇的调度方式 自适应流量的侦听机制：通信结束继续侦听一段时间 串音避免：RTS/CTS/DATA/ACK 缺点：延迟受限于帧长度，不适合实时业务 分配性MAC协议： “隐藏终端”（Hidden Stations）：在通信领域，基站A向基站B发送信息，基站C未侦测到A也向B发送，故A和C同时将信号发送至B，引起信号冲突，最终导致发送至B的信号都丢失了。 暴露终端是指在发送节点的覆盖范围内而在接收节点的覆盖范围外的节点，暴露终端因听到发送节点的发送而可能延迟发送。但是，它其实是在接收节点的通信范围之外，它的发送不会造成冲突。这就引入了不必要的延时。 ZigBee 功能节点：协调者（COORDINATOR）、路由器（ROUTER）、终端设备（END DEVICE） 协调者（老大）功能：发送网络信标、建立一个PAN、管理网络节点、存储网络节点信息、寻找节点对路由信息 路由器功能：允许其它设备加入网络、跳跃路由、辅助子设备供电 终端设备功能：传感节点的载体、轻载化程序设计 网络拓扑结构：星型、网型、树形 模式：非信标模式（CSMA/CA）、信标模式（竞争和分配的混合性信道接入） CSMA/CA方式下通过三个参数的调节来实现冲突避免：退避次数（NB)、竞争窗口长度（CW)、退避指数（BE） 信标、超帧及其结构： 超帧包含活动部分和非活动部分，超帧以一个信标的开始为开始，信标定义超帧结构 CAP为自由竞争阶段、CFP为非竞争阶段、CFP内可以保证GTS（保证时隙）的传送 信标是子设备同步父设备的标记 耗能：传感模块的功耗远高于射频模块的功耗，这是因为传感模块大多采用模拟电路进行感测，需要一直恒定的加载电流。]]></content>
      <categories>
        <category>专业课程</category>
      </categories>
      <tags>
        <tag>物联网概论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率论与数理统计 学习笔记]]></title>
    <url>%2Fposts%2F8acb8928.html</url>
    <content type="text"><![CDATA[第一章 随机事件及其概率第一节 随机事件及其频率、概率的统计定义随机事件(偶然事件)：在试验的结果中，可能发生、也可能不发生的事件 随机事件的频率具有一定的稳定性 随机事件的概率为频率的近似值 $P(A) \approx f(A) = \frac{m}{n}$ 必然事件 P(U)=1；不可能事件 P(V)=0 第二节 样本空间样本点：随机试验的每一个可能出现的且是最简单的不可再分的结果 样本空间：所有的样本点构成的集合（分为可列个和不可列个(如误差范围)） 任一随机事件A都是样本空间Ω的一个子集 第三节 事件的关系及运算包含/包含于：$A \subset B$ 和(并)：$A∪B$ 积(交)：$A∩B 或 AB$ 互不相容(互斥)：两个互不相容事件的和 $A+B$ 对立(逆)：$\overline{A}=B$ 完备事件组：n个事件至少有一个事件一定发生 A发生但B不发生：$A-B=A\overline{B}=A-AB$ 运算性质：交换律、结合律、分配律、德摩根律（$\overline{A∪B}=\overline{A}&ensp;\overline{B},\overline{AB}=\overline{A}∪\overline{B}$） 第四节 概率的古典定义乘法定理：完成一件事需r步，第i步有$ m_ i $种方法，完成这件事总方法数 $ m_ 1m_ 2…m_ r $ 加法定理：完成一件事有r类方法，第i类有$ m_ i $种方法，完成这件事总方法数 $ m_ 1+m_ 2+…+m_ r $ 排列：$ A _ n ^m = \frac{n!}{(n-m)!} $ 组合：$ C _ n ^m = \frac{A _ n ^m}{P_ m} = \frac{n!}{(n-m)!m!}$ 概率的古典定义：试验样本总共有$ n_Ω$ 个等可能的基本事件，其中随机事件A包含$ n_A$个基本事件，($ n_A$&lt;=$ n_Ω$)，则 $P(A) = \frac{n_A}{n_Ω}$ 不放回依次抽样与一次抽样的一致性、抽签次序无关性 第五节 概率加法定理若随机事件A与B互斥，即$AB = \emptyset，则P(A+B)= P(A)+P(B) \Rightarrow P(A)+P(\overline{A})=1$ 若A、B是任意的两个随机事件，则二者和事件的概率为 $P(A∪B)=P(A)+P(B)-P(AB)$ $\Rightarrow P(A∪B∪C)=P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC) $ 第六节 条件概率与乘法定理已知事件A发生的条件下，事件B发生的概率：$P(B|A)=\frac{P(AB)}{P(A)}$ 若$P(A_1A_2…A_{n-1})&gt;0,则 P(A_1A_2…A_{n})=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1A_2…A_n-1)$ 第七节 全概率公式与贝叶斯公式&ensp;&ensp;先验，由因溯果 P(A) = \sum_{i=1}^nP(B_i)P(A|B_i) &ensp;&ensp;后验，由果溯因 P(B_i|A) = \frac{P(AB_i)}{P(A)} = \frac{P(B_i)P(A|B_i)}{\sum_{i=1}^nP(B_i)P(A|B_i)},i=1,2,...,n第八节 随机事件的独立性若两事件A与B满足$P(AB) = P(A)P(B)$，则称事件A与B相互独立 &ensp;&ensp;性质1：不可能事件及必然事件与任意的随机事件相互独立 &ensp;&ensp;性质2：A与B相互独立，则A与$\overline{B},\overline{A}与B,\overline{A}与\overline{B}$也相互独立&ensp;&ensp;（相互对称性） 第九节 贝努力概型事件A恰好发生k次的概率：$P_n(k) = C_n^kp^kq^{n-k},k=0,1,2,…,n$ $\sum_{k=0}^nP_n(k) = \sum_{k=0}^nC_n^kp^kq^{n-k} = (p+q)^n = 1$ 事件A发生次数介于$m_1$与$m_2$之间：$P_n(m_1 \leq k \leq m_2) = \sum_{k=m1}^{m2}P_n(k)$ 事件A至少发生r次：$P(k \geq r) = \sum_{k=r}^nP_n(k) = 1 - \sum_{k=0}^{r-1}P_n(k)$ 第十节 概率论的公理化体系非负性：P(A) $\leq$ 0; 规范性：P(Ω)=1; 可列可加性(可数可加性)：$A_1,A_2,…$ 两两互不相容，则$P(\sum_{i=1}^\infty A_i) = \sum_{i=1}^\infty P(A_i)$ 第二章 随机变量及其分布第一节 随机变量的概念设Ω为随机变量的样本空间，如果对每一个样本点$\omega \in Ω$，均有唯一确定的实数X($\omega$)与之对应，即存在一个定义于Ω的单值实函数X=X($\omega$)，则称X=X($\omega$)为样本空间Ω上的随机变量 第二节 离散型随机变量的概率分布性质： ①$p_k \geq 0 (k=1,2,..) $ ②$\sum_{k=1}^{\infty}p_k = 1$ 第三节 几种常用的离散型随机变量的分布 0-1分布：$P(X=1) = p，P(X=0) = q（0&lt;p&lt;1，p+q=1）$ 超几何分布：$P(X=m) = \frac{C_M^mC_{N-M}^{n-m}}{C_N^n} （n \leq N,M \leq N），记作X～H(n,M,N)$，N趋向无穷大时近似服从二项分布 二项分布：$P(X=k) = C_n^kp^kq^{n-k} （k=0,1,2,…,n） ，记作X ～B(n,p)$ ，n很大，p很小时，可用泊松分布近似替代二项分布 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;二项式分布的最可能取值( P(X=k)取得最大值的k )： &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;①若(n+1)p不是整数，则其整数部分[(n+1)p]即为所求； &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;②若(n+1)p=m是整数，则m和m-1即为所求 泊松分布：$P(X=k) = P_{\lambda}(k) = \frac{\lambda^k}{k!}e^{-\lambda} （k=0,1,2,…），记作X～P(\lambda)$ 几何分布：$P(X=k)=q^{k-1}p（k=1,2,…）， 记作X～G(p)$ 第四节 随机变量的分布函数$F(x) = P(X \leq x)$ 性质： $F(x) 单调不减，若x_1&lt;x_2,则F(x_1) \leq F(x_2)$ 对于任意x，P(x)=F(x)-F(x-0),即当前值-左极限值 $P(x_1&lt;X \leq x_2) = F(x_2)-F(x_1)$离散型随机变量只能用 $P(x_1 \leq X \leq x_2) =P(x_1&lt;X \leq x_2)=P(x_1 \leq X&lt;x_2)=P(x_1&lt;X&lt;x_2) =F(x_2)-F(x_1)$连续性随机变量都适用 离散型随机变量的F(x)含跳跃间断点；连续性随机变量F(x)连续且位于y=0与y=1之间 第五节 连续性随机变量的概率密度 分布函数F(x)与概率密度函数f(x)的关系： $f(x) = F^{′}(x) $ $F(x)=\int_{-\infty}^xf(t)dt$ 性质： $因为F(-\infty)=0,F(+\infty)=1,所以有\int_{-\infty}^{+\infty}f(x)dx = 1$ $P(x_1&lt;X \leq x_2)=F(x_2)-F(x_1)=\int_{x_1}^{x_2}f(x)dx$ 第六节 几种常用的连续随机变量的分布均匀分布 X~U(a,b) f(x)=\begin{cases} \frac{1}{b-a},&\text{a]]></content>
      <categories>
        <category>专业课程</category>
      </categories>
      <tags>
        <tag>概率论与数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EOJ Monthly 2019.2]]></title>
    <url>%2Fposts%2Fec536e41.html</url>
    <content type="text"><![CDATA[原题链接：https://acm.ecnu.edu.cn/contest/140/ A,B,C,E To be continue… D 进制转换 题意：求[l,r]中所有数的k进制末尾恰好有m个零的数有多少个 思路： x在k进制下末尾恰好有m个零说明x%(k^m)恒等于0，而x%(k^(m+1))不恒等于0，而x%(k^m)==0的情况包含了x%(k^(m+1))==0的情况，所以由容斥定理有[1,x]中满足题意的数有 x/(k^m) - x/(k^(m+1)) 个 代码： 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;ll calc(ll k,ll m,ll x)&#123; for(int i=1;i&lt;=m;i++)&#123; x/=k; &#125; return x;&#125;int main()&#123; ll l,r,k,m; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%lld%lld%lld%lld",&amp;l,&amp;r,&amp;k,&amp;m); printf("%lld\n",calc(k,m,r)-calc(k,m+1,r)-calc(k,m,l-1)+calc(k,m+1,l-1)); &#125;&#125; F 方差 题意： 在n个数中选m个数，使得这m个数的方差*(m^2)最小 思路： 首先想到要使方差越小，则要这m个数与平均数的差距越小，所以我们可以先排序再尺取m长; 不难发现将方差公式乘以m^2后可以化简得到 m(a_1^2+a_2^2+⋯+a_m^2) − (a_1+a_2+⋯+a_m)^2（MathJax真好用，小声哔哔 然后维护一个前缀和与一个前缀平方和即可 代码： 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;int a[maxn];ll sum1[maxn],sum2[maxn];int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; sort(a+1,a+1+n); for(int i=1;i&lt;=n;i++)&#123; sum1[i]=sum1[i-1]+a[i]; sum2[i]=sum2[i-1]+a[i]*a[i]; &#125; ll ans=-1; for(int i=m;i&lt;=n;i++)&#123; ll tmp=m*(sum2[i]-sum2[i-m])-(sum1[i]-sum1[i-m])*(sum1[i]-sum1[i-m]); if(ans==-1||ans&gt;tmp) ans=tmp; &#125; printf("%lld\n",ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSU 1803--2016]]></title>
    <url>%2Fposts%2F81348f2b.html</url>
    <content type="text"><![CDATA[题意： 求[l,r]之间有多少种a*b=2016的组合。 思路： 首先2016的1倍情况下有1*2016 , 2*1008 , 3*637… 等情况，2倍情况就是把a或b扩大2倍就行，那么我们可以把a看做[1,2016]的数，a’ 看做[2017,4032]的数，这样每次跨2016个数就知道有多少倍数了。最后两层for循环找出i*j==2016的时候把对应的倍数种类乘起来加到答案就行了。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; int main()&#123; ll n,m; ll a[3000],b[3000]; //a[i]储存n有多少个i*2016&lt;=n，b[i]....m while(~scanf("%lld%lld",&amp;n,&amp;m)) &#123; ll k=n/2016; //有k个2016跨度 ll mm=n%2016; //余下的等下都要+1 for(int i=1;i&lt;=mm;i++) a[i]=k+1; for(int i=mm+1;i&lt;=2016;i++) a[i]=k; k=m/2016; mm=m%2016; for(int i=1;i&lt;=mm;i++) b[i]=k+1; for(int i=mm+1;i&lt;=2016;i++) b[i]=k; ll ans=0; for(int i=1;i&lt;=2016;i++) &#123; for(int j=1;j&lt;=2016;j++) &#123; if((i*j)%2016==0) &#123; ans+=(a[i]*b[j]); &#125; &#125; &#125; printf("%lld\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 4011--Happy-Sequence]]></title>
    <url>%2Fposts%2Fundefined.html</url>
    <content type="text"><![CDATA[题意： 给一个n和m，求所有组成m长且值在1-n内且满足 a[i]%a[i-1]==0 的序列方案数。 思路： dp[i] [j] 表示长度为 i 的序列的最后一位为 j ,转移方程：dp[i] [j]=0 , dp[i] [j]+=dp[i-1] [ j的因子 ] 。因子可以通过埃氏筛打表得到，dp[m] [i]累加和即为答案，预处理2000*2000以内所有答案即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std; #define N 2005#define mod 1000000007int dp[N][N];vector&lt;int&gt;y[N]; //储存因子int main()&#123; for(int i=1; i&lt;=N; i++) &#123; for(int j=i; j&lt;=N; j+=i) &#123; y[j].push_back(i); &#125; &#125; for(int i=1; i&lt;=N; i++) dp[1][i]=1; for(int i=2; i&lt;=N; i++) &#123; for(int j=1; j&lt;=N; j++) &#123; for(int k=0; k&lt;y[j].size(); k++) &#123; dp[i][j]=(dp[i][j]+dp[i-1][y[j][k]])%mod; &#125; &#125; &#125; int t; scanf("%d",&amp;t); while(t--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); int ans=0; for(int i=1; i&lt;=n; i++) ans=(ans+dp[m][i])%mod; printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 2594--Driving-Straight]]></title>
    <url>%2Fposts%2Fae8e5760.html</url>
    <content type="text"><![CDATA[题意： 给出一个(2*m-1)*(2*n-1)的图，要求输出从左下角走到右上角最短距离走法的路径，只能在 ‘-’ 或 ‘|’ 上移动，答案保证有解，有多解输出任一，n,m&lt;=400。 思路： 因为题目要求输出路径，而bfs中如果每个状态都记录到当前状态的路径，可能会TLE或者MLE。 所以考虑先从终点开始bfs出每个点到终点的最短距离，然后再从起点出发bfs一直找 当前点的最短距离-1==下一步的最短距离 的位置就可以回到终点，注意方向的变换。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;using namespace std;char mp[1005][1005];int dis[1005][1005];int m,n;int dx[10]=&#123;-1,0,1,0&#125;; //反向由北到西顺时针 依次为0123int dy[10]=&#123;0,1,0,-1&#125;;int dd[10][10] = &#123;&#123;0, 1, 2, 3&#125;, // F&#123;3, 0, 1, 2&#125;, // L&#123;1, 2, 3, 0&#125; // R&#125;;char dir[10]=&#123;'F','L','R'&#125;; struct node&#123; int x,y; node()&#123;&#125; node(int x,int y):x(x),y(y)&#123;&#125;&#125;; void bfs()&#123; queue&lt;node&gt;q; memset(dis,-1,sizeof(dis)); dis[1][2*n-1]=0; q.push(node(1,2*n-1)); node now; int x,y,px,py; while(!q.empty()) &#123; now=q.front(); q.pop(); px=now.x,py=now.y; //printf("%d %d\n",px,py); for(int i=0;i&lt;4;i++) &#123; x=px+dx[i]; y=py+dy[i]; if(mp[x][y]=='-' || mp[x][y]=='|') &#123; x+=dx[i]; y+=dy[i]; if(dis[x][y]==-1) &#123; dis[x][y]=dis[px][py]+1; q.push(node(x,y)); &#125; &#125; &#125; &#125;&#125; void print()&#123; int statu,x,y,px,py; if(mp[2*m-1][2]=='-' &amp;&amp; dis[2*m-1][1]-1==dis[2*m-1][3]) &#123; puts("E"); px=2*m-1,py=3; statu=1; &#125; else if(mp[2*m-2][1]=='|' &amp;&amp; dis[2*m-1][1]-1==dis[2*m-3][1]) &#123; puts("N"); px=2*m-3,py=1; statu=0; &#125; while(1) &#123; if(dis[px][py]==0) &#123; puts(""); break; &#125; for(int i=0;i&lt;3;i++) &#123; x=px+dx[dd[i][statu]]; y=py+dy[dd[i][statu]]; if(mp[x][y]=='-' || mp[x][y]=='|') &#123; x+=dx[dd[i][statu]]; y+=dy[dd[i][statu]]; if(dis[x][y]==dis[px][py]-1) &#123; printf("%c",dir[i]); statu=dd[i][statu]; px=x,py=y; break; &#125; &#125; &#125; &#125;&#125; int main()&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;m,&amp;n); memset(mp,' ',sizeof(mp)); getchar(); for(int i=1; i&lt;=2*m-1; i++) &#123; gets(mp[i]+1); &#125; bfs(); /*for(int i=1;i&lt;=2*m-1;i+=2) &#123; for(int j=1;j&lt;=2*n-1;j+=2) &#123; printf("%3d",dis[i][j]); &#125;puts(""); &#125;*/ print(); if(T) puts(""); &#125;&#125; /*24 4+-+-+-+|+-+-+-+ |+-+-+-+|+-+-+-+NRFFLLFFRRFF4 4+-+ +-+| | |+ +-+-+| | |+-+-+-+| |+-+-+-+EFFLFF*/]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 110D--Lucky Probability]]></title>
    <url>%2Fposts%2Fcd41c611.html</url>
    <content type="text"><![CDATA[题意： 出个两个（P,V）范围在1e9的正整数区间，分别从其中随机选出一个数，选出的两个数作为一个新区间的左右端点。要求新区间内的幸运数刚好为k个的概率（幸运数指一个数的数位只有4或7）。 思路： 首先可以dfs找出所有在数据范围内的幸运数，记为L数组，因为数目不多，便可成k段遍历 L数组，每次分别计算【 L[i-1]+1，L[i]】与【Pl，Pr】的线段交集，和【 L[i+k-1]，L[i+k]-1】与【Vl，Vr】的线段交集，将两个结果相乘即是符合[i,i+k-1]区间幸运数的可能情况，同样的还要对P,V两个区间交换后在计算一遍，概率=所有可能情况/(Pr-Pl+1)/(Vr-Vl+1);然后还要注意k==1的情况会重复计算，需特判。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll L[1050];int num=0;void dfs(int len,int p,int v)&#123; if(p==len) &#123; L[++num]=v; return; &#125; dfs(len,p+1,v*10+4); dfs(len,p+1,v*10+7);&#125; ll contain(ll x1,ll y1,ll x2,ll y2)&#123; ll l=max(x1,x2); ll r=min(y1,y2); return r-l+1&gt;0?r-l+1:0;&#125; int main()&#123; for(int len=1;len&lt;=9;len++) dfs(len,0,0); L[0]=0; L[++num]=1000000000; //for(int i=1;i&lt;=num;i++) printf("%d %lld\n",i,L[i]); ll Pl,Pr,Vl,Vr; int k; scanf("%lld%lld%lld%lld%d",&amp;Pl,&amp;Pr,&amp;Vl,&amp;Vr,&amp;k); ll sum=0; for(int i=1;i&lt;=1022-k+1;i++) &#123; int j=i+k-1; sum+=contain(L[i-1]+1,L[i],Pl,Pr)*contain(L[j],L[j+1]-1,Vl,Vr); if(L[i]&gt;Pr) break; &#125; for(int i=1;i&lt;=1022-k+1;i++) &#123; int j=i+k-1; sum+=contain(L[i-1]+1,L[i],Vl,Vr)*contain(L[j],L[j+1]-1,Pl,Pr); if(L[i]&gt;Vr) break; &#125; if(k==1) &#123; for(int i=1;i&lt;=1022;i++) &#123; if(contain(L[i],L[i],Pl,Pr)&amp;&amp;contain(L[i],L[i],Vl,Vr)) sum--; &#125; &#125; printf("%.10f\n",sum*1.0/(Vr-Vl+1)/(Pr-Pl+1));&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2774--Long Long Message]]></title>
    <url>%2Fposts%2Fd4401c4f.html</url>
    <content type="text"><![CDATA[题意：给出两个最长长为1e5的字符串，求他们的最长公共子串长度。 思路： 分别将两个字符串预处理出hash值，二分【1-min（lens，lent）】的长度，check函数中每次将长度为mid的hash值记录并检查是否符合条件，是则下边界右移，否则上边界左移。复杂度O(nlogn) 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int N =100000+5; char s[N],t[N];int lens,lent;ull base=233;ull p[N],hs[N],ht[N];ull geths(int l,int r)&#123; return hs[r]-p[r-l+1]*hs[l-1];&#125;ull getht(int l,int r)&#123; return ht[r]-p[r-l+1]*ht[l-1];&#125; int check(int len)&#123; vector&lt;ull&gt;mp; for(int i=1; i&lt;=lens-len+1; i++) &#123; ull tmp=geths(i,i+len-1); mp.push_back(tmp); &#125; sort(mp.begin(),mp.end()); for(int i=1; i&lt;=lent-len+1; i++) &#123; ull tmp=getht(i,i+len-1); if(binary_search(mp.begin(),mp.end(),tmp)) return 1; &#125; return 0;&#125; int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); p[0]=1; for(int i=1; i&lt;N; i++) p[i]=p[i-1]*base; while(~scanf("%s%s",s+1,t+1)) &#123; lens=strlen(s+1); lent=strlen(t+1); for(int i=1; i&lt;=lens; i++) &#123; hs[i]=hs[i-1]*base+s[i]-'a'; &#125; for(int i=1; i&lt;=lent; i++) &#123; ht[i]=ht[i-1]*base+t[i]-'a'; &#125; int l=1,r=min(lens,lent),mid; while(l&lt;=r) &#123; mid=(l+r)/2; if(check(mid)) l=mid+1; else r=mid-1; &#125; printf("%d\n",r); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>字符串hash</tag>
      </tags>
  </entry>
</search>
