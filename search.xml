<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[湘潭大学2019程序设计实践]]></title>
    <url>%2F%E6%B9%98%E6%BD%AD%E5%A4%A7%E5%AD%A62019%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5.html</url>
    <content type="text"><![CDATA[抄袭一时爽，查重火葬场 因考前会查重，故仅提供思路参考，代码后续补上，有更好解法欢迎交流 1262 Fish贪心，优先队列维护每个池塘能钓到鱼的数量即可，当前池塘有最多鱼的池塘优先出队列 12 1271 Color结论：n*m-(x的种类数)*(y的种类数) 12 1163 ASCLL直接模拟，输出%05X和%02X即带前导0的十六进制，回车的ASCLL码也要输出，注意输出空格和回车的地方 12 1243 Bob’s Password枚举九个数字会非法的情况即可 12 1246 Matrix Transposition看半天题意，n,m没用，将输入的x看做y，输入的y看做x，反过来按y优先排序即可 12 1248 Alice and Bob直接模拟，将1作为数字7处理会很好写很多，注意求和依然是+1 12 1251 Colombian Number简单数学，注意到[1,1000000000]区间内数位和在[1,81]内，所以只需在区间[n-81,n]内枚举k看是否能使k+sum(k)==n成立即可 12 1253 Robot贪心，如果在中途转弯肯定不如每次从头走到尾，可以证明最多转n-1次，时间复杂度O($n^2$) 12 1252 Matrix Word统计每个字符在每一行每一列的出现次数，最后判断是否都为1即可 12 1621 Duplicate Elementsunordered_map或map或set记录每个值是否出现即可,当然也可以用其他的哈希方法，超时的可以试试之前的方法 12 1263 矩形面积的并哪一年的蓝桥杯原题来着，求出相交矩形的边界,判掉不会相交的情况，在不知道位置相对位置的情况下计算面积注意取绝对值，面积并=两矩形面积和-两矩形面积交 l=max(min(x1,x2),min(x3,x4));r=min(max(x1,x2),max(x3,x4));d=max(min(y1,y2),min(y3,y4));u=min(max(y1,y2),max(y3,y4)); 12 1268 鞍点输入的时候就记录每行每列的最值即可 12 1272 Robot统计L,R,U,D的个数，只有当其中三个有且三个的其中一个变为剩下两个中另一个使得剩下两个相等时才可行 12 1277 Tri-Triangle找规律然后直接输出 12 1280 String Hash就是26进制转10进制 12 1281 Cute String输入用gets或者循环getchar()，跳过字符串首部空格后，统计中间空格个数便可知道单词个数，看空格个数是否&gt;9和字母种类个数&gt;10即可 12 1284 多项式直接求和，求和过程中取模 12 1286 比赛当时找的规律+猜结论？ 好像是dp[i]表示冠军最多打i场需要的最多选手人数，那么容易退推出前几项dp[0]=1,dp[1]=2,dp[2]=4… dp[i]=dp[i-1]+dp[i-2]+1，如果n&lt;=dp[i]，那么答案就是i 64位整数__int64要%I64d输入输出啊，%lld就gg了 12 1291 Buying Gifts要想最大值和最小值相差最小，那么连续的m长连续段礼物价格序列是最有可能的 将价格升序排序后以长度m尺取找出最小价格差即可，由于排好序所以总和肯定取之前的更小 12 1292 Co-stringhash预处理+枚举最大长度或者暴力枚举左右端点+剪枝 看statu应该有更简单的解法 12 1293 Diamond找规律直接输出 12 1294 Enquiry维护一个前缀和,sum[i]表示1…i有多少男女相邻的个数 12 1296 GCD容斥，与6互素就不会有和6一样的因子2,3，所以[l,r]区间的数减去2和3的倍数再加上6的倍数(计算2和3的倍数时多减了一次)即为答案 12 1299 String按题意模拟即可 12 1300 Dice按题意模拟即可 12 1301 Zeroes按题意模拟循环1000次即可 12 1305 斐波那契区间直接扫描一遍即可，注意防止越界，如果中途a[i]+a[i+1]!=a[i+2],那么左端点起点重新从i+1开始 12 1308 比赛按题意模拟计算即可 12 1239 2048巨恶心的大模拟，建议直接写相关函数每次调用，方便调试 12 1264 字符不重复子串如果是简单的求长度就直接用两个指针+标记数组做就好了，有点像滑动窗口 这里要用动态规划，pre[s[i]]为前一个s[i]的位置，f[i]表示以s[i]结尾的最长不重复子串长度 那么对于s[i]有两种情况，一是s[i]在前面未出现，那么f[i]=f[i-1]+1；二是前面已经出现了s[i]，如果控制的区间左端点l在pre[s[i]]前面，说明当前控制的区间中有部分要跳过，f[i]=i-pre[s[i]]，区间要缩小，否则依然是f[i]=f[i-1]+1 12 1273 Set用set或map或其他容器等统计数字种类数，种类数&lt;=3肯定可以，&gt;4肯定不行，==4特判一下 12 1274 Matrix很容易看出规律$ans=1+2^2+2^2+1+4^2+4^2+1+…+(2n)^2+(2n)^2+1$ 由于$1^2+2^2+3^2+…+n^2=n(n+1)(2n+1)/6$ 可以推出$2^2+4^2+6^2+…+(2n)^2=2n(n+1)(2n+1)/3$ 因为答案要取模,又因为公式中有除法需用到数论中逆元的知识解决 当然也可以直接上Java大数 12 1275 Exam Schedule直接模拟 12 1170 ICPC统计每列的最高等级和所有列最高等级的出现次数即可 12 1241 Permutation首先先学习一下置换的定义和置换乘法的性质，离散数学刘任任版P190 其实就是要通过不断映射使得序列回到初始序列 如果暴力模拟，可能会卡成O(n!)的复杂度，即全排列的情况 其实只需要计算对每一个数使a[i]变为i的次数，然后计算所有次数的最小公倍数即为答案 12 1249 Alice’s Prime首先一位的素数只有2,3,5,7，然后dfs将这四个数后面不断添加1,3,5,7,9再判断素数，最后排个序 12 1266 RGB统计R,G,B的出现次数，在0…R-1统计G,B的出现次数，记为R1,R2，在R…R+G-1统计R,B的出现次数，记为G1,G2，在R+G…lens-1统计R,G的出现次数，记为B1,B2 那么首先肯定是两个两个区间互相交换，R1,G1交换，R2,B1交换和G2,B2交换，有可能交换不完，成为0…R-1还有’G’，R…R+G-1还有’B’，R+G…lens-1还有’R’的情况，那对于每个未交换字符的需要交换2次 12 1267 Matrix直接模拟 12 1279 Dual Prime素数打表，1e6以内最多不到1e5个素数，然后枚举任意两个不同的素数，弄个前缀和维护1..i 内符合条件的个数 12 1283 Good Number首先n位数第一位必须是1，满足条件只需要n-1个数中的1的个数&gt;=0的个数，那么对n-1分奇偶谈论 n-1为奇，$ans=C_{n-1}^{n/2}+C_{n-1}^{n/2+1}+…+C_{n-1}^{n-1}$ n-1为偶，$ans=C_{n-1}^{n-1/2}+C_{n-1}^{n-1/2+1}+…+C_{n-1}^{n-1}$ n==1特判下，组合数用杨辉三角打表就好了，64位整数__int64要%I64d输入输出啊，%lld就gg了 12 1287 银行因为所有业务在当天，则可以把时间化为分钟数，然后枚举一天的所有分钟24*60=1440 对于每一分钟，如果有新的用户来了，则加入优先队列；如果过了上一个业务办理的时间，把队列中等待超时的出队列，然后队列中选一个优先级最高的业务开始处理 每个业务的等待时间：超时的就是最大等待时间，没超时的就是当前处理时间-业务开始时间 12 1295 Flawless Prime首先判断数位是否有0，存在0肯定不是，然后依次去掉最高位暴力判断是否为素数 12 1297 Homework发现与题目号无关，只需要通过学号和排名的关系来用map记录对应学号的积分，最后算出成绩排个序 12 1304 ZUMA!模拟把c放到第i个和第i+1个之间后的结果，然后答案取最大值 12 1307 Beautiful Number二进制枚举0的位置和二进制串的长度，对于64位整数第63位是符号位，唯一的0前面必须有1，不然就会成为前导0，如果0…61个位置中的第i个位置为0，那么len…i+1的位置为1，i-1…0的位置也为1， 计算出所有这样的数后排序，求答案每次遍历即可 12 1309 唯一的子串枚举左端点取出子串丢到set或map中去重，自动排序 12 1270 Unique Digit Number看top应该可以推公式，根据排列组合可以算出位数为1…10的符合条件数的个数…然后不会了 只会暴力dfs打表，根据位数打表就可以确保大小顺序，然后注意0不能作为前导 12 1303 Sequence乍一看以为是贪心，每次取较大的一端，其实这样有问题 记忆化搜索（备忘录），直接深搜的话对于当前长度都有两个选择，要么取左端点要么取右端点，时间复杂度O($2^n$) ans[l][r]表示区间l,r的最优解，回溯的时候如果已经求出了子区间的，直接返回对应值即可，不必重复计算 12 1244 Estrella’s Chocolate求最小的最大值，二分最大热量 以当前最大热量值吃完所有巧克力所需天数&gt;m，说明最大热量需要再大一些，左指针右移；反过来同理 12 1269 Craftman求制作手套最大值，二分手套件数 如果制作当前x件所需多余原料数&gt;k，说明原材料不够，右指针左移；反过来同理 12 1167 逆序数（大数据）既然是大数据，暴力O($n^2$)肯定T 树状数组或者归并排序O(nlogn) 12 1160 猜数字需要满足所有的k个条件，则需要把询问存起来离线操作，然后枚举$C_n^4$个的所有组合，回溯法或者直接枚举，对于每个组合看是否满足这k个询问 12 1179 Shortest PathDijkstra求k+1次最短路然后求和，注意指定的城市只能走一次，所以跑Dij的时候需要稍稍标记即可 12 1186 Tourist 2经典的TSP问题，回溯法O(n!)求出最优值并记录路径 12 1195 Large Population要求边最少，互相连通且边权最大，就是求最大生成树，把边按边权降序排然后Kruskal跑一下 12 1245 Lisa’s Puzzle把二进制反过来看做求前缀，构造一个只有01结点的trie树，类似于哈夫曼树，把每个数化为二进制01串插入到trie树，并记录每个结点经过的次数，每个数的答案就是该数最后一个结点的下面两个结点的经过次数和，下面没有结点说明该数不是其他数的前缀了 12 1250 Bonus把输入看做有向图，从出度为0的开始拓扑排序，也就是和常规的反过来，求出每个人的等级即可算工资 12 待更…]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>程序设计实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[湖南大学第15届校赛 H-Longest Common Palindrome Substring]]></title>
    <url>%2F%E6%B9%96%E5%8D%97%E5%A4%A7%E5%AD%A6%E7%AC%AC15%E5%B1%8A%E6%A0%A1%E8%B5%9B-H-Longest-Common-Palindrome-Substring.html</url>
    <content type="text"><![CDATA[原题链接 题意：给两个1e5长的字符串，求两者最长公共回文子串长度 思路： manacher 分别求出s,t串的mp[]数组，同时也可以求出对应最长奇回文子串长度(a,c)和最长偶回文子串长度(c,d) 由于manacher求出的是以i为中心的最长回文半径，且长度为len的子串为回文子串,len-2的的子串也为回文子串 那么s,t的最长公共回文子串长度可能是[0,1,3,5,…min(a,c)]和[0,2,4,6,…,min(b,d)]这两个区间内的一个长度 hash预处理字符串，然后分别二分这两个区间，check的时候就要用到mp[]数组来判断二分的长度子串是否为回文子串，注意分奇偶讨论 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn = 1e5+5;char ma[maxn*2];int mp[2][maxn*2];void manacher(char s[],int len,int k)&#123; int l=0; ma[l++]='$'; ma[l++]='#'; for(int i=1;i&lt;=len;i++)&#123; ma[l++]=s[i]; ma[l++]='#'; &#125; ma[l]=0; int mx=0,id=0; for(int i=0;i&lt;l;i++)&#123; mp[k][i]=mx&gt;i?min(mp[k][2*id-i],mx-i):1; while(ma[i+mp[k][i]]==ma[i-mp[k][i]]) mp[k][i]++; if(i+mp[k][i]&gt;mx)&#123; mx=i+mp[k][i]; id=i; &#125; &#125;&#125;char s[maxn],t[maxn];int lens,lent;ull base=233;ull p[maxn],hs[maxn],ht[maxn];ull geths(int l,int r)&#123; return (ull)hs[r]-p[r-l+1]*hs[l-1];&#125;ull getht(int l,int r)&#123; return (ull)ht[r]-p[r-l+1]*ht[l-1];&#125;vector&lt;ull&gt;tmp;bool check(int k)&#123; tmp.clear(); ull ss,tt; for(int i=0;i&lt;2*lens+2;i++)&#123; if(mp[0][i]-1&gt;=k)&#123; if((mp[0][i]-1)&amp;1)&#123; ss=geths(i/2-k/2,i/2+k/2); &#125; else&#123; ss=geths(i/2-k/2+1,i/2+k/2); &#125; tmp.push_back(ss); &#125; &#125; sort(tmp.begin(),tmp.end()); for(int i=0;i&lt;2*lent+2;i++)&#123; if(mp[1][i]-1&gt;=k)&#123; if((mp[1][i]-1)&amp;1)&#123; tt=getht(i/2-k/2,i/2+k/2); &#125; else&#123; tt=getht(i/2-k/2+1,i/2+k/2); &#125; if(binary_search(tmp.begin(),tmp.end(),tt)) return true; &#125; &#125; return false;&#125;int main() &#123; //freopen("in.txt","r",stdin); p[0]=1; for(int i=1;i&lt;maxn;i++)&#123; p[i]=p[i-1]*base; &#125; vector&lt;int&gt;len; while(~scanf("%s%s",s+1,t+1))&#123; lens=strlen(s+1); lent=strlen(t+1); for(int i=1;i&lt;=lens;i++)&#123; hs[i]=hs[i-1]*base+s[i]-'a'; &#125; for(int i=1;i&lt;=lent;i++)&#123; ht[i]=ht[i-1]*base+t[i]-'a'; &#125; int a=0,b=0,c=0,d=0; manacher(s,lens,0); for(int i=0;i&lt;2*lens+2;i++)&#123; int k=mp[0][i]-1; if(k&amp;1) a=max(a,k); else b=max(b,k); &#125; manacher(t,lent,1); for(int i=0;i&lt;2*lent+2;i++)&#123; int k=mp[1][i]-1; if(k&amp;1) c=max(c,k); else d=max(d,k); &#125; int Maxodd=min(a,c),Maxeven=min(b,d); len.clear(); len.push_back(0); for(int i=1;i&lt;=Maxodd;i+=2)&#123; len.push_back(i); &#125; int l=0,r=len.size()-1,ans=0; while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(check(len[mid])) l=mid; else r=mid-1; &#125; ans=max(ans,len[l]); len.clear(); for(int i=0;i&lt;=Maxeven;i+=2)&#123; len.push_back(i); &#125; l=0,r=len.size()-1; while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(check(len[mid])) l=mid; else r=mid-1; &#125; ans=max(ans,len[l]); printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>manacher</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template of ACM]]></title>
    <url>%2FTemplate-of-ACM.html</url>
    <content type="text"><![CDATA[ST表12345678910111213141516171819//f[i][j]表示区间[i,i+2^j-1]的最值void ST()&#123; for(int i=1;i&lt;=n;i++) d[i][0]=f[i][0]=a[i]; int t=log(n)/log(2); for(int j=1;j&lt;=t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); d[i][j]=min(d[i][j-1],d[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125;int querymax(int l,int r)&#123; int k=log(r-l+1)/log(2); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125;int querymin(int l,int r)&#123; int k=log(r-l+1)/log(2); return min(d[l][k],d[r-(1&lt;&lt;k)+1][k]);&#125; KMP123456789101112131415161718192021222324//next[i] 表示t[i-next[i]...i-1]=t[0...next[i]-1]//循环节len=m%(m-next[m])==0?m-next[m]:1void getNext(char t[],int m)&#123; int i,j; j=Next[0]=-1; i=0; while(i&lt;m)&#123; while(j!=-1&amp;&amp;t[i]!=t[j]) j=Next[j]; Next[++i]=++j; //if(t[++i]==t[++j]) Next[i]=Next[j]; //优化 //else Next[i]=j; &#125;&#125;int kmp(char s[],int n,char t[],int m)&#123; getNext(t,m); int i=0,j=0; while(i&lt;n)&#123; while(j==-1&amp;&amp;s[i]!=t[j]) j=next[j]; i++,j++; if(j&gt;=m)&#123; //匹配成功 ; &#125; &#125;&#125; ExtendKMP12345678910111213141516171819202122232425262728293031323334353637383940//next[i]表示t[i...m-1]与t[0...m-1]的最长公共前缀//extend[i]表示s[i...n-1]与t[0...m-1]的最长公共前缀int Next[maxn],extend[maxn];void getNext(char t[],int m)&#123; Next[0]=m; int j=0; while(j+1&lt;m&amp;&amp;t[j]==t[j+1]) j++; Next[1]=j; int k=1; for(int i=2;i&lt;m;i++)&#123; int p=Next[k]+k-1; int L=Next[i-k]; if(i+L&lt;p+1) Next[i]=L; else &#123; j=max(0,p-i+1); while(i+j&lt;m&amp;&amp;t[i+j]==t[j]) j++; Next[i]=j; k=i; &#125; &#125;&#125;void extendkmp(char t[],int m,char s[],int n)&#123; getNext(t,m); int j=0; while(j&lt;n&amp;&amp;j&lt;m&amp;&amp;t[j]==s[j]) j++; extend[0]=j; int k=0; for(int i=1;i&lt;n;i++)&#123; int p=extend[k]+k-1; int L=Next[i-k]; if(i+L&lt;p+1) extend[i]=L; else &#123; j=max(0,p-i+1); while(i+j&lt;n&amp;&amp;j&lt;m&amp;&amp;s[i+j]==t[j]) j++; extend[i]=j; k=i; &#125; &#125;&#125; 最小表示法123456789101112131415161718//取得最小表示法下标的开始位置int getmin(char s[],int n)&#123; for(int i=1;i&lt;=n;i++) s[n+i]=s[i]; int i=1,j=2,k; while(i&lt;=n&amp;&amp;j&lt;=n)&#123; for(k=0;k&lt;=n&amp;&amp;s[i+k]==s[j+k];k++); if(k==n) break; if(s[i+k]&gt;s[j+k])&#123; //s[i+k]&lt;s[j+k]最大表示法 i=i+k+1; if(i==j) i++; &#125; else&#123; j=j+k+1; if(i==j) i++; &#125; &#125; return min(i,j);&#125; Hash1234567891011121314151617181920typedef unsigned long long ull;char s[maxn],t[maxn];int lens,lent;ull base=233; //冲突可换其它素数ull p[maxn],hs[maxn];ull geths(int l,int r)&#123; return (ull)hs[r]-p[r-l+1]*hs[l-1];&#125;p[0]=1;for(int i=1;i&lt;maxn;i++)&#123; p[i]=p[i-1]*base;&#125;scanf("%s%s",s+1,t+1);lens=strlen(s+1);lent=strlen(t+1);for(int i=1;i&lt;=lens;i++)&#123; hs[i]=hs[i-1]*base+s[i];&#125; Manacher1234567891011121314151617181920212223//mp[i]表示以i为中心的最长回文的半径，mp[i]-1为原串中最长回文串的长度//mp[0...2*n+1]/2 求和即为所有子串中回文子串个数char ma[maxn*2];int mp[maxn*2];void manacher(char s[],int len)&#123; int l=0; ma[l++]='$'; ma[l++]='#'; for(int i=0;i&lt;len;i++)&#123; ma[l++]=s[i]; ma[l++]='#'; &#125; ma[l]=0; int mx=0,id=0; for(int i=0;i&lt;l;i++)&#123; mp[i]=mx&gt;i?min(mp[2*id-i],mx-i):1; while(ma[i+mp[i]]==ma[i-mp[i]]) mp[i]++; if(i+mp[i]&gt;mx)&#123; mx=i+mp[i]; id=i; &#125; &#125;&#125; 素数筛12345678910111213int p[maxn],cnt=0;;bool isp[maxn];void getprime()&#123; memset(isp,true,sizeof(isp)); isp[0]=isp[1]=false; isp[2]=true; for(int i=2;i&lt;maxn;i++)&#123; if(isp[i]) p[cnt++]=i; for(int j=0;j&lt;cnt&amp;&amp;p[j]*i&lt;maxn;j++)&#123; isp[p[j]*i]=false; &#125; &#125;&#125; 二分123456789101112131415//找a[]中&gt;=x最小的那个while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(a[mid]&gt;=x) r=mid; else l=mid+1;&#125;return a[l];//找a[]中&lt;=x最大的那个while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(a[mid]&lt;=x) l=mid; else r=mid-1;&#125;return a[l]; 快读12345678910//C++关闭同步流ios::sync_with_stdio(false);cin.tie(0);//正负整数inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125; 拓扑排序12345678910111213141516171819//求有向图顺序或判有环bool topu()&#123; queue&lt;int&gt;q; //要求字典序改优先队列 for(int i=1;i&lt;=n;i++)&#123; if(in[i]==0) q.push(i); &#125; int cnt=0; while(!q.empty())&#123; int x=q.front(); q.pop(); cnt++; for(int i=0;i&lt;V[x].size();i++)&#123; int next=V[x][i]; if(--in[next]==0) q.push(next); Rank[next]=Rank[x]+1; &#125; &#125; return cnt==n;&#125; Dijkstra123456789101112131415161718192021222324252627282930313233343536373839//求由form到图中其他点的最短路径struct node&#123; int val,id; node(int id,int val):id(id),val(val) &#123;&#125; bool operator &lt;(const node &amp;hs)const&#123; return val&gt;hs.val; &#125;&#125;;struct edge&#123; int next,to,w;&#125;e[maxm*2];int head[maxn],cnt;void addedge(int u,int v,int w)&#123; e[++cnt]=edge&#123;head[u],v,w&#125;; head[u]=cnt;&#125;int dis[maxn],vis[maxn];void dijkstra(int from)&#123; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++) dis[i]=INF; priority_queue&lt;node&gt;q; q.push(node(from,0)); dis[from]=0; while(!q.empty())&#123; int cur=q.top().id; q.pop(); if(vis[cur])continue; vis[cur]=true; for(int i=head[cur]; i ; i=e[i].next)&#123; int v=e[i].to; if(dis[cur]+e[i].w &lt; dis[v])&#123; dis[v]=dis[cur]+e[i].w; q.push(node(v,dis[v])); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARM嵌入式系统 学习笔记]]></title>
    <url>%2FARM%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[[TOC] 第1章 嵌入式系统概述 嵌入式系统定义：嵌入到对象体系中的专用计算机应用系统。 应用举例：手机、MP3、打印机、DV等。 嵌入式系统 分类 ①嵌入式微处理器（EMPU，基础是CPU，应用于专门设计的电路板上，满足嵌入式应用的特殊要求，在其工作温度、抗电磁干扰、可靠性等方面做了增强） ②微控制器（MCU，整个计算机系统集成到一块芯片中，适用于控制） ③DSP处理器（DSP，应用目标是大批量的消费类产品） ④片上系统（SOC，分通用和专用，专用芯片可用于互联网安全方面） 特点：嵌入性、专用性、计算机 嵌入式处理器：为了完成特殊的应用而设计的特殊目的处理器。 嵌入式最小系统：提供嵌入式处理器运行所必须的条件的电路与嵌入式处理器共同组成的系统。 嵌入式系统基本概念： 实时操作系统（RTOS）：一段在嵌入式系统启动后首先执行的背景程序，用户的应用程序是运行于RTOS之上的各个任务，RTOS根据各个任务的要求，进行资源管理、消息管理、任务调度及异常处理等工作。 资源：程序运行时可使用的软、硬件环境。 共享资源：被一个以上任务使用的资源。 任务：一个线程。 任务切换：保存当前运行任务的工作状态并入栈，把下一个要运行任务的当前状态从栈中装回CPU寄存器并开始运行。 内核：负责管理各个任务，提供任务切换的基本服务。 非占先式内核：中断后回到中断了的任务。 占先式内核：中断后让进入就绪态优先级最高的开始运行。 任务优先级：表示任务被调度的优先程度。 中断：一种硬件机制，用于通知CPU有个异步事件发生了。 常见嵌入式实时操作系统 μClinux：开源 Windows CE：开放 VxWorks：实时性卓越 μC/OS - ΙΙ：开源、抢占式 第2章 ARM7体系结构 ARM简介 ARM公司是一家知识产权(IP)供应商，它与一般的半导体公司最大的不同就是不制造芯片且不向终端用户出售芯片，而是通过转让设计方案，由合作伙伴生产出各具特色的芯片。 ARM架构是ARM公司面向市场设计的第一款低成本RISC微处理器。 ARM7后缀含义： 带M：64位乘法指令 带D：支持片上调试 带T：高密度16位Thumb指令集扩展 带I：Embedded ICE硬件仿真功能模块 ARM处理器使用冯·诺依曼结构，指令数据共用一条32位总线；直接支持8位字节(2^32)，16位半字(2^31)或者32位字(2^30)的数据类型。 如果一个数据是以字方式存储的，那么它就是字对齐的，否则就是非字对齐的；特征：bit0=bit1=0,其他任意。 如果一个数据是以半字方式存储的，那么它就是半字对齐的，否则就是非半字对齐的；特征：bit0=0,其他任意。 流水线 三级：①取指：从存储器装载一条指令 ②译码：识别将要执行的指令 ③执行：处理指令并将结果写回寄存器 ARM处理器状态 ARM指令集为32位长度，效率高，代码密度低，都是有条件执行，具有最完整的功能；Thumb指令集为16位长度，代码密度较高，只有一条具备有条件执行，能实现ARM指令集的大部分功能。在功能上可以认为Thumb是ARM的子集。 当前程序状态寄存器CPSR中的控制位T反映处理器正在操作的状态，T=0，处理器处于ARM状态，T=1，处理器处于Thumb状态。 从一个ARM例程调用另一个Thumb例程时，内核必须切换状态，反之亦然。BX分支将ARM内核的操作状态在ARM和Thumb之间进行切换。 &nbsp;&nbsp;&nbsp;&nbsp;7. ARM处理器模式 除了用户模式以外，其余所有6种模式称之为非用户模式 特权模式中除去系统模式外的5种模式称之为异常模式 用户(usr)、系统(sys)、管理(svc)、中止(abt)、未定义(und)、中断(irq)、快速中断(fiq) &nbsp;&nbsp;&nbsp;&nbsp;8. ARM内部寄存器 ARM处理器内部共有37个用户可访问的32位寄存器，其中有6个32位状态寄存器目前只使用了其中12位；31个通用寄存器+6个状态寄存器(1个CPSR+5个SPSR)；不可同时访问，对其访问取决于处理器状态和处理器模式。 堆栈指针R13(SP)，保存堆栈的出入口地址、待使用寄存器内容 链接寄存器R14(LR)，保存子程序和子程序的返回地址 程序计数器R15(PC)，总是指向“正在取指”的指令 所有模式共享一个程序状态寄存器CPSR，ARM通过此寄存器监视和控制内部操作的。SPSR为异常模式中保存CPSR当前值的备份程序寄存器。 程序状态寄存器格式 N Z C V … I F T M4 M3 M2 M1 M0 负 0 进位 溢出 保留 irq禁止 fiq禁止 状态位 模式位 . . . . &nbsp;&nbsp;&nbsp;&nbsp;9. 模式控制位 M[4:0] 模式 10000 用户 10001 快速中断 10010 中断 10011 管理 10111 中止 11011 未定义 11111 系统 &nbsp;&nbsp;&nbsp;&nbsp;10. 异常向量表 地址 异常 模式 0x0000 0000 复位 管理 0x0000 0004 未定义指令 未定义 0x0000 0008 软件中断 管理 0x0000 000C 中止（预取） 中止 0x0000 0010 中止（数据） 中止 0x0000 0014 保留 保留 0x0000 0018 IRQ 中断 0x0000 001C FIQ 快速中断 &nbsp;&nbsp;&nbsp;&nbsp;11. 中断优先级 优先级 异常 1 复位 2 数据中止 3 FIQ 4 IRQ 5 预取指中止 6 未定义指令 6 软件中断SWI &nbsp;&nbsp;&nbsp;&nbsp;12. ARM体系的储存系统 &nbsp;&nbsp;&nbsp;&nbsp;位于地址A的字包含的字节位于A、A+1、A+2、A+3； 小端格式：一个字中的最低地址被看作是最低位字节，最高地址的字节被看作是最高位字节，储存器系统字节0连接到数据线7~0； 大端格式：一个字中的最高位字节保存在最低地址，最低位字节保存在最高位地址，储存器系统字节0连接到数据线31~24； 第3章 ARM7TDMI（-S）指令系统 ARM处理器寻址方式 寄存器寻址： 寄存器编号 MOV R1,R2 ；将R2的值存入R1 SUB R0,R1,R2；将R1的值减R2的值结果存入R0 立即寻址： 操作数 SUBS R0,R0,#1；R0-1存入R0 MOV R0,#0xFF000；将立即数0xFF000装入R0 寄存器移位寻址： ASR(1-32)、LSL(1-31)、LSR(1-32)、ROR(1-31)、RRX(1) MOV R0,R2,LSL #3 ；R2的值左移3位结果存入R0 ANDS R1,R1,R2,LSL R3 ；R2的值左移R3位，结果与R1相与后存入R1 寄存器间接寻址： [] LDR R1,[R2] ；将R2指向的储存单元的数据读出存入R1 //加载字数据 SWP R1,R1,[R2]；将R2指向的储存单元的数据与R1的值交换 基址寻址 STR R1,[R0,#-4]！；将R1的值存入R0-4指定的储存单元 //存储字数据 多寄存器寻址：！，{ } LDMIA R1!,{R2-R7,R12}；将R1指向的单元中的数据读出到R2-R7,R12中，R1++；//多寄存器加载 STMIA R0!,{R2-R7,R12}；将R2-R7,R12的值保存到R0指向的存储单元中，R0++; //多寄存器存储 堆栈寻址 满堆栈：指向最后压入栈的有效数据项，向移动指针再写数据； 空堆栈：指向下一个待压入数据的空位置，先写入数据在移动指针； X递增：增大地址向上增长；X递减：减小地址向下增长。 相对寻址 程序计数器PC提供基准地址，地址码字段作为偏移量 第4章 LPC2000系列ARM硬件结构 为存储器分配地址的过程称为存储器映射；但为了增加系统的灵活性，系统中有部分存储单元（主要包括引导块(Boot Block)和用于保存向量表的少量存储单元）可以同时出现在不同地址上，则称为存储器重映射。 存储器重映射并不是对映射单元的内容进行了复制，只是将多个地址指向了同一个存储单元，通过“存储器管理部件”实现。即一个物理地址对应多个逻辑地址。 Boot Block是芯片设计厂家在LPC2000系列ARM内部固化的一段代码，用户无法对其修改或删除。这段代码在芯片复位后被首先运行，其功能主要是判断运行哪个存储器上的程序，检查用户代码是否有效，判断芯片是否被加密，芯片的在应用编程(IAP)以及在系统编程功能(ISP)。 系统启动代码(Boot Loader)：大部分由汇编指令构成，可以实现向量表定义、堆栈初始化、系统变量初始化、中断系统初始化、I/O初始化、外围初始化、地址重映射等操作。启动顺序：Boot Block-&gt;Boot Loader-&gt;操作系统 时钟系统概述：时钟是计算机系统的脉搏，处理器核在一拍接一拍的时钟驱动下完成指令执行、状态变换等动作。外设部件在时钟的驱动下进行着各种工作，比如串口数据的收发、A/D转换、定时器计数等。因此时钟对于一个计算机系统是至关重要的，通常时钟系统出现问题也是最致命的，比如振荡器不起振、振荡不稳、停振等。组成：晶体振荡器、唤醒定时器、锁相环（PLL）和VPB分频器。 晶体振荡器的两个模式：使用外部时钟源时，称为“从属模式”；使用外部晶体时，称为“振荡模式”。 LPC2000系列ARM两个复位源： 外部复位：通过把芯片的$\overline{RESET}$引脚拉为低电平使芯片复位。$\overline{RESET}$引脚为施密特触发输入引脚，带有一个额外的干扰滤波器，可以滤除非常短促的脉冲信号，使处理器不会被干扰脉冲意外复位，或者被不稳定的复位信号复位多次。 $\overline{RESET}$需要保持一段时间的低电平，必须在晶振稳定运行之后才能撤除。 在系统编程(ISP)：是一种非常实用的片内Flash烧写方式。ISP工作时，通过UART0使用约定协议与计算机上的ISP软件进行通信，并按用户的操作要求，调用内部的IAP代码实现各种功能。 看门狗复位：内置看门狗部件，可以利用此部件来复位处理器。 锁相环PLL 作用：将振荡器产生的时钟频率$F_{OSC}$进行升频。 LPC2000系列ARM是基于ARM7内核的，该内核的工作频率基本在100Mhz以下，所以LPC2000系列ARM大部分支持最高60MHz的内核时钟，少部分支持70MHz的内核时钟。 PLL频率计算：$F_{OSC}$经流控振荡器CCO得到$F_{CCO}$，$F_{CCO}$经过2P分频后得$F_{CCLK}=F_{CCO}/(2*P)$，$F_{CCO}/(2*P)$经M分频后得到$F_{CCO}/(2*P*M) = F_{OSC}$ PLL设置 参考链接 $F_{CCO}$取值必须在156～320MHz内 M取值1-32，将M-1放在PLLCFG[4:0] P取值1,2,4,8，将$log_2P$放在PLLCFG[6:5] PLLCON寄存器:包涵使能连接PLL的位,也就是控制PLL是否进行连接,这个连接需要在向PLLFEED发送正确的信息(馈送序列)的时候才生效,否则及时将使能位置位,PLL也不会连接到电路中。PLLCON必须在PLL开始连接之前就设置好,否则会造成系统不可预知的错误,先设置1后设置3。 PLLSTAT寄存器:从里面可以读出PLLCON,PLLCFG的值,但必须是在PLLFEED的馈送序列被发送,PLLCON,PLLCFG生效以后才可以读到正确的值(while(PLLSTAT &amp; (1&lt;&lt;10) == 0) ;) PLLFEED寄存器:向此寄存器以连续的VPB总线周期写入0xaa,0x55,即馈送序列，在正确的序列被写入PLLFEED之后,PLLCON,PLLCFG才生效,PLL电路才能正确的连接到电路中 12345678PLLCON = 1;PLLCFG = (M-1)|（log2(P)&lt;&lt;5）;PLLFEED = 0xaa;PLLFEED = 0x55;while(PLLSTAT &amp; (1&lt;&lt;10) == 0);PLLCON = 3;PLLFEED = 0xaa;PLLFEED = 0x55; &nbsp;&nbsp;9. VPB分频器 作用：将$F_{CCLK}$分频，方便外设工作、降低系统功耗 &nbsp;&nbsp;10. 两种节电模式： 空闲模式：处理器停止执行指令，使功耗最低降至1～2mA电流 掉电模式：振荡器关闭，芯片没有任何内部时钟，功耗降低到几乎为零 &nbsp;&nbsp;11. bank0~bank3的片选信号分别是CS0~CS3。 &nbsp;&nbsp;12. 外部存储器接口 LPC2200的外部存储器宽度可设定为8位，16位和32位 宽度为8位时，有效数据线D7~D0，只有BLS0有效 宽度为16位时，有效数据线D15~D0，BLS0、BLS1都有效 操作16位存储器时，需将LPC2200的地址线A1连接到存储器地址A0处 &nbsp;&nbsp;13. PSRAM读写数据 写入16位 123456789int main(void)&#123; uint16 *point16; uint16 data16 = 0x00; point16 = (uint16 *)0x80001020; while(1)&#123; *point16 = data16++; //循环向地址0x80001020处写入数据 &#125; return 0;&#125; 写入低8位 123456789int main(void)&#123; uint8 *point8; uint8 data8 = 0x00; point8 = (uint8 *)0x80001010; while(1)&#123; *point8 = data8++;//循环向地址0x80001010处写入数据 &#125; return 0;&#125; 写入高8位 123456789int main(void)&#123; uint8 *point8; uint8 data8 = 0x00; point8 = (uint8 *)0x80001011; while(1)&#123; *point8 = data8++;//循环向地址0x80001011处写入数据 &#125; return 0;&#125; 读取8位 1234567891011121314uint8 RcvDate8;int main(void)&#123; uint8 *point8; point8 = (uint*)0x80001010; while(1)&#123; RcvDate8 = *point8++;//读取0x80001010处的数据 RcvDate8 = *point8++;//读取0x80001011处的数据 RcvDate8 = *point8++;//读取0x80001012处的数据 RcvDate8 = *point8--;//读取0x80001013处的数据 point8--; point8--; &#125; return 0;&#125; &nbsp;&nbsp;14. ARM的大部分引脚都具有多种功能，即引脚复用。但是一个引脚在同一时刻只能使用其中一个功能，通过配置相关寄存器控制多路开关与片内外设。 &nbsp;&nbsp;15. GPIO的特性 可以独立控制每个GPIO口的方向（输入/输出模式） 可以独立设置每个GPIO口的输出状态（高/低电平） 所有GPIO口在复位后默认为输入状态 &nbsp;&nbsp;16. GPIO应用示例 ​ 设置P0.0为输出高电平 123PINSEL0 &amp;= 0xFFFFFFFC; //设置引脚连接模块，将P0.0设置为GPIO功能IO0DIR |= 0x00000001; //将P0.0设置为输出IOSET = 0x00000001; //设置P0.0输出高电平 使用GPIO控制蜂鸣器 123456789101112#define BEEPCON 0x00000080 //P0.7控制B1，低电平蜂鸣int main(void)&#123; PINSEL0 = 0x00000000; //设置引脚连接GPIO IO0DIR = BEEPCON; //设置I/O为输出 while(1)&#123; IO0SET = BEEPCON; //BEEPCON=1 Delay(10); IO0CLR = BEEPCON; //BEEPCON=0 Delay(10); &#125; reuturn 0;&#125; 读取P0.0引脚的电平状态 1234uint32 PinStat; //定义存放I/O状态的变量PINSEL0 &amp;= 0xFFFFFFFC; //设置引脚连接模块，将P0.0设置为GPIO功能IO0DIR &amp;= 0xFFFFFFFE; //将P0.0设置为输入PinStat = IO0PIN&amp;0x01; //通过IP0PIN寄存器获取P0.0当前电平状态 读取按键状态 12345678910111213#define BEEPCON 0x00000080#define PIN_P014 0x00004000 //定义P0.14屏蔽字int main(void)&#123; uint32 i; PINSEL0 = 0x00000000; //设置引脚连接GPIO IO0DIR = BEEPCON; //设置B1控制口为输出，其他I/O为输入 while(1)&#123; if((IO0DIR&amp;PIN_P014)!=0) IO0SET = BEEPCON; else IO0CLR = BEEPCON; Delay(10); &#125; return 0;&#125; 在多个I/O口线上输出数据 12345#define DataBus 0xFFPINSEL0 &amp;= 0xFFFF0000；//设置引脚连接模块，将P0.0~P0.7设置为GPIO功能IO0DIR |= DataBus; //将所有I/O口设置为输出IO0CLR = DataBus; //将所有I/O口设置为低电平输出IO0SET = Data; //将输出的数据从I/O口输出 &nbsp;&nbsp;17. 中断分类 快速中断请求（FIQ）：优先级最高 向量IRQ：中等优先级，16个优先级，每个中断源分别设置服务程序入口 非向量IRQ：优先级最低，支持一个非向量中断，所有中断共用一个服务程序入口 &nbsp;&nbsp;18. VIC可以管理32路中断请求。 &nbsp;&nbsp;19. 中断触发方式 边沿触发：上升沿触发、下降沿触发 电平触发：高电平触发、低电平触发 &nbsp;&nbsp;20. 外部中断应用示例 EINT0低电平中断初始化 12345678PINSEL1 = (PINSEL1&amp;0xFFFFFFFC)|0x01; //选择P0.16为EINT0EXTMODE = EXTMODE&amp;0x0E; //电平触发EXTPOLAR = EXTPOLAR&amp;0x0E; //低电平中断/*设置向量中断控制器*/VICIntSelect = VICIntSelect&amp;(~(1&lt;&lt;14)); //EINT0分配为IRQ中断VICVectCntl0 = 0x20|14; //EINT分配为向量IRQ通道0VICVectAddr0 = (uint32)EINT0_ISR; //向量IRQ通道0的中断服务程序地址为EINT0_ISRVICIntEnable = (1&lt;&lt;14); //EINT0中断使能 EINT0下降沿中断初始化 123PINSEL1 = (PINSEL1&amp;0xFFFFFFFC)|0x01;EXTMODE = EXTMODE|0x01;EXTPOLAR = EXTPOLAR&amp;0x0E; &nbsp;&nbsp;21. SPI总线系统是一种同步串行外设接口，允许MCU与各种外围设备一串行方式进行通信、数据交换。 &nbsp;&nbsp;22. $I^2C$BUS是NXP半导体公司推出的芯片间串行传输总线，它以2根连线实现了完善的双向数据传送，可以极方便的构成多机系统和外围器件拓展系统。 &nbsp;&nbsp;23. LPC2000系列ARM7微控制器包含有2个符合16C550工业标准的异步串行口（UART）：UART0和UART1。其中UART0只提供TXD（发送）和RXD（接受）信号引脚，而UART1增加了一个调制解调器（Modem）接口。 &nbsp;&nbsp;24. UART应用示例 UART0初始化 12345678910#define UART_BPS 115200void UART0_Ini(void)&#123; uint16 Fdiv; U0LCR = 0x83; //DLAB=1,可设置波特率 Fdiv = (Fpclk/16)/UART_BPS; //设置波特率 U0DLM = Fdiv/256; //除数锁存高位寄存器 U0DLL = Fdiv%256; //除数锁存低位寄存器 U0LCR = 0x03;&#125; UART0查询方式接受数据 123456uint8 UART0_RcvByte(void)&#123; uint8 rcv_data; while((U0LSR&amp;0x01)==0); //状态 rcv_data = U0RBR; //接受缓存 return rcv_data;&#125; UART0中断方式接受数据 12345678910111213141516171819void __irq UART_Exception(void)&#123; ... switch(U0IIR&amp;0x0f)&#123; case 0x04: //发生RDA中断 //从接受FIFO中读取数据 break; case 0x0c: //发生字符超时中断——CTI while((U0LSR&amp;0x01)==1)&#123; //如果接受FIFO中含有的有效数据，就读取UnRBR寄存器 RcvData[i++]=U0RBR; &#125; break; ... default: break; &#125; VICVectAddr = 0;&#125; &nbsp;&nbsp;25. 看门狗 带内部预分频器的可编程32位定时器]]></content>
      <categories>
        <category>嵌入式系统</category>
      </categories>
      <tags>
        <tag>嵌入式系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法设计与分析 学习笔记]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[[TOC] 第1章 算法概述算法定义：解决问题的有穷序列指令 算法的性质：输入、输出、确定性、有限性 程序和算法的区别：程序可不满足有限性，比如操作系统 求上下界函数： \lim_{n\rightarrow\infty} \frac{f(n)}{g(n)} = \begin{cases}0, & \text{f(n)=O(g(n))}\\\infty, & \text{f(n)= $\Omega$(g(n))}\\c,& \text{f(n)=$\Theta$(g(n))} \end{cases} 第2章 递归与分治策略一般递归方程时间复杂度分析 T(n)1} \end{cases}其中，a是子问题的个数，b是递减的步长，|表示递减方式，D(n)是合成子问题的开销 当|为减法： T(n)1}\\ O(n),&\text{a=1} \end{cases}当|为除法： $p=log_ba$ ①D(n)为常数 T(n)1}\\ O(log_bn),&\text{a=1} \end{cases}②D(n)为线性函数cn T(n)]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>算法设计与分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物联网概论 学习笔记]]></title>
    <url>%2F%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%AE%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[物联网（IoT）：Internet of Things 物联网是具有自我标示、感知和智能的物理实体基于通信技术相互连接形成的网络，这些物理设备可以在无需人工干预的条件下实现协同和互动，为人们提供智慧和集约的服务，传感网是物联网的基础，是物联网的组成部分 物联网三层体系结构：感知层、网络层和应用层 感知层是物联网的皮肤和五官——识别物体，采集信息； 网络层是物联网的神经中枢和大脑——信息传递和处理； 应用层是物联网的“社会分工”——与行业需求结合，实现广泛智能化 RFID全称：Radio Frequency Identification 射频识别 RFID系统的基本组成： ①硬件组成：RFID标签、识读器、天线和主机 ②软件组成：RFID系统软件、中间件和应用软件 RFID系统结构通过空中接口将电子标签与读写器连接 RFID系统的原理： ①耦合(Coupling)：根据需求和成本可利用电磁波和磁感应 ②磁耦合 ③电磁波耦合(反向散射原理) RFID频段分布 低频：125.124KHz 恶劣环境下使用 高频：13.56MHz 门禁卡、公交卡等 （ISO/IEC 14443标准 非接触集成电路接近卡） 超高频：433.92Mhz / 868-960Mhz 微波：2.45GHz 一般传感器的定义：测量装置、输入与输出有对应关系、有一定的精确度 一般传感器的组成： ①敏感元件：直接感受被测量、并输出与被测量成确定关系的某一物理量的元件 ②转换元件：敏感元件的输出就是它的输入，将感受到的非电量直接转换为电量的元件 ③测量电路：将转换元件输出的电量变换为便于显示、记录、控制、处理的有用电信号 传感器的静态特性： ①线性度：指其输出量与输入量之间的实际关系曲线(即静态特征曲线)偏离直线的程度，又称为非线性误差 ②灵敏度：指传感器在稳态下的输出变化量△y与引起变化的输入变化△x之比 ③迟滞：传感器在正(输入量增大)和反(输入量减小)行程期间，其输出-输入特性曲线不重合的现象 ④重复性：在输入按同一方向连续多次变动时得到特性曲线不一致的程度 ⑤分辨率：在测量方向内所能测量输入量的最小变化量△x ⑥漂移：在外界的干扰下，输出量发生与输入量无关的变化 应变效应：金属导体或者半导体在受外力作用时，会产生相应的应变，其阻值也随之发生变化 。 应变片式传感器——电桥 ①直流电桥（单臂电桥、惠斯通电桥）：$K_{u} = U/4$ ②半差动电桥(双臂电桥)：$K_{u} = U/2$ ③全桥电路（全臂电桥）：$K_{u} = U$ 变磁阻式(自感)传感器： 电感：在电路中电流发生变化时能产生电动势的性质成为电感，分为自感和互感 自感：当线圈中有电流通过时，线圈的周围就会产生磁场。当线圈中电流发生变化时，其周围的磁场也产生相应的变化，此变化的磁场可使线圈自身产生感应电动势。 互感：两个电感线圈相互靠近时，一个电感线圈的磁场变化将影响另一个电感线圈，这种影响就是互感。互感的大小取决于电感线圈的自感与两个电感线圈耦合的程度 。 应用范畴：微位移 分类： 变气隙式 &nbsp;&nbsp;工作原理：气隙厚度的改变，使得磁路中磁阻值变化，从而导致电路电感值变化 变截面式 螺管式 电容式传感器：$c_0 = \frac{\epsilon_0\epsilon_rS}{d_0}$ 分类：①变极距型②变面积型③变介质型（油箱测油位） 应用：手机指纹识别 ps:实验箱指纹识别模块使用的是光电式传感器 磁电式传感器-霍尔传感器 霍尔效应：置于磁场中的静止载流导体, 当它的电流方向与磁场方向不一致时, 载流导体上垂直于电流和磁场方向产生电动势。该电势称霍尔电势。 霍尔电势与控制电流和磁感应强度成正比 霍尔电势的灵敏度与霍尔常数RH正比而与霍尔片厚度成反比 应用：微位移、测转速(汽车轮胎)、测电流、计数、开关等 压电式传感器 压电效应：某些电介质,当沿着一定方向对其施力而使它变形时,其内部就产生极化现象,同时在它的两个表面上便产生符号相反的电荷,当外力去掉后,其又重新恢复到不带电状态。 Z为光轴，X为电轴，Y为机械轴 压电效应称为纵向压电效应，沿Y方向产生的为横向压电效应，沿Z轴不产生 侧压力时线性度不好，需要在力传递系统中加入预加力，称预载 光电式传感器 光电效应：光的频率越高，其光子能量就越大。当具有一定能量的光子作用到某些物体上转化为该物体中一些电子的能量而产生电效应。 分类： 外光电效应（光线照到某些物体上造成表面电子逸出的现象） 光电导效应、光生伏特效应(内光电效应) （物体受光照后，内部原子释放出电子不能逸出表面，使物体电阻率发生变化或产生光电动势的现象） 光电倍增管：对光电流放大以提高灵敏度,阳极最后收集到的电子数是阴极发射的$10^5～10^6$倍 应用：亮度传感器、烟雾报警器、光电鼠标等 无线传感器 定义：是大量的静止或移动的传感器以自组织和多跳的方式构成的无线网络，目的是协作地采集、处理、传输网络覆盖地域内感知对象的检测信息，并报告用户。 传感器节点 -&gt; 汇聚节点 -&gt; 管理节点 网络节点组成：传感模块—计算模块—通信模块——存储模块 无线传感网：WSN(Wireless sensor network) 电池供电，能量有限（耗能排序：发送&gt;接受&gt;空闲&gt;睡眠 短距离通讯（距离增加一倍，功耗增加三倍 节点生命周期 自适应网络 路由的性质： 路由策略分析：最大PA、最小能量消耗、最少跳转、最大最小PA节点 定向扩散路由：①兴趣扩散（洪泛方式）②梯度建立③加强路径 GPSR绕过路由空洞的步骤： 构造全网连接平面图 通过删边处理，变成可平面图（GG、RNG算法 通过右手法则，绕过路由空洞（每经过一个面，顺时针到的第一条边 MAC协议： 分类：时分复用无竞争接入方式(分配型）、随机竞争接入方式（竞争型）、竞争与固定分配相结合的接入方式（混合型） S-MAC协议： 优点： 周期性的侦听/睡眠的低占空比方式 虚拟簇的调度方式 自适应流量的侦听机制：通信结束继续侦听一段时间 串音避免：RTS/CTS/DATA/ACK 缺点：延迟受限于帧长度，不适合实时业务 分配性MAC协议： “隐藏终端”（Hidden Stations）：在通信领域，基站A向基站B发送信息，基站C未侦测到A也向B发送，故A和C同时将信号发送至B，引起信号冲突，最终导致发送至B的信号都丢失了。 暴露终端是指在发送节点的覆盖范围内而在接收节点的覆盖范围外的节点，暴露终端因听到发送节点的发送而可能延迟发送。但是，它其实是在接收节点的通信范围之外，它的发送不会造成冲突。这就引入了不必要的延时。 ZigBee 功能节点：协调者（COORDINATOR）、路由器（ROUTER）、终端设备（END DEVICE） 协调者（老大）功能：发送网络信标、建立一个PAN、管理网络节点、存储网络节点信息、寻找节点对路由信息 路由器功能：允许其它设备加入网络、跳跃路由、辅助子设备供电 终端设备功能：传感节点的载体、轻载化程序设计 网络拓扑结构：星型、网型、树形 模式：非信标模式（CSMA/CA）、信标模式（竞争和分配的混合性信道接入） CSMA/CA方式下通过三个参数的调节来实现冲突避免：退避次数（NB)、竞争窗口长度（CW)、退避指数（BE） 信标、超帧及其结构： 超帧包含活动部分和非活动部分，超帧以一个信标的开始为开始，信标定义超帧结构 CAP为自由竞争阶段、CFP为非竞争阶段、CFP内可以保证GTS（保证时隙）的传送 信标是子设备同步父设备的标记 耗能：传感模块的功耗远高于射频模块的功耗，这是因为传感模块大多采用模拟电路进行感测，需要一直恒定的加载电流。]]></content>
      <categories>
        <category>物联网概论</category>
      </categories>
      <tags>
        <tag>物联网概论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率论与数理统计 学习笔记]]></title>
    <url>%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[[TOC] 第一章 随机事件及其概率第一节 随机事件及其频率、概率的统计定义随机事件(偶然事件)：在试验的结果中，可能发生、也可能不发生的事件 随机事件的频率具有一定的稳定性 随机事件的概率为频率的近似值 P(A)\approxf(A) = $\frac{m}{n}$ 必然事件 P(U)=1 不可能事件 P(V)=0 第二节 样本空间样本点：随机试验的每一个可能出现的且是最简单的不可再分的结果 样本空间：所有的样本点构成的集合（分可列个和不可列个） 任一随机事件A都是样本空间Ω的一个子集 第三节 事件的关系及运算包含/包含于：$A \subset B$ 和(并)：$A∪B$ 积(交)：$A∩B 或 AB$ 互斥(互不相容)：两个互不相容的和 $A+B$ 对立(逆) 完备事件组：n个事件至少有一个事件一定发生 交换律、结合律、分配律、德摩根律 第四节 概率的古典定义乘法定理：完成一件事需r步，第i步有$ m_ i $种方法，完成这件事总方法数 $ m_ 1m_ 2…m_ r $ 加法定理：完成一件事有r类方法，第i类有$ m_ i $种方法，完成这件事总方法数 $ m_ 1+m_ 2+…+m_ r $ 排列：$ A _ n ^m = \frac{n!}{(n-m)!} $ 组合：$ C _ n ^m = \frac{A _ n ^m}{P_ m} = \frac{n!}{(n-m)!m!}$ 概率的古典定义：试验样本总共有$ n_Ω$ 个等可能的基本事件，其中随机事件A包含$ n_A$个基本事件，($ n_A$&lt;=$ n_Ω$) 则 $P(A) = \frac{n_A}{n_Ω}$ 不放回依次抽样与一次抽样的一致性 、 抽签次序无关性 第五节 概率加法定理若随机事件A与B互斥，即$AB = \emptyset，则P(A+B)= P(A)+P(B) \Rightarrow P(A)+P(\overline{A})=1$ 若A、B是任意的两个随机事件，则二者和事件的概率为 $P(A∪B)=P(A)+P(B)-P(AB)$ &ensp;&ensp; $\Rightarrow P(A∪B∪C)=P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC) $ 第六节 条件概率与乘法定理$P(B|A)=\frac{P(AB)}{P(A)}$ 若$P(A_1A_2…A_{n-1})&gt;0,则 P(A_1A_2…A_{n})=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1A_2…A_n-1)$ 第七节 全概率公式与贝叶斯公式&ensp;&ensp;先验，由因溯果 P(A) = \sum_{i=1}^nP(B_i)P(A|B_i) &ensp;&ensp;后验，由果溯因 P(B_i|A) = \frac{P(AB_i)}{P(A)} = \frac{P(B_i)P(A|B_i)}{\sum_{i=1}^nP(B_i)P(A|B_i)},i=1,2,...,n第八节 随机事件的独立性若两事件A与B满足P(AB) = P(A)P(B)，则称事件A与B相互独立 &ensp;&ensp;性质1：不可能事件及必然事件与任意的随机事件相互独立 &ensp;&ensp;性质2：A与B相互独立，则A与$\overline{B},\overline{A}与B,\overline{A}与\overline{A}$也相互独立&ensp;&ensp;（相互对称性） 第九节 贝努力概型事件A恰好发生k次的概率：$P_n(k) = C_n^kp^kq^{n-k},k=0,1,2,…,n$ $\sum_{k=0}^nP_n(k) = \sum_{k=0}^nC_n^kp^kq^{n-k} = (p+q)^n = 1$ 事件A发生次数介于$m_1$与$m_2$之间：$P_n(m_1&lt;=k&lt;=m_2) = \sum_{k=m1}^{m2}P_n(k)$ 事件A至少发生r次：$P(k&gt;=r) = \sum_{k=r}^nP_n(k) = 1 - \sum_{k=0}^{r-1}P_n(k)$ 第十节 概率论的公理化体系非负性：P(A)&gt;=0; 规范性：P(Ω)=1; 可列可加性(可数可加性)：$A_1,A_2,…$ 两两互不相容，则$P(\sum_{i=1}^\infty A_i) = \sum_{i=1}^\infty P(A_i)$ 第二章 随机变量及其分布第一节 随机变量的概念设Ω为随机变量的样本空间，如果对每一个样本点$\omega \in Ω$，均有唯一确定的实数X($\omega$)与之对应，即存在一个定义于Ω的单值实函数X=X($\omega$)，则称X=X($\omega$)为样本空间Ω上的随机变量 第二节 离散型随机变量的概率分布性质： ①$p_k&gt;=0 (k=1,2,..) $ ②$\sum_{k=1}^{\infty}p_k = 1$ 第三节 几种常用的离散型随机变量的分布“0-1”分布：$P(X=1) = p，P(X=0) = q（0&lt;p&lt;1，p+q=1）$ 超几何分布：$P(X=m) = \frac{C_M^mC_{N-M}^{n-m}}{C_N^n} （n&lt;=N,M&lt;=N）记作X～H(n,M,N)$ 二项分布：$P(X=k) = C_n^kp^kq^{n-k} （k=0,1,2,…,n） 记作X ～B(n,p)$ &ensp;&ensp;二项式分布的最可能取值( P(X=k)取得最大值的k )： &ensp;&ensp;①若(n+1)p不是整数，则其整数部分[(n+1)p]即为所求； &ensp;&ensp;②若(n+1)p=m是整数，则m和m-1即为所求 泊松分布：$P(X=k) = P_{\lambda}(k) = \frac{\lambda^k}{k!}e^{-\lambda} （k=0,1,2,…）记作X～P(\lambda)$ 几何分布：$P(X=k)=q^{k-1}p（k=1,2,…） 记作X～G(p)$ 第四节 随机变量的分布函数$F(x) = P(X&lt;=x)$ 性质： $F(x) 单调不减，若x_1&lt;x_2,则F(x_1)&lt;=F(x_2)$ $P(x_1&lt;X&lt;=x_2) = F(x_2)-F(x_1)$离散型随机变量只能用 $P(x_1&lt;=X&lt;=x_2) =P(x_1&lt;X&lt;=x_2)=P(x_1&lt;=X&lt;x_2)=P(x_1&lt;X&lt;x_2) =F(x_2)-F(x_1)$连续性随机变量都适用 离散型随机变量的F(x)含跳跃间断点；连续性随机变量F(x)连续且位于y=0与y=1之间 第五节 连续性随机变量的概率密度 分布函数F(x)与概率密度函数f(x)的关系： $f(x) = F^{′}(x) $ $F(x)=\int_{-\infty}^xf(t)dt$ 性质： $因为F(-\infty)=0,F(+\infty)=1,所以有\int_{-\infty}^{+\infty}f(x)dx = 1$ $P(x_1&lt;X&lt;=x_2)=F(x_2)-F(x_1)=\int_{x_1}^{x_2}f(x)dx$ 第六节 几种常用的连续随机变量的分布均匀分布 X~U(a,b) f(x)=\begin{cases} \frac{1}{b-a},&\text{a]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>概率论与数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛-41]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-41.html</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/contest/373#question A 翻硬币问题 题意：A和B玩游戏，A先手，要将n个正面硬币翻转为反面且每次只能翻转m个，B有一次可以在A翻转后将一枚硬币翻转的机会，给出n,m问A是否能将所有硬币翻转 思路： 简单签到题，容易想到： ​ 当n&lt;m时，A翻不了 ​ 当n==m时，A可以一下就翻完 ​ 当n&gt;m时，无论A是否刚好翻完，B都可以打乱 代码： 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); if(n==m) puts("Yes"); else puts("No"); &#125; return 0;&#125; B 666RGP 题意：给出n个数(n&lt;=300,-666&lt;=ai&lt;=666)，分数开始初值为0，对于第i个数有两种操作，一是分数+a[i],二是分数*(-1)，问经过n个数后有多少种方法分数变为-666，且中间分数不能出现666，答案对1e8+7取模 思路：简单计数dp 设dp[i] [j]表示，经过第i个数后分数为j的答案，那么有dp[i] [j] = dp[i-1] [j - a[i]] + dp[i-1] [-j] 注意过滤掉j==666的情况 因为j最大会有2*300*666 这么大，如果开dp[300] [2*300*666] 肯定空间不够 考虑转移方程只和i 和 i-1有关，可以用滚动数组形式优化 代码： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxv = 700*300;const int P = 1e8+7;int dp[2][maxv*2];int a[305]; int main() &#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); dp[0][maxv]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=-666*n;j&lt;=666*n;j++)&#123; if(j==666) continue; dp[i&amp;1][j+maxv]=(dp[(i-1)&amp;1][-j+maxv]+dp[(i-1)&amp;1][j-a[i]+maxv])%P; &#125; &#125; printf("%d\n",dp[n&amp;1][-666+maxv]); return 0;&#125; C 抓捕盗窃犯 题意：在n点中，第i个点有ai个人，再给出下一时刻第i个点的所有人转移到vi点，问在m个地方建立哨卡（可以一直监控当地经过的人），最多可以监视到多少人 思路： n个点，每个点有一条有向出边 容易想到这些点将组成一些块 且每个块内都有一个环 这样，一个块的所有地点的人都会经过环 那么用并查集整合n个地点人口，再取前m大就行 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;int f[maxn];ll a[maxn],b[maxn]; int get(int x)&#123; return f[x]==x?x:f[x]=get(f[x]);&#125; int main() &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; f[i]=i; scanf("%lld",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; int to; scanf("%d",&amp;to); int x=get(i),y=get(to); if(x!=y)&#123; f[x]=y; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; int f=get(i); b[f]+=a[i]; &#125; sort(b+1,b+1+n); ll ans=0; for(int i=n;i&gt;n-m;i--)&#123; ans+=b[i]; &#125; printf("%lld\n",ans); return 0;&#125; D 最小相似度 题意：给出n个m长的二进制01串，问构造一个m长的01串使得这个串和这n个串对应位相同的数量最大的最小值 思路：将n个串都作为起点进行bfs，搜索完所有2^m内的数，dp[i]表示从某个起点到i需要翻转的位数，既有多少位与原先某个串不相同，m-max(dp[i]) 即为最小相同的位数 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn =3e5+5;int n,m;int dp[1&lt;&lt;20]; void bfs()&#123; queue&lt;int&gt;q; char s[25]; memset(dp,-1,sizeof(int)*((1&lt;&lt;m)+5)); for(int i=0;i&lt;n;i++)&#123; scanf("%s",s); int tmp=0; for(int j=0;j&lt;m;j++)&#123; tmp+=(1&lt;&lt;j)*(s[j]-'0'); &#125; dp[tmp]=0; q.push(tmp); &#125; while(!q.empty())&#123; int u=q.front(); q.pop(); for(int j=0;j&lt;m;j++)&#123; if(dp[u^(1&lt;&lt;j)]!=-1) continue; dp[u^(1&lt;&lt;j)]=dp[u]+1; q.push(u^(1&lt;&lt;j)); &#125; &#125;&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;m); bfs(); int ans=-1; for(int i=0;i&lt;(1&lt;&lt;m);i++) ans=max(ans,dp[i]); printf("%d\n",m-ans);&#125; E 球的体积并 题意：给出两个球的球心坐标和半径，求两球相交体积 思路：球冠体积公式(h为球冠高，r为球半径,d为球心距) V=PI*h(3a^2+h^2)/6=PI*h^2(3r-h)/3 h=r-(ra^2-rb^2+d^2)/2d注意外离、外切、内含的几种情况需特判 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const double PI = acos(-1);typedef struct point &#123; double x,y,z; point() &#123; &#125; point(double a, double b,double c) &#123; x = a; y = b; z = c; &#125; point operator -(const point &amp;b)const &#123; //返回减去后的新点 return point(x - b.x, y - b.y,z-b.z); &#125; point operator +(const point &amp;b)const &#123; //返回加上后的新点 return point(x + b.x, y + b.y,z+b.z); &#125; point operator *(const double &amp;k)const &#123; //返回相乘后的新点 return point(x * k, y * k,z*k); &#125; point operator /(const double &amp;k)const &#123; //返回相除后的新点 return point(x / k, y / k,z/k); &#125; double operator *(const point &amp;b)const &#123; //点乘 return x*b.x + y*b.y+z*b.z; &#125;&#125; point;double dist(point p1, point p2) &#123; //返回平面上两点距离 return sqrt((p1 - p2)*(p1 - p2));&#125;typedef struct sphere &#123;//球 double r; point centre; double v()&#123; return 4.0/3*PI*r*r*r; &#125;&#125; sphere;void Solve(sphere a, sphere b) &#123; double d = dist(a.centre, b.centre);//球心距 //double t = (d*d + a.r*a.r - b.r*b.r) / (2.0 * d);// //double h = sqrt((a.r*a.r) - (t*t)) * 2;//h1=h2，球冠的高 //double angle_a = 2 * acos((a.r*a.r + d*d - b.r*b.r) / (2.0 * a.r*d)); //余弦公式计算r1对应圆心角，弧度 //double angle_b = 2 * acos((b.r*b.r + d*d - a.r*a.r) / (2.0 * b.r*d)); //余弦公式计算r2对应圆心角，弧度 if(d-a.r-b.r&gt;=0)&#123; printf("%.10f\n",a.v()+b.v()); return; &#125; if(d+a.r&lt;b.r||d+b.r&lt;a.r)&#123; printf("%.10f\n",max(a.v(),b.v())); return; &#125; double l1 = (a.r*a.r - b.r*b.r + d*d) / (2*d); double l2 = (b.r*b.r - a.r*a.r + d*d) / (2*d); double h1 = a.r - l1, h2 = b.r - l2;//分别为两个球缺的高度 double v1 = PI*h1*h1*(a.r - h1 / 3);//相交部分r1圆所对应的球缺部分体积 double v2 = PI*h2*h2*(b.r - h2 / 3);//相交部分r2圆所对应的球缺部分体积 double v = v1 + v2;//相交部分体积 printf("%.10f\n",a.v()+b.v()-v); //double s1 = PI*a.r*x1; //r1对应球冠表面积 //double s2 = PI*a.r*x2; //r2对应球冠表面积 //double s = 4 * PI*(a.r*a.r + b.r*b.r) - s1 - s2;//剩余部分表面积&#125; int main() &#123; sphere a,b; scanf("%lf%lf%lf%lf",&amp;a.centre.x,&amp;a.centre.y,&amp;a.centre.z,&amp;a.r); scanf("%lf%lf%lf%lf",&amp;b.centre.x,&amp;b.centre.y,&amp;b.centre.z,&amp;b.r); Solve(a,b); return 0;&#125; F 简单数学题 数学弃… 岑巨出的题，难度适中，B题dp因为没注意要从dp[0] [maxv]开始初始化debug了很久 C题想到了并查集竟然不想写 E题内含的条件写错了，一直以为公式错了QAQ 还是大意了啊]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>bfs</tag>
        <tag>dp</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客OI周赛7-普及组]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2OI%E5%91%A8%E8%B5%9B7-%E6%99%AE%E5%8F%8A%E7%BB%84.html</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/contest/372#question A 救救猫咪 暴力 B 救救兔子 题意：给出n长数组，m个询问，每次询问给出一个x，要求数组中与x差距最小的数(如果差距相等，输出较小的那个) 思路： 二分，原数组排序后用upper_lowbound() 找出第一个比x大元素的位置，在分别比较当前位置和当前位置-1的数与x的差距，注意比第一个数小和最后一个数大的时候需特判 代码： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;int a[maxn]; int main()&#123; int n,q,x; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); sort(a,a+n); scanf("%d",&amp;q); while(q--)&#123; scanf("%d",&amp;x); if(x&gt;=a[n-1]) printf("%d\n",a[n-1]); else if(x&lt;=a[0]) printf("%d\n",a[0]); else&#123; int pos=upper_bound(a,a+n,x)-a; if(abs(a[pos-1]-x) &lt;= abs(a[pos]-x)) printf("%d\n",a[pos-1]); else printf("%d\n",a[pos]); &#125; &#125;&#125; C 救救企鹅 题意: 给出字符串s,a,b(长度&lt;=1e6),要求输出将s中所有a替换为b后的字符串 思路: kmp或hash求出s中与a匹配的位置,再替换一下即可 比赛的时候没有注意到a,b串的长度可以不相等 只过了50%qwq 赛后发现用Java或Python都可以直接秒这题tql 代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int maxn = 1e6+5;char s[maxn],a[maxn],b[maxn];int lens,lena,lenb;ull base=131;ull p[maxn],hs[maxn];ull geth(int l,int r)&#123; return (ull)hs[r]-hs[l-1]*p[r-l+1];&#125; vector&lt;int&gt;pos;int main()&#123; p[0]=1; for(int i=1;i&lt;maxn;i++) p[i]=p[i-1]*base; scanf("%s%s%s",s+1,a+1,b+1); lens=strlen(s+1); lena=lenb=strlen(a+1); ull tt=0; for(int i=1;i&lt;=lena;i++) tt=tt*base+(ull)a[i]; for(int i=1;i&lt;=lens;i++) hs[i]=hs[i-1]*base+(ull)s[i]; for(int i=1;i&lt;=lens-lena+1;i++)&#123; ull ss=geth(i,i+lena-1); if(ss==tt)&#123; pos.push_back(i); i+=lena-1; &#125; &#125; int k=1; for(int i=0;i&lt;pos.size();i++)&#123; while(k!=pos[i])&#123; putchar(s[k]); k++; &#125; printf("%s",b+1); k+=lena; &#125; while(k&lt;=lens)&#123; putchar(s[k]); k++; &#125; puts("");&#125; D 数糖纸 题意: 给出长度为n的数组(maxn=1e6),要求不含相同元素的最长连续区间长度 思路: 双指针(l,r)移动表示[l,r]内没有重复的元素,用个set记录当前区间已经出现了的数,如果枚举到一个没有出现的数,则加入set,++r,否则一直删除左端已经出现过的元素直到重复元素被删除 上面可以稍微优化一下,因为 Ai 最大1e9,我们先将原数组离散化,再用一个vis[] 记录Ai 是否出现过 代码1: 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;int a[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int ans=-1,l=1,r=1; set&lt;int&gt;s; while(r&lt;=n)&#123; if(s.find(a[r])==s.end())&#123; s.insert(a[r]); ans=max(ans,r-l+1); r++; &#125; else&#123; s.erase(a[l]); l++; &#125; &#125; printf("%d\n",ans);&#125; 代码2: 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;int a[maxn],b[maxn],pre[maxn],vis[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); b[i]=a[i]; &#125; sort(b+1,b+1+n); int m=unique(b+1,b+1+n)-b-1; for(int i=1;i&lt;=n;i++)&#123; a[i]=lower_bound(b+1,b+1+n,a[i])-b-1; &#125; int ans=-1,l=1; for(int i=1;i&lt;=n;i++)&#123; if(!vis[a[i]])&#123; vis[a[i]]=1; &#125; else&#123; while(a[l]!=a[i])&#123; vis[a[l]]=0; l++; &#125; l++; vis[a[i]]=1; &#125; ans=max(ans,i-l+1); &#125; printf("%d\n",ans);&#125; 一场比较简单的比赛,一点小粗心kmp就挂了 第一次在高铁上写博客,刺激~]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>字符串hash</tag>
        <tag>暴力</tag>
        <tag>kmp</tag>
        <tag>STL</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EOJ Monthly 2019.2]]></title>
    <url>%2FEOJ-Monthly-2019-2.html</url>
    <content type="text"><![CDATA[原题链接：https://acm.ecnu.edu.cn/contest/140/ A,B,C,E To be continue… D 进制转换 题意：求[l,r]中所有数的k进制末尾恰好有m个零的数有多少个 思路： x在k进制下末尾恰好有m个零说明x%(k^m)恒等于0，而x%(k^(m+1))不恒等于0，而x%(k^m)==0的情况包含了x%(k^(m+1))==0的情况，所以由容斥定理有[1,x]中满足题意的数有 x/(k^m) - x/(k^(m+1)) 个 代码： 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;ll calc(ll k,ll m,ll x)&#123; for(int i=1;i&lt;=m;i++)&#123; x/=k; &#125; return x;&#125;int main()&#123; ll l,r,k,m; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%lld%lld%lld%lld",&amp;l,&amp;r,&amp;k,&amp;m); printf("%lld\n",calc(k,m,r)-calc(k,m+1,r)-calc(k,m,l-1)+calc(k,m+1,l-1)); &#125;&#125; F 方差 题意： 在n个数中选m个数，使得这m个数的方差*(m^2)最小 思路： 首先想到要使方差越小，则要这m个数与平均数的差距越小，所以我们可以先排序再尺取m长; 不难发现将方差公式乘以m^2后可以化简得到 m(a_1^2+a_2^2+⋯+a_m^2) − (a_1+a_2+⋯+a_m)^2（MathJax真好用，小声哔哔 然后维护一个前缀和与一个前缀平方和即可 代码： 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;int a[maxn];ll sum1[maxn],sum2[maxn];int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; sort(a+1,a+1+n); for(int i=1;i&lt;=n;i++)&#123; sum1[i]=sum1[i-1]+a[i]; sum2[i]=sum2[i-1]+a[i]*a[i]; &#125; ll ans=-1; for(int i=m;i&lt;=n;i++)&#123; ll tmp=m*(sum2[i]-sum2[i-m])-(sum1[i]-sum1[i-m])*(sum1[i]-sum1[i-m]); if(ans==-1||ans&gt;tmp) ans=tmp; &#125; printf("%lld\n",ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客OI周赛7-提高组]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2OI%E5%91%A8%E8%B5%9B7-%E6%8F%90%E9%AB%98%E7%BB%84.html</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/contest/371#question A 小睿睿的等式 题意：有n根火柴棒，能摆成形如“A+B=n”的等式且使用的火柴棒数也恰好等于n/k的等式有多少种(B+A=n与A+B=n看作一种,“=”与“+”分别需要使用2根火柴棒,maxn=5e7) 思路：直接暴力拆分每组A+B写的挫会超时，比赛时没注意给出的空间很大(512MB)，先将所有5e7以内数所需火柴数打表即可 代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =5e7+5;int num[maxn];int main() &#123; num[0]=6; num[1]=2; num[2]=5; num[3]=5; num[4]=4; num[5]=5; num[6]=6; num[7]=3; num[8]=7; num[9]=6; int n; int k; scanf("%d%d",&amp;n,&amp;k); for(int i=10;i&lt;=n;i++)&#123; num[i]=num[i/10]+num[i%10]; &#125; int kk=n/k; int ans=0,x,y,z=num[n]; for(int a=0; a&lt;=n/2; a++) &#123; int b=n-a; x=num[a]; y=num[b]; if(x+y+z+4==kk) ans++; &#125; printf("%d\n",ans); return 0;&#125; B 小睿睿的询问 题意：给出随机生成一个n长数组的函数和生成区间查询L，R的函数，要求所有L，R区间生成数组中val[i]最大且较小下标异或值（maxn=1e5，maxm=5e7) 思路：最开始写的线段树（O(mlogn)），因为是随机数据没想到过了时间是全场最久的(4632/5000 ms),后来知道可以用ST表写，但自己写的挫，加了个二分查对应下标也用了2900+ms(O(nlognlogn))，再后来可以在ST表处直接用个pair，val[i]和i对应,每次查询O(1)，总体复杂度O(nlogn+m) 代码： 线段树版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =1e5+5;int n,m;int val[maxn],Max[maxn&lt;&lt;2],idx[maxn&lt;&lt;2]; void push_up(int l,int r,int o)&#123; Max[o]=max(Max[o&lt;&lt;1],Max[o&lt;&lt;1|1]); if(Max[o&lt;&lt;1] &gt;= Max[o&lt;&lt;1|1]) idx[o]=idx[o&lt;&lt;1]; else idx[o]=idx[o&lt;&lt;1|1];&#125; void build(int l,int r,int o)&#123; if(l==r)&#123; Max[o]=val[l]; idx[o]=l; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(l,r,o);&#125; int query(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return idx[o]; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid&amp;&amp;R&gt;mid)&#123; int i=query(L,R,lson); int j=query(L,R,rson); if(val[i]&gt;=val[j]) return i; else return j; &#125; else if(L&lt;=mid)&#123; return query(L,R,lson); &#125; else if(R&gt;mid)&#123; return query(L,R,rson); &#125; return 0;&#125; void generate_array(int n,int seed) &#123; unsigned x = seed; for (int i=1; i&lt;=n; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; val[i]=x%100; &#125;&#125; int lastans=0,ans=0;void generate_ask(int n,int m,int seedx,int seedy) &#123; unsigned x=seedx,y=seedy; for (int i=1; i&lt;=m; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; y ^= y &lt;&lt; 13; y ^= y &gt;&gt; 17; y ^= y &lt;&lt; 5; int L=(x^lastans)%n+1,R=(y^lastans)%n+1; if (L&gt;R) swap(L,R); lastans=query(L,R,1,n,1); ans^=lastans; &#125; printf("%d\n",ans);&#125; int main() &#123; int seed,seedx,seedy; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;seed,&amp;seedx,&amp;seedy); //double ss=clock(); generate_array(n,seed); build(1,n,1); generate_ask(n,m,seedx,seedy); //printf("%.0fms\n",clock()-ss); return 0;&#125; 二分+ST版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =1e5+5;int n,m;int val[maxn];vector&lt;int&gt;idx[105];int f[maxn][20];void ST_pre()&#123; for(int i=1;i&lt;=n;i++)&#123; f[i][0]=val[i]; &#125; int t=log(n)/log(2)+1; for(int j=1;j&lt;t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]); &#125; &#125;&#125;int ST_query(int l,int r)&#123; int k=log(r-l+1)/log(2); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125; void generate_array(int n,int seed) &#123; unsigned x = seed; for (int i=1; i&lt;=n; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; val[i]=x%100; idx[val[i]].push_back(i); &#125;&#125; int lastans=0,ans=0;void generate_ask(int n,int m,int seedx,int seedy) &#123; unsigned x=seedx,y=seedy; for (int i=1; i&lt;=m; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; y ^= y &lt;&lt; 13; y ^= y &gt;&gt; 17; y ^= y &lt;&lt; 5; int L=(x^lastans)%n+1,R=(y^lastans)%n+1; if (L&gt;R) swap(L,R); int pos,Max=ST_query(L,R); int s=lower_bound(idx[Max].begin(),idx[Max].end(),L)-idx[Max].begin(); for(int k=s;k&lt;=idx[Max].size();k++)&#123; if(idx[Max][k]&gt;=L&amp;&amp;idx[Max][k]&lt;=R)&#123; pos=idx[Max][k]; break; &#125; &#125; lastans=pos; ans^=lastans; &#125; printf("%d\n",ans);&#125; int main() &#123; int seed,seedx,seedy; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;seed,&amp;seedx,&amp;seedy); //double ss=clock(); generate_array(n,seed); ST_pre(); generate_ask(n,m,seedx,seedy); //printf("%.0fms\n",clock()-ss); return 0;&#125; 优化ST版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =1e5+5;int n,m;int val[maxn];pair&lt;int,int&gt; f[maxn][20]; void ST_pre()&#123; for(int i=1;i&lt;=n;i++)&#123; f[i][0].first=i; f[i][0].second=val[i]; &#125; int t=log(n)/log(2)+1; for(int j=1;j&lt;t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; //f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]); f[i][j] = f[i][j-1].second &gt;= f[i+(1&lt;&lt;j-1)][j-1].second ? f[i][j-1]:f[i+(1&lt;&lt;j-1)][j-1]; &#125; &#125;&#125;int ST_query(int l,int r)&#123; int k=log(r-l+1)/log(2); return f[l][k].second &gt;= f[r-(1&lt;&lt;k)+1][k].second ? f[l][k].first : f[r-(1&lt;&lt;k)+1][k].first;&#125; void generate_array(int n,int seed) &#123; unsigned x = seed; for (int i=1; i&lt;=n; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; val[i]=x%100; &#125;&#125; int lastans=0,ans=0;void generate_ask(int n,int m,int seedx,int seedy) &#123; unsigned x=seedx,y=seedy; for (int i=1; i&lt;=m; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; y ^= y &lt;&lt; 13; y ^= y &gt;&gt; 17; y ^= y &lt;&lt; 5; int L=(x^lastans)%n+1,R=(y^lastans)%n+1; if (L&gt;R) swap(L,R); int pos=ST_query(L,R); lastans=pos; ans^=lastans; &#125; printf("%d\n",ans);&#125; int main() &#123; int seed,seedx,seedy; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;seed,&amp;seedx,&amp;seedy); //double ss=clock(); generate_array(n,seed); ST_pre(); generate_ask(n,m,seedx,seedy); //printf("%.0fms\n",clock()-ss); return 0;&#125; C 小睿睿的方案 To be continue… 这场Rating赛打得还是还算比较开心吧，学了一下ST表空间复杂度O(nlogn),区间查询O(1)很不错的算法，程序运算时间的计算和数组所占大概空间的计算，虽然理论课学了但一直没去实践QWQ另外牛客题目还不错~不说了EOJ的题还没补呢！]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>ST</tag>
        <tag>线段树</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛 40A--小D的剧场]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-40A--%E5%B0%8FD%E7%9A%84%E5%89%A7%E5%9C%BA.html</url>
    <content type="text"><![CDATA[题意： 给出自然数1-49的49个数要求拼接成长度为n的序列，且要求任意相邻的三个不能为给出q个条件中任意一个条件的全排列，求所有合法序列数对 1e9+7 取模。 原题链接：https://ac.nowcoder.com/acm/contest/369/A Input: 123456789101110 10 //n q18 3 343 28 2242 28 348 48 429 9 3147 9 221 22 4915 48 292 8 274 24 34 Output: 1382785822 思路： 设dp[i] [j] [k]为放到第i位时，a[i-1]=j, a[i]==k的状态，提前将不合法字段标记，转移方程： dp_{i,k,l} = \sum_{i=1}^{49} (!ban_{j,k,l})*dp_{i-1,j,k}表示j,k,l可行时，可在 a[i-2]==j,a[i-1]==k的状态转移到 a[i-1]==k,a[i]==l的状态。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int P = 1e9+7;int dp[505][50][50];bool ban[50][50][50];int main()&#123; int n,q; scanf("%d%d",&amp;n,&amp;q); while(q--)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ban[a][b][c]=ban[a][c][b]=true; ban[b][a][c]=ban[b][c][a]=true; ban[c][a][b]=ban[c][b][a]=true; &#125; for(int i=1;i&lt;=49;i++)&#123; for(int j=1;j&lt;=49;j++)&#123; dp[2][i][j]=1; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=49;j++)&#123; for(int k=1;k&lt;=49;k++)&#123; for(int l=1;l&lt;=49;l++)&#123; if(!ban[j][k][l])&#123; dp[i][k][l]=(dp[i][k][l]+dp[i-1][j][k])%P; &#125; &#125; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=49;i++)&#123; for(int j=1;j&lt;=49;j++)&#123; ans=(ans+dp[n][i][j])%P; &#125; &#125; printf("%d\n",ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛 40C--小A与欧拉路]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-40C--%E5%B0%8FA%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%B7%AF.html</url>
    <content type="text"><![CDATA[题意： 小A给你了一棵树，对于这棵树上的每一条边，你都可以将它复制任意（可以为0）次（即在这条边连接的两个点之间再加一条边权相同的边），求所有可能新形成的图中欧拉路的最短长度 欧拉路：从图中任意一个点开始到图中任意一个点结束的路径，并且图中每条边只通过恰好一次。 原题链接：https://ac.nowcoder.com/acm/contest/369/C Input： 12344 //n 树的点数1 2 1 //u v w1 3 11 4 2 Output： 15 思路： 先考虑回路的情况。由于是一棵树，任两点间路径只有一条，从一条边走到深度更大的点，一定还会从同一条边返回以回到起点或者遍历其他子树，所以每条边需要复制一次，此时答案是边权和的两倍。 不是回路的情况可以减掉从终点回到起点的路径，要让这条路径尽量长，所以长度一定是直径的长度。 答案就是边权和的两倍减去直径长度。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2e5+5;struct EDGE&#123; int next,w,to;&#125;edge[maxn*2];int head[maxn];int cnt; void add(int u,int v,int w)&#123; edge[++cnt].next=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125; int pos,ans;int d[maxn];void dfs(int x,int pre)&#123; for(int i=head[x];i;i=edge[i].next)&#123; int to=edge[i].to; if(to==pre) continue; d[to]=d[x]+edge[i].w; dfs(to,x); &#125; if(d[x]&gt;ans)&#123; ans=d[x]; pos=x; &#125;&#125; int main()&#123; int n; scanf("%d",&amp;n); ll sum=0; for(int i=0;i&lt;n-1;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); sum+=2*w; &#125; dfs(1,-1); memset(d,0,sizeof(d)); dfs(pos,-1); printf("%lld\n",sum-ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>欧拉路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSU 1803--2016]]></title>
    <url>%2FCSU%201803--2016.html</url>
    <content type="text"><![CDATA[题意： 求[l,r]之间有多少种a*b=2016的组合。 思路： 首先2016的1倍情况下有1*2016 , 2*1008 , 3*637… 等情况，2倍情况就是把a或b扩大2倍就行，那么我们可以把a看做[1,2016]的数，a’ 看做[2017,4032]的数，这样每次跨2016个数就知道有多少倍数了。最后两层for循环找出i*j==2016的时候把对应的倍数种类乘起来加到答案就行了。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; int main()&#123; ll n,m; ll a[3000],b[3000]; //a[i]储存n有多少个i*2016&lt;=n，b[i]....m while(~scanf("%lld%lld",&amp;n,&amp;m)) &#123; ll k=n/2016; //有k个2016跨度 ll mm=n%2016; //余下的等下都要+1 for(int i=1;i&lt;=mm;i++) a[i]=k+1; for(int i=mm+1;i&lt;=2016;i++) a[i]=k; k=m/2016; mm=m%2016; for(int i=1;i&lt;=mm;i++) b[i]=k+1; for(int i=mm+1;i&lt;=2016;i++) b[i]=k; ll ans=0; for(int i=1;i&lt;=2016;i++) &#123; for(int j=1;j&lt;=2016;j++) &#123; if((i*j)%2016==0) &#123; ans+=(a[i]*b[j]); &#125; &#125; &#125; printf("%lld\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 4011--Happy-Sequence]]></title>
    <url>%2FZOJ%204011--Happy-Sequence.html</url>
    <content type="text"><![CDATA[题意： 给一个n和m，求所有组成m长且值在1-n内且满足 a[i]%a[i-1]==0 的序列方案数。 思路： dp[i] [j] 表示长度为 i 的序列的最后一位为 j ,转移方程：dp[i] [j]=0 , dp[i] [j]+=dp[i-1] [ j的因子 ] 。因子可以通过埃氏筛打表得到，dp[m] [i]累加和即为答案，预处理2000*2000以内所有答案即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std; #define N 2005#define mod 1000000007int dp[N][N];vector&lt;int&gt;y[N]; //储存因子int main()&#123; for(int i=1; i&lt;=N; i++) &#123; for(int j=i; j&lt;=N; j+=i) &#123; y[j].push_back(i); &#125; &#125; for(int i=1; i&lt;=N; i++) dp[1][i]=1; for(int i=2; i&lt;=N; i++) &#123; for(int j=1; j&lt;=N; j++) &#123; for(int k=0; k&lt;y[j].size(); k++) &#123; dp[i][j]=(dp[i][j]+dp[i-1][y[j][k]])%mod; &#125; &#125; &#125; int t; scanf("%d",&amp;t); while(t--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); int ans=0; for(int i=1; i&lt;=n; i++) ans=(ans+dp[m][i])%mod; printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 2594--Driving-Straight]]></title>
    <url>%2FZOJ%202594--Driving-Straight.html</url>
    <content type="text"><![CDATA[题意： 给出一个(2*m-1)*(2*n-1)的图，要求输出从左下角走到右上角最短距离走法的路径，只能在 ‘-’ 或 ‘|’ 上移动，答案保证有解，有多解输出任一，n,m&lt;=400。 思路： 因为题目要求输出路径，而bfs中如果每个状态都记录到当前状态的路径，可能会TLE或者MLE。 所以考虑先从终点开始bfs出每个点到终点的最短距离，然后再从起点出发bfs一直找 当前点的最短距离-1==下一步的最短距离 的位置就可以回到终点，注意方向的变换。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;using namespace std;char mp[1005][1005];int dis[1005][1005];int m,n;int dx[10]=&#123;-1,0,1,0&#125;; //反向由北到西顺时针 依次为0123int dy[10]=&#123;0,1,0,-1&#125;;int dd[10][10] = &#123;&#123;0, 1, 2, 3&#125;, // F&#123;3, 0, 1, 2&#125;, // L&#123;1, 2, 3, 0&#125; // R&#125;;char dir[10]=&#123;'F','L','R'&#125;; struct node&#123; int x,y; node()&#123;&#125; node(int x,int y):x(x),y(y)&#123;&#125;&#125;; void bfs()&#123; queue&lt;node&gt;q; memset(dis,-1,sizeof(dis)); dis[1][2*n-1]=0; q.push(node(1,2*n-1)); node now; int x,y,px,py; while(!q.empty()) &#123; now=q.front(); q.pop(); px=now.x,py=now.y; //printf("%d %d\n",px,py); for(int i=0;i&lt;4;i++) &#123; x=px+dx[i]; y=py+dy[i]; if(mp[x][y]=='-' || mp[x][y]=='|') &#123; x+=dx[i]; y+=dy[i]; if(dis[x][y]==-1) &#123; dis[x][y]=dis[px][py]+1; q.push(node(x,y)); &#125; &#125; &#125; &#125;&#125; void print()&#123; int statu,x,y,px,py; if(mp[2*m-1][2]=='-' &amp;&amp; dis[2*m-1][1]-1==dis[2*m-1][3]) &#123; puts("E"); px=2*m-1,py=3; statu=1; &#125; else if(mp[2*m-2][1]=='|' &amp;&amp; dis[2*m-1][1]-1==dis[2*m-3][1]) &#123; puts("N"); px=2*m-3,py=1; statu=0; &#125; while(1) &#123; if(dis[px][py]==0) &#123; puts(""); break; &#125; for(int i=0;i&lt;3;i++) &#123; x=px+dx[dd[i][statu]]; y=py+dy[dd[i][statu]]; if(mp[x][y]=='-' || mp[x][y]=='|') &#123; x+=dx[dd[i][statu]]; y+=dy[dd[i][statu]]; if(dis[x][y]==dis[px][py]-1) &#123; printf("%c",dir[i]); statu=dd[i][statu]; px=x,py=y; break; &#125; &#125; &#125; &#125;&#125; int main()&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;m,&amp;n); memset(mp,' ',sizeof(mp)); getchar(); for(int i=1; i&lt;=2*m-1; i++) &#123; gets(mp[i]+1); &#125; bfs(); /*for(int i=1;i&lt;=2*m-1;i+=2) &#123; for(int j=1;j&lt;=2*n-1;j+=2) &#123; printf("%3d",dis[i][j]); &#125;puts(""); &#125;*/ print(); if(T) puts(""); &#125;&#125; /*24 4+-+-+-+|+-+-+-+ |+-+-+-+|+-+-+-+NRFFLLFFRRFF4 4+-+ +-+| | |+ +-+-+| | |+-+-+-+| |+-+-+-+EFFLFF*/]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 110D--Lucky Probability]]></title>
    <url>%2FCodeforces%20110D--Lucky%20Probability.html</url>
    <content type="text"><![CDATA[题意： 出个两个（P,V）范围在1e9的正整数区间，分别从其中随机选出一个数，选出的两个数作为一个新区间的左右端点。要求新区间内的幸运数刚好为k个的概率（幸运数指一个数的数位只有4或7）。 思路： 首先可以dfs找出所有在数据范围内的幸运数，记为L数组，因为数目不多，便可成k段遍历 L数组，每次分别计算【 L[i-1]+1，L[i]】与【Pl，Pr】的线段交集，和【 L[i+k-1]，L[i+k]-1】与【Vl，Vr】的线段交集，将两个结果相乘即是符合[i,i+k-1]区间幸运数的可能情况，同样的还要对P,V两个区间交换后在计算一遍，概率=所有可能情况/(Pr-Pl+1)/(Vr-Vl+1);然后还要注意k==1的情况会重复计算，需特判。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll L[1050];int num=0;void dfs(int len,int p,int v)&#123; if(p==len) &#123; L[++num]=v; return; &#125; dfs(len,p+1,v*10+4); dfs(len,p+1,v*10+7);&#125; ll contain(ll x1,ll y1,ll x2,ll y2)&#123; ll l=max(x1,x2); ll r=min(y1,y2); return r-l+1&gt;0?r-l+1:0;&#125; int main()&#123; for(int len=1;len&lt;=9;len++) dfs(len,0,0); L[0]=0; L[++num]=1000000000; //for(int i=1;i&lt;=num;i++) printf("%d %lld\n",i,L[i]); ll Pl,Pr,Vl,Vr; int k; scanf("%lld%lld%lld%lld%d",&amp;Pl,&amp;Pr,&amp;Vl,&amp;Vr,&amp;k); ll sum=0; for(int i=1;i&lt;=1022-k+1;i++) &#123; int j=i+k-1; sum+=contain(L[i-1]+1,L[i],Pl,Pr)*contain(L[j],L[j+1]-1,Vl,Vr); if(L[i]&gt;Pr) break; &#125; for(int i=1;i&lt;=1022-k+1;i++) &#123; int j=i+k-1; sum+=contain(L[i-1]+1,L[i],Vl,Vr)*contain(L[j],L[j+1]-1,Pl,Pr); if(L[i]&gt;Vr) break; &#125; if(k==1) &#123; for(int i=1;i&lt;=1022;i++) &#123; if(contain(L[i],L[i],Pl,Pr)&amp;&amp;contain(L[i],L[i],Vl,Vr)) sum--; &#125; &#125; printf("%.10f\n",sum*1.0/(Vr-Vl+1)/(Pr-Pl+1));&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2774--Long Long Message]]></title>
    <url>%2FPOJ%202774--Long%20Long%20Message.html</url>
    <content type="text"><![CDATA[题意：给出两个最长长为1e5的字符串，求他们的最长公共子串长度。 思路： 分别将两个字符串预处理出hash值，二分【1-min（lens，lent）】的长度，check函数中每次将长度为mid的hash值记录并检查是否符合条件，是则下边界右移，否则上边界左移。复杂度O(nlogn) 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int N =100000+5; char s[N],t[N];int lens,lent;ull base=233;ull p[N],hs[N],ht[N];ull geths(int l,int r)&#123; return hs[r]-p[r-l+1]*hs[l-1];&#125;ull getht(int l,int r)&#123; return ht[r]-p[r-l+1]*ht[l-1];&#125; int check(int len)&#123; vector&lt;ull&gt;mp; for(int i=1; i&lt;=lens-len+1; i++) &#123; ull tmp=geths(i,i+len-1); mp.push_back(tmp); &#125; sort(mp.begin(),mp.end()); for(int i=1; i&lt;=lent-len+1; i++) &#123; ull tmp=getht(i,i+len-1); if(binary_search(mp.begin(),mp.end(),tmp)) return 1; &#125; return 0;&#125; int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); p[0]=1; for(int i=1; i&lt;N; i++) p[i]=p[i-1]*base; while(~scanf("%s%s",s+1,t+1)) &#123; lens=strlen(s+1); lent=strlen(t+1); for(int i=1; i&lt;=lens; i++) &#123; hs[i]=hs[i-1]*base+s[i]-'a'; &#125; for(int i=1; i&lt;=lent; i++) &#123; ht[i]=ht[i-1]*base+t[i]-'a'; &#125; int l=1,r=min(lens,lent),mid; while(l&lt;=r) &#123; mid=(l+r)/2; if(check(mid)) l=mid+1; else r=mid-1; &#125; printf("%d\n",r); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>字符串hash</tag>
      </tags>
  </entry>
</search>
