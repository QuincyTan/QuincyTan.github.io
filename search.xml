<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019杭电多校 补题日志]]></title>
    <url>%2F2019%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1-%E8%A1%A5%E9%A2%98%E6%97%A5%E5%BF%97.html</url>
    <content type="text"><![CDATA[留点曾经被搞自闭的印象… 第一场1009-String 题意：在n长字符串中选出k长子序列，使子序列中每个字母的出现次数分别在一个区间内，且要求字典序最小 思路：统计后缀和，记录[i..n]还有多少个某字符，记录每个字符出现的所有位置，然后每次对于要放的第i个位置，贪心的从小的字母开始选，如果选定该字符且后面的字符个数符合条件就取该字符放在第i个位置，否则下一个；如果有某一位选不了，就说明不够构造出答案 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970String#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5+5;int cnt[maxn][30];vector&lt;int&gt;pos[30];int p[30],used[30];char s[maxn],ans[maxn];int l[30],r[30];int main()&#123; int k; while(~scanf("%s%d",s,&amp;k))&#123; memset(p,0,sizeof(p)); memset(cnt,0,sizeof(cnt)); memset(used,0,sizeof(used)); for(int i=0;i&lt;26;i++)&#123; pos[i].clear(); &#125; for(int i=0;i&lt;26;i++)&#123; scanf("%d%d",&amp;l[i],&amp;r[i]); &#125; int lens=strlen(s); for(int i=lens-1;i&gt;=0;i--)&#123; for(int j=0;j&lt;26;j++)&#123; cnt[i][j]=cnt[i+1][j]+(s[i]-'a'==j); &#125; &#125; for(int i=0;i&lt;lens;i++)&#123; pos[s[i]-'a'].push_back(i); &#125; for(int i=0;i&lt;26;i++)&#123; p[i]=0; &#125; bool ok=true; int last=-1; for(int i=0;i&lt;k;i++)&#123; ok=false; for(int j=0;j&lt;26;j++)&#123; if(used[j]==r[j]) continue; //限制最多拿该字符取的个数 while(p[j]!=pos[j].size()&amp;&amp;pos[j][p[j]]&lt;=last) p[j]++; //当前位置在上一次选定位置之前 if(p[j]==pos[j].size()) continue; used[j]++; int now = pos[j][p[j]]; int flag=1,need=0; for(int k=0;k&lt;26;k++)&#123; if(cnt[now+1][k]&lt;l[k]-used[k]) flag=0; //后面总字符个数不够 need += max(0,l[k]-used[k]); &#125; if(need &gt; k-i-1) flag=0; //至少需要的字符个数位置不够 if(!flag)&#123; //该字符不可取 used[j]--; &#125; else&#123; ans[i]='a'+j; ok=true; last=now; break; &#125; &#125; if(!ok) break; &#125; ans[k]='\0'; if(!ok) puts("-1"); else printf("%s\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线性基</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营 补题日志]]></title>
    <url>%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E8%A1%A5%E9%A2%98%E6%97%A5%E5%BF%97.html</url>
    <content type="text"><![CDATA[留点曾经被搞自闭的印象… 第一场A-Equivalent Prefixes 题意：给定两个n长整数序列，每个序列不会出现重复元素，问最长的p使得[1,p]区间内的任意子区间都满足[l,r]中的最小值的位置相同 思路：二分答案，对于每个长度递归验证合法性，查询区间最值线段树或ST表维护，总时间复杂度O(nlognlogn) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5+5;int n;int a[maxn],b[maxn];int posa[maxn],posb[maxn];int Mina[maxn&lt;&lt;2],Minb[maxn&lt;&lt;2];void push_up(int o)&#123; Mina[o]=min(Mina[o&lt;&lt;1],Mina[o&lt;&lt;1|1]); Minb[o]=min(Minb[o&lt;&lt;1],Minb[o&lt;&lt;1|1]);&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; Mina[o]=a[l]; Minb[o]=b[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;int query(int k,int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; if(k==1) return Mina[o]; else return Minb[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=INF; if(L&lt;=mid) ret=min(ret,query(k,L,R,lson)); if(R&gt;mid) ret=min(ret,query(k,L,R,rson)); return ret;&#125; bool pd(int l,int r)&#123; if(l&gt;=r) return true; int mina = query(1,l,r,1,n,1); int minb = query(2,l,r,1,n,1); if(posa[mina]!=posb[minb]) return false; int mid = posa[mina]; return pd(l,mid-1)&amp;&amp;pd(mid+1,r);&#125; int main()&#123; while(~scanf("%d",&amp;n))&#123; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); posa[a[i]]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;b[i]); posb[b[i]]=i; &#125; build(1,n,1); int l=1,r=n; while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(pd(1,mid)) l=mid; else r=mid-1; &#125; printf("%d\n",l); &#125;&#125; E-ABBA 题意：有n个”AB”和m个”BA”是由2(n+m)长的字符串中取出的子序列得到，问原字符串有多少种构造可能 思路：dp[i][j]表示当前前缀有i个’A’和j个’B’的合法情况种数，根据合法性再进行转移，dp[n+m][n+m]即为答案 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 2e3+5;const int P = 1e9+7;int f[maxn][maxn];int main() &#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; for(int i=0;i&lt;=n+m;i++)&#123; for(int j=0;j&lt;=n+m;j++)&#123; f[i][j]=0; &#125; &#125; //f[i][j] 表示当前前缀有i个'A'和j个'B'的合法序列种类数 f[0][0]=1; for(int i=0; i&lt;=n+m; i++) &#123; for(int j=0; j&lt;=n+m; j++) &#123; if(i+1&lt;=n || i-n+1&lt;=j) &#123;//AB的A少了或者BA的A少了 f[i+1][j]=(f[i][j]+f[i+1][j])%P; &#125; if(j+1&lt;=m || j-m+1&lt;=i) &#123;//BA的B少了或者AB的B少了 f[i][j+1]=(f[i][j]+f[i][j+1])%P; &#125; &#125; &#125; printf("%d\n",f[n+m][n+m]); &#125;&#125; 第二场D-Kth Minimum Clique 题意：RT,求一张图的第K小团 思路：N最大100，每个团内要求每个点与其他点都有边相连，那么可以对起始每个点作为一个最小独立团进行bfs加点扩大，当新的点满足与当前团内所有点都有边的时候加入该团，bitset标记团内选点和边，K最大1e6，按团的权值出队列最多跑K次，第K次出队列的即为第K小的团，然后每个团记录团内最大结点的id，避免跑出重复的团 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 100+5;struct node&#123; int id; ll w; bitset&lt;maxn&gt;sta; node()&#123;&#125; node(int i,ll w,bitset&lt;maxn&gt;s):id(i),w(w),sta(s)&#123;&#125; bool operator &lt; (const node&amp;hs)const&#123; return w&gt;hs.w; &#125;&#125;;ll w[maxn];bitset&lt;maxn&gt;e[maxn]; int n,k;ll bfs()&#123; if(k==1) return 0; bitset&lt;maxn&gt;sta; priority_queue&lt;node&gt; pq; k--; for(int i=1;i&lt;=n;i++)&#123; sta[i]=1; pq.push(node(i,w[i],sta)); sta[i]=0; &#125; node now; while(!pq.empty())&#123; now = pq.top(); pq.pop(); k--; if(k==0) return now.w; for(int i=now.id+1;i&lt;=n;i++)&#123; if((e[i]&amp;now.sta)==now.sta)&#123; now.sta[i]=1; pq.push(node(i,now.w+w[i],now.sta)); now.sta[i]=0; &#125; &#125; &#125; return -1;&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;w[i]); &#125; char s[maxn][maxn]; for(int i=1;i&lt;=n;i++)&#123; scanf("%s",s[i]+1); for(int j=1;j&lt;=n;j++)&#123; e[i][j]=s[i][j]-'0'; &#125; &#125; printf("%lld\n",bfs());&#125; F-Partition problem 题意：2N个人需要分成两个N人的队，任意两个来自不同队的人配对有个value，求所有队员分别配对后的最大value和 思路：起始将2N个人都放在一队，2^2N枚举哪些人被分到了二队，如果第i个人被调到二队，算代价只需O(n)计算第i个人对整体value和的变化，注意剪枝 123456789101112131415161718192021222324252627282930313233343536373839404142434445#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 30;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n;int vis[30];ll ans,v[maxn][maxn]; void dfs(int i,int cnt,ll sum)&#123; if(cnt==n)&#123; ans=max(ans,sum); return; &#125; if(i-cnt&gt;n) return; //剪枝 前面有i-cnt&gt;n个人在一队肯定不行 //不动 dfs(i+1,cnt,sum); //移到另一队 ll tmp=0; for(int j=1;j&lt;=2*n;j++)&#123; if(!vis[j]) tmp+=v[i][j]; else tmp-=v[i][j]; &#125; vis[i]=1; dfs(i+1,cnt+1,sum+tmp); vis[i]=0;&#125; int main()&#123; n=read(); for(int i=1;i&lt;=2*n;i++)&#123; for(int j=1;j&lt;=2*n;j++)&#123; v[i][j]=read(); &#125; &#125; dfs(1,0,0); printf("%lld\n",ans);&#125; H-Second Large Rectangle 题意：给出一个n*m的只包含01的矩阵，求第二大的只含1的子矩阵大小 思路：对于求第一大，单调栈维护以当前行为底和包含每一列矩阵的左边界和右边界，就可以求出所有可能的最大矩形；对于求第二大，因为有可能是第一大缩小单位宽或者单位高，也可能是和第一大面积相等但位置不同，所以把全部可能情况排序去重查找即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e3+5;struct rec&#123; int h,w,x,y,s; bool operator &lt; (const rec&amp;hs)const&#123; return s&lt;hs.s; &#125; bool operator == (const rec&amp;hs)const&#123; return h==hs.h&amp;&amp;w==hs.w&amp;&amp;x==hs.x&amp;&amp;y==hs.y&amp;&amp;s==hs.s; &#125;&#125;a[maxn*maxn*3]; char mp[maxn][maxn];int h[maxn],L[maxn],R[maxn];int main() &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf("%s",mp[i]+1); &#125; int cnt=0; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; if(mp[i][j]=='1') h[j]++; else h[j]=0; &#125; for(int j=1; j&lt;=m; j++) &#123; L[j]=j; while(L[j]&gt;1&amp;&amp;h[j]&lt;=h[L[j]-1]) L[j]=L[L[j]-1]; &#125; for(int j=m; j&gt;=1; j--) &#123; R[j]=j; while(R[j]&lt;m&amp;&amp;h[j]&lt;=h[R[j]+1]) R[j]=R[R[j]+1]; &#125; for(int j=1;j&lt;=m;j++)&#123; int hh=h[j],ww=R[j]-L[j]+1,x=i,y=L[j],s=hh*ww; a[cnt++]=rec&#123;hh,ww,x,y,s&#125;; a[cnt++]=rec&#123;hh-1,ww,x,y,s-ww&#125;; a[cnt++]=rec&#123;hh,ww-1,x,y,s-hh&#125;; &#125; &#125; sort(a,a+cnt); for(int i=cnt-1;i&gt;=0;i--)&#123; if(!(a[i]==a[i-1]))&#123; printf("%d\n",a[i-1].s); break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>二分</tag>
        <tag>dp</tag>
        <tag>分治</tag>
        <tag>单调栈</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC2019女生专场D-Tree]]></title>
    <url>%2FCCPC2019%E5%A5%B3%E7%94%9F%E4%B8%93%E5%9C%BAD-Tree.html</url>
    <content type="text"><![CDATA[今天花一天时间好好学习了下树链剖分，之前听上去很高大上的样子，上半年寒假集训学长讲的时候还完全不懂，现在学着学着就很好理解了。刚好这道最近要补的题就是个裸题，拿来练练手。 原题链接 如果想区间维护更新的话因为是开根号，不满足加减乘幂等运算性质，所以只好单点更新，但这样复杂度会是O(qnlogn)？实际上，因为ai最大1e9，对其在在10次开根号的操作下会变为1，然后就不会变了，所以维护一个区间最大值，每次更新看是否最大值&lt;=1，是的话线段树就不要递归向下更新了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;typedef long long ll;const int maxn = 1e5+10;const int maxm = 1e5+10;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct edge&#123; int next,to;&#125;e[maxm*2];int head[maxn],cnt;void addedge(int u,int v)&#123; e[++cnt]=edge&#123;head[u],v&#125;; head[u]=cnt;&#125;int n,q,val[maxn];int fa[maxn],deep[maxn],siz[maxn],son[maxn],rk[maxn],top[maxn],id[maxn];void dfs1(int u,int pre,int dep)&#123; fa[u]=pre;deep[u]=dep;siz[u]=1; for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v==pre)continue; dfs1(v,u,dep+1); siz[u]+=siz[v]; if(siz[v]&gt;siz[son[u]])son[u]=v; &#125;&#125;void dfs2(int u,int t)&#123; top[u]=t;id[u]=++cnt;rk[cnt]=u; if(!son[u])return; dfs2(son[u],t); for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v!=son[u]&amp;&amp;v!=fa[u])dfs2(v,v); &#125;&#125;ll Max[maxn&lt;&lt;2],Sum[maxn&lt;&lt;2];void push_up(int o)&#123; Sum[o]=Sum[o&lt;&lt;1]+Sum[o&lt;&lt;1|1]; Max[o]=max(Max[o&lt;&lt;1],Max[o&lt;&lt;1|1]);&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; Max[o]=Sum[o]=val[rk[l]]; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;void update(int L,int R,int l,int r,int o)&#123; if(Max[o]&lt;=1) return; if(l==r)&#123; Sum[o]=(int)sqrt(Sum[o]); Max[o]=Sum[o]; return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) update(L,R,lson); if(R&gt;mid) update(L,R,rson); push_up(o);&#125;ll querysum(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Sum[o]; &#125; int mid=(l+r)&gt;&gt;1;ll ret=0; if(L&lt;=mid) ret+=querysum(L,R,lson); if(R&gt;mid) ret+=querysum(L,R,rson); return ret;&#125;void PathUpdate(int x,int y)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); update(id[top[x]],id[x],1,n,1); x=fa[top[x]]; &#125; if(id[x]&gt;id[y]) swap(x,y); update(id[x],id[y],1,n,1);&#125;ll PathQuery(int x,int y)&#123; ll ret=0; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); ret+=querysum(id[top[x]],id[x],1,n,1); x=fa[top[x]]; &#125; if(id[x]&gt;id[y])swap(x,y); ret+=querysum(id[x],id[y],1,n,1); return ret;&#125;int main()&#123; n=read(),q=read(); for(int i=1;i&lt;=n;i++) val[i]=read(); cnt=0; for(int i=1;i&lt;=n;i++) head[i]=0; for(int i=0;i&lt;n-1;i++)&#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; cnt=0; dfs1(1,0,1); dfs2(1,1); build(1,n,1); while(q--)&#123; int op=read(),x=read(),y=read(); if(op==0)&#123; PathUpdate(x,y); &#125; else&#123; printf("%lld\n",PathQuery(x,y)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客小白月赛16&&CodeForces1191 补题]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B16-CodeForces1191-%E8%A1%A5%E9%A2%98.html</url>
    <content type="text"><![CDATA[又是自闭的一天… D-小阳买水果求序列连续子段和大于0的最长子序列长度 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3ftypedef long long ll;using namespace std;const int maxn = 2e6+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int ans,sum,n;int a[maxn];int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; //枚举r二分l (l,r] int x=read(); sum+=x; a[i]=min(a[i-1],sum); if(sum-a[i-1]&lt;=0) continue; int l=0,r=i-1; while(l&lt;r)&#123; int m=(l+r)&gt;&gt;1; if(sum-a[m]&gt;0) r=m; else l=m+1; &#125; ans=max(ans,i-l); &#125; printf("%d\n",ans);&#125; F-小石的妹子拓扑思想+线段树维护区间最大值 发现用数组数组常数小，代码量也少 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1#define INF 0x3f3f3f3ftypedef long long ll;using namespace std;const int maxn = 1e5+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct node&#123; int a,b,id; bool operator &lt; (const node&amp;hs)const&#123; return a&gt;hs.a; &#125;&#125;p[maxn];int n;int bb[maxn],ans[maxn];int Max[maxn&lt;&lt;2];void update(int p,int v,int l,int r,int o)&#123; if(l==r)&#123; Max[o]=v; return; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) update(p,v,lson); else update(p,v,rson); Max[o]=max(Max[o&lt;&lt;1],Max[o&lt;&lt;1|1]);&#125;int querymax(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Max[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=-1; if(L&lt;=mid) ret=max(ret,querymax(L,R,lson)); if(R&gt;mid) ret=max(ret,querymax(L,R,rson)); return ret;&#125;int main()&#123; n=read(); for(int i=0;i&lt;n;i++)&#123; int a=read(),b=read(); bb[i]=b; p[i]=node&#123;a,b,i&#125;; &#125; sort(p,p+n); sort(bb,bb+n); //离散化bi for(int i=0;i&lt;n;i++)&#123; p[i].b=lower_bound(bb,bb+n,p[i].b)-bb+1; &#125; //因为已经对ai排序,满足aj&gt;ai,则只要考虑bj&gt;bi的最大排名即可 for(int i=0;i&lt;n;i++)&#123; ans[p[i].id]=querymax(p[i].b,n,1,n,1)+1; update(p[i].b,ans[p[i].id],1,n,1); &#125; for(int i=0;i&lt;n;i++) printf("%d\n",ans[i]);&#125; H-小阳的贝壳$gcd(a,b,c)=gcd(a,b-a,c-b)=gcd(a,gcd(b-a,c-b));$ $gcd([l,r])=gcd(a[l],gcd([l+1,r]))$ a[l]=$\sum_{i=1}^{l}f[i]$,f[i]为差分数列f[i]=a[i]-a[i-1] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1#define INF 0x3f3f3f3ftypedef long long ll;using namespace std;const int maxn = 1e5+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int a[maxn],f[maxn];int Sum[maxn&lt;&lt;2],Max[maxn&lt;&lt;2],Gcd[maxn&lt;&lt;2];void push_up(int o)&#123; Sum[o]=Sum[o&lt;&lt;1]+Sum[o&lt;&lt;1|1]; Max[o]=max(Max[o&lt;&lt;1],Max[o&lt;&lt;1|1]); Gcd[o]=__gcd(Gcd[o&lt;&lt;1],Gcd[o&lt;&lt;1|1]);&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; Sum[o]=f[l]; Max[o]=Gcd[o]=abs(Sum[o]); return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;void update(int p,int v,int l,int r,int o)&#123; if(l==r)&#123; Sum[o]+=v; Max[o]=Gcd[o]=abs(Sum[o]); return; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) update(p,v,lson); else update(p,v,rson); push_up(o);&#125;int querymax(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Max[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=0; if(L&lt;=mid) ret=max(ret,querymax(L,R,lson)); if(R&gt;mid) ret=max(ret,querymax(L,R,rson)); return ret;&#125;int querysum(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Sum[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=0; if(L&lt;=mid) ret+=querysum(L,R,lson); if(R&gt;mid) ret+=querysum(L,R,rson); return ret;&#125;int querygcd(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return Gcd[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=0; if(L&lt;=mid) ret=__gcd(ret,querygcd(L,R,lson)); if(R&gt;mid) ret=__gcd(ret,querygcd(L,R,rson)); return ret;&#125;int main()&#123; int n=read(),m=read(); for(int i=1;i&lt;=n;i++)&#123; a[i]=read(); f[i]=a[i]-a[i-1]; &#125; build(1,n,1); while(m--)&#123; int op=read(),l=read(),r=read(); if(op==1)&#123; int x=read(); update(l,x,1,n,1); if(r+1&lt;=n) update(r+1,-x,1,n,1); &#125; else if(op==2)&#123; if(l==r) puts("0"); else printf("%d\n",querymax(l+1,r,1,n,1)); &#125; else&#123; if(l==r) printf("%d\n",querysum(1,l,1,n,1)); else printf("%d\n",__gcd(querysum(1,l,1,n,1),querygcd(l+1,r,1,n,1))); &#125; &#125;&#125; 复习一下线段树~好久没写的样子 C-Tokitsukaze and Discard Items123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5+5;ll a[maxn];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); ll n,m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;a[i]; &#125; int ans=0,cnt=0; int i=1; while(i&lt;=m)&#123; ll r = ((a[i]-cnt-1)/k+1)*k+cnt; //计算第一个特殊数所在页上限 while(i&lt;=m&amp;&amp;a[i]&lt;=r)&#123; cnt++; i++; &#125; ans++; &#125; cout&lt;&lt;ans&lt;&lt;'\n';&#125; D-Tokitsukaze, CSL and Stone Game12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5+5;int a[maxn];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int n;cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; sort(a,a+n); if(n&gt;=2&amp;&amp;a[0]==0&amp;&amp;a[1]==0)&#123;//注意特判 puts("cslnb"); return 0; &#125; ll sum=0; int has2=0;//相同数对的个数 for(int i=0;i&lt;n;i++)&#123; sum+=a[i]-i; //贪心选取,要使不重复,最后每堆数目留下的肯定是0,1,2,... if(i&lt;n-1&amp;&amp;a[i]==a[i+1]) has2++; if(i&gt;0&amp;&amp;i&lt;n-1&amp;&amp;a[i]==a[i+1]&amp;&amp;a[i-1]+1==a[i])&#123;//x,x+1,x+1这种情况无论怎么取都先手输 puts("cslnb"); return 0; &#125; &#125; if((sum&amp;1)==0 || has2&gt;=2) puts("cslnb"); else puts("sjfnb");&#125; 补完Div2的CD发现真的不难，因为读错题和读题太慢很影响心态，下次还得细心点啊]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>二分</tag>
        <tag>树状数组</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法学习(转)]]></title>
    <url>%2F%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%BD%AC.html</url>
    <content type="text"><![CDATA[b站上无意翻到新疆小姐姐莎依拜 (Sahiba Anwar)的英语语法视频《一堂课让你懂得英语语法百分之九十五》，全长103分钟，语速较慢，2倍速下不到1小时可以看完。中学上的语法课都是零零散散的，整体总结一下，感觉知识体系清晰了很多。（BTW，小姐姐声音真好听） 概要 语法是一座体系，是一座大楼，但是中学期间学习的语法是零散的，我们学习的内容都是砖块，无法看到英语语法的大楼。这个视频能够让我们快速认识语法大楼的全貌（相当于理解了95%）。剩余的5%，都是小碎砖，再去细地探索。视频作者是新疆小姐姐莎依拜 (Sahiba Anwar)。本篇内容完全来自视频。 结构分类 按照结构分类时，所有英文句子能够分成三类： 简单句： 1主语 + 谓语 + 宾语 并列句： 1234主谓宾， 并列词 + 主谓宾 ————————————————⟶ ↓ ↳ e.g. and,or,but etc. ↓(简单句) (简单句) |-----------同等地位，并列关系------------| 复合句： 123主谓宾， 从句引导词 + 主谓宾 ————————————————⟶ ↓ ↳ e.g. which,when,where... ↓主句(主导地位，大哥，简单句) 从句(从属地位，小弟，简单句) 从句类型： 名词性从句（名词） 定语从句（形容词） 状语从句（副词） 主语：subject → 动作的发出者 ⇒ 我谓语： verb → 动作 ⇒ 踢宾语： object → 动作的承受者 ⇒ 球 主谓宾和它的五个兄弟（简单句的六个基本句型） 所有的英文句子无外乎主谓宾的问题，把主谓宾研究清楚了，把所有句子就搞清楚了。 句型112主（名） 谓（及物） 宾（名） I play games. 句型2123主（名） 谓（不及物） Spring comes. ↳此动作无承受者，所以没有宾语 句型312345678主（名） 系 表 ↳共3种 （名词；形容词；不定式；介宾[介词+名词]）&lt;1&gt; Be动词：am, is, are, was, were&lt;2&gt; 感官动词（五官）：look, sound, smell, taste, feel&lt;3&gt; 变化动词：become, turn, go, get, grow&lt;4&gt; 静止动词：stay, remain, keep* 不定式[to do], 但是如果遇到to + 动词ing，这里的to是介词。 句型4123 主 谓 宾 宾（名） (及物) （名） （名） I give you money 句型512345678主 谓 宾 补（名） （及物） （名） （1.形容词 2.不定式）|----结构完成，意思不完整---| |---补充说明意思---|1. The music makes me sad.2. He tells me to go. * He helps me (to) understand the problem. 特殊 句型61234567There be 句型，表达&quot;存在&quot;。There be 名词There is a dog.There be 名词 介宾There is a dog under the tree. 从句：引导词 + 主谓宾（或其五个兄弟）名词性从句 主语从句 宾语从句 表语从句 同位语从句 一模一样的句子，只不过位置不同，所以名称不同。 12345主 谓 宾语(名词) (及物动词) (名词)名词性从句 名词性从句 ↓ ↓主语从句 宾语从句 名词性从句常用的引导词有:that, whether, what 12345678e.g. 名词性从句： that he likes football (引导词) (名) (动) (名) | |------主谓宾(句子)-------| ⇒ 不能做句子成分* |-----------------------| | ⇓ ↲ 降级成 名词（可以做句子成分）* 为什么不能做句子成分？英文里一个句子只能有一个谓语动词，否则句子不成立。 主语从句 1234That he likes football surprised us.--------------------- ▲ ▲ 名词 及物动词 名词 （主语） （谓语）（宾语） 宾语从句 1234 He said that he likes football. ▲ ▲ ---------------------- 名词 及物动词 名词（主语）（谓语） （宾语） 表语从句 1234 The fact is that he likes football. -------- ▲ ▲ 名词 be动词 名词（主语） （系语） （表语） 同位语从句什么是同位语？同位语起解释说明名词的作用，和其解释的名词相等；同位语是[名词] 123456789101112如： 主， 同位语， 谓宾. Yusuf, a Uyghur man, loves spring. 主谓宾， 同位语 . Yusuf loves spring, on of the four season.上面的同位语是以插入语的形式。The fact that he likes football surprised us.-------- ---------------------- ▲ ▲ 名词 同位语从句 动词（谓） 名词（宾）He states the fact that he likes football. ▲ ▲ ▲ ------------------------* 同位语从句的引导词只有that。 定语从句什么是定语？修饰限定名词，红红的花定语Ⅰ：形容词（短一些）定语Ⅱ：短语或从句（长一些） 1234567891011121314151617181920**为什么要分两种呢**？因为英语忌讳头重脚轻，定语稍微长一点，马上往后挪。 定Ⅰ 主 定Ⅱ 谓 定Ⅰ 宾 定Ⅱ （名） （动） （名） A beautiful girl shared a fascinating story. --------- ▲ ----------- ▲ 定Ⅰ(形) 定Ⅰ(形) A girl from Mars shared a story about her people. ▲ --------- ▲ --------------- 定Ⅱ(介宾短语) 定Ⅱ(介宾短语) A task to tackle is the potential crisis. ▲ --------- --------- ▲ 定Ⅱ(不定式) 定Ⅰ(形) A girl who likes spring shared a story which moved us. ▲ ---------------- ▲ --------------- (定语从句) （定语从句） 状语从句 什么是状语？ 副词：修饰动词:walk slowly； 修饰形容词：slightly higher； 起副词作用的句子：状语从句 按作用划分： 时间状语(从句)：何时？ 地点状语(从句)：在哪？ 原因状语(从句)：为啥？因为…； 条件状语(从句)：在什么情况下？如果…；只要…；只有…； 目的状语(从句)：为了啥？为了…；这样就能…； 结果状语(从句)：导致了啥？结果…；以至于…； 让步状语(从句)：转折的前奏，强调前的东西不重要。虽然…； 方式状语(从句)：怎么做的（发生的）？用…；通过…； 状语从句是存在于简单句（主谓宾）之外的。 例子： 1234Yusuf smiles happily. 副词修饰动词，出现在动词之后Yusuf quickly understood. 副词修饰动词，出现在动词之前She is strikingly beautiful. 副词修饰形容词，表示程度：强He is pretty tall. 副词修饰形容词，表示程度：弱 123456789101112131415He came yesterday. 时间副词，位置灵活Yesterday he came.He called me when I was sleeping. 时间状语从句He celebrated hes birthday at school. 地点副词，位置灵活At school he celebrated his birthday.We met where we used to go for a walk. 地点状语从句He likes spring for its beauty.He likes srping for it is beautiful.He likes spring because it is beautiful.He likes spring as it is beautiful.He likes spring since it is beautiful. 都是从句，原因除了since前后都可以外，其他的都靠后Because开头的不是状语从句，而是一个名词性句子 12If you win, there will be a reward. 条件状语从句As long as you win, there will be a reward. 条件状语从句 1234I study for my well-being. I don&apos;t spend extra to save money. (to is short for in order to)I don&apos;t spend extra in order to save money. (in order to 可以提前)I don&apos;t spend extra so that I can save money. 目的状语从句 12He tried so hard that he finally succeeded. 结果状语从句这里的so...that...和目的状语从句的so that不同，目的状语从句中的so that不能加任何东西，so that共同引导。 12Although you have a point there, I don&apos;t agree with your proposal.让步状语从句，不需转折词。重点在转折后面的东西。 1234567I learned English through an online course.I contact my friends via Wechat.I draw with my pen.I found differences by contasting the two.She looks at me as if she knows me.He finished the work as I told him to.方式状语 三个特殊句式（对六种基本句型的操纵） 强调句 12345678He hit me.It was him that hit me.I learned about this project through this site.It was through this site that I learned about this project.It is 名 that 动(名)It is 介宾 that 主谓(宾) 倒装句 1234567891011正常句序：主 谓 (宾)倒装句序：谓 主 (宾） -&gt; 强调加强语气的作用正常：We can win only when we try harder. (情态动词+实意动词 才算一个谓语)倒装：Only when we try harder can we win. 部分倒装正常：The bus comes.倒装： Here comes the bus.正常：The Queen live long!倒装：Long live The Queen! 虚拟语句 假设一个有可能发生的事情–&gt;条件状语If it rains, the event will be canceled. (主将从现) 假设一件不可能发生的事-&gt;虚拟语气现在不可能： If I were a boy, I would be a soldier. (过去时)过去不可能（和既成事实相反）If I had studied English, it would have been easier now.If I hadn’t had that extra cake, I wouldn’t have been feeling guilty.(过去完成) （过去时 + 完成时） 时态 一般（习惯性） 进行（正在发生） 完成（有结果） 完成进行时（持续性：一直在做） 语态 主动语态 1I finished my task. 被动语态 1My task is finished. 非谓语分词： 现在分词（doing）：和主句主语为主动关系 过去分词（done）：和主句主语为被动关系 1234567The boy was lost, failing to find the way back home. ---------------------------------- 非谓语The boy was lost, failed by his poor memory. ------------------------- 非谓语 至此，语法大楼搭建结束，赶紧去拾小砖块。]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-1182C Beautiful Lyrics]]></title>
    <url>%2FCodeforces-1182C-Beautiful-Lyrics.html</url>
    <content type="text"><![CDATA[原题链接 题意： 给出最多1e5个字符串，问求最多能构成多少个字符串四元组，要求四元组的前两个字符串中的元音字母个数相同，后两个元音字母个数相同且还要每个字符串的最后一个元音字母相同 思路： 先对所有字符串用STL嵌套分类，把符合后两个字符串条件的优先先分到一块，然后剩下的元音字母数量相同的在分到一块，最后两两合并 #auto &amp; 表示可以修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;bool isvowel(char ch)&#123; return (ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u');&#125;int getcount(string &amp;str)&#123; int res=0; for(auto ch:str) if(isvowel(ch)) res++; return res;&#125;char getlast(string &amp;str)&#123; for(int i=str.length()-1;i&gt;=0;i--)&#123; if(isvowel(str[i])) return str[i]; &#125;&#125;unordered_map&lt;int,unordered_map&lt;char,vector&lt;string&gt;&gt;&gt; all;vector&lt;pair&lt;string,string&gt;&gt; both1,both2,ans;string a,b;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; string str; cin&gt;&gt;str; all[getcount(str)][getlast(str)].push_back(str); &#125; for(auto &amp;same_count:all)&#123; for(auto &amp;same_last:same_count.second)&#123; while(same_last.second.size()&gt;=2)&#123; a=same_last.second.back(); same_last.second.pop_back(); b=same_last.second.back(); same_last.second.pop_back(); both2.push_back(&#123;a,b&#125;); &#125; &#125; vector&lt;string&gt;rest; for(auto &amp;same_last:same_count.second)&#123; if(same_last.second.size())&#123; rest.push_back(same_last.second.back()); &#125; &#125; while(rest.size()&gt;=2)&#123; a=rest.back(); rest.pop_back(); b=rest.back(); rest.pop_back(); both1.push_back(&#123;a,b&#125;); &#125; &#125; pair&lt;string,string&gt; b1,b2; while(both1.size()&amp;&amp;both2.size())&#123; b1=both1.back(); both1.pop_back(); b2=both2.back(); both2.pop_back(); ans.push_back(&#123;b1.first,b2.first&#125;); ans.push_back(&#123;b1.second,b2.second&#125;); &#125; while(both2.size()&gt;=2)&#123; b1=both2.back(); both2.pop_back(); b2=both2.back(); both2.pop_back(); ans.push_back(&#123;b1.first,b2.first&#125;); ans.push_back(&#123;b1.second,b2.second&#125;); &#125; cout&lt;&lt;ans.size()/2&lt;&lt;'\n'; for(auto s:ans)&#123; cout&lt;&lt;s.first&lt;&lt;' '&lt;&lt;s.second&lt;&lt;'\n'; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>STL</tag>
        <tag>贪心</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[湘潭大学2019程序设计实践]]></title>
    <url>%2F%E6%B9%98%E6%BD%AD%E5%A4%A7%E5%AD%A62019%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5.html</url>
    <content type="text"><![CDATA[抄袭一时爽，查重火葬场因考前会查重，故仅提供思路参考，代码后续补上，有问题欢迎下方评论留言 ericxie官方解析点这里 食用此篇博文代码前建议上网自学一些C++STL容器(set、vector、map等)的用法 1262 Fish贪心，优先队列维护每个池塘能钓到鱼的数量即可，当前池塘有最多鱼的池塘优先出队列 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e3+5;struct fish&#123; int a,b; fish()&#123;&#125; fish(int a,int b):a(a),b(b)&#123;&#125; bool operator &lt; (const fish &amp;hs)const&#123; return a&lt;hs.a; &#125;&#125;;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; priority_queue&lt;fish&gt;pq; int n,m,a,b; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;a,&amp;b); pq.push(fish(a,b)); &#125; int ans=0; fish now; while(m--)&#123; now=pq.top(); pq.pop(); ans+=now.a; now.a=max(0,now.a-now.b); pq.push(now); &#125; printf("%d\n",ans); &#125;&#125; 1271 Color结论：n*m-(x的种类数)*(y的种类数) 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e3+5;set&lt;int&gt;x,y;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; x.clear(); y.clear(); int n,m,k,a,b; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=0;i&lt;k;i++)&#123; scanf("%d%d",&amp;a,&amp;b); x.insert(a); y.insert(b); &#125; printf("%d\n",n*m-x.size()*y.size()); &#125;&#125; 1163 ASCLL直接模拟，输出%05X和%02X即带前导0的十六进制，回车的ASCLL码也要输出，注意输出空格和回车的地方 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+5;string s;int main()&#123; char ch; while(ch=getchar())&#123; if(ch==-1) break; else s+=ch; &#125; int id=0,cnt=0; int lens=s.length(); for(int i=0;i&lt;lens;i++)&#123; if(cnt==0) printf("%05X ",id++); printf("%02X",(int)s[i]); cnt++; if(i!=lens-1)&#123; if(cnt!=16) printf(" "); else&#123; cnt=0; printf("\n"); &#125; &#125; &#125;&#125; 1243 Bob’s Password枚举九个数字会非法的情况即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+5;char s[10];int vis[10];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; for(int i=0;i&lt;10;i++) vis[i]=0; scanf("%s",s); int lens=strlen(s); bool ok=true; for(int i=0;i&lt;lens;i++)&#123; int a=s[i]-'0'; if(i==0)&#123; vis[a]=1; continue; &#125; if(a==1)&#123; if((!vis[2]&amp;&amp;s[i-1]=='3')||(!vis[4]&amp;&amp;s[i-1]=='7')||(!vis[5]&amp;&amp;s[i-1]=='9'))&#123; ok=false; break; &#125; &#125; else if(a==2)&#123; if(!vis[5]&amp;&amp;s[i-1]=='8')&#123; ok=false; break; &#125; &#125; else if(a==3)&#123; if((!vis[2]&amp;&amp;s[i-1]=='1')||(!vis[5]&amp;&amp;s[i-1]=='7')||(!vis[6]&amp;&amp;s[i-1]=='9'))&#123; ok=false; break; &#125; &#125; else if(a==4)&#123; if(!vis[5]&amp;&amp;s[i-1]=='6')&#123; ok=false; break; &#125; &#125; else if(a==6)&#123; if(!vis[5]&amp;&amp;s[i-1]=='4')&#123; ok=false; break; &#125; &#125; else if(a==7)&#123; if((!vis[4]&amp;&amp;s[i-1]=='1')||(!vis[5]&amp;&amp;s[i-1]=='3')||(!vis[8]&amp;&amp;s[i-1]=='9'))&#123; ok=false; break; &#125; &#125; else if(a==8)&#123; if(!vis[5]&amp;&amp;s[i-1]=='2')&#123; ok=false; break; &#125; &#125; else if(a==9)&#123; if((!vis[5]&amp;&amp;s[i-1]=='1')||(!vis[6]&amp;&amp;s[i-1]=='3')||(!vis[8]&amp;&amp;s[i-1]=='7'))&#123; ok=false; break; &#125; &#125; vis[a]=1; &#125; if(ok) puts("Yes"); else puts("No"); &#125;&#125; 1246 Matrix Transposition看半天题意，n,m没用，将输入的x看做y，输入的y看做x，反过来按y优先排序即可 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+5;struct node&#123; int x,y,v; node()&#123;&#125; node(int x,int y,int v):x(x),y(y),v(v)&#123;&#125; bool operator &lt; (const node &amp;b) const&#123; if(y!=b.y) return y&lt;b.y; return x&lt;b.x; &#125;&#125;p[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,m,k; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=0;i&lt;k;i++)&#123; int x,y,v; scanf("%d%d%d",&amp;x,&amp;y,&amp;v); p[i]=node(x,y,v); &#125; sort(p,p+k); for(int i=0;i&lt;k;i++)&#123; printf("%d %d %d\n",p[i].y,p[i].x,p[i].v); &#125; puts(""); &#125;&#125; 1248 Alice and Bob直接模拟，将1作为数字7处理会很好写很多，注意求和依然是+1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;int cnta[10],cntb[10];int suma,sumb;bool pd1()&#123; int a=0,b=0; for(int i=2;i&lt;=7;i++)&#123; if(cnta[i]==3)a=i; if(cntb[i]==3)b=i; &#125; if(a||b)&#123; if(a&amp;&amp;b)&#123; if(a&gt;b) puts("Alice"); else if(a&lt;b) puts("Bob"); else puts("Draw"); &#125; else if(a) puts("Alice"); else if(b) puts("Bob"); return true; &#125; return false;&#125;bool pd2()&#123; int a=0,aa=0,b=0,bb=0; for(int i=2;i&lt;=7;i++)&#123; if(cnta[i]==2)a=i; if(cntb[i]==2)b=i; if(cnta[i]==1)aa=i; if(cntb[i]==1)bb=i; &#125; if(a||b)&#123; if(a&amp;&amp;b)&#123; if(a&gt;b) puts("Alice"); else if(a&lt;b) puts("Bob"); else &#123; if(aa&gt;bb) puts("Alice"); else if(aa&lt;bb) puts("Bob"); else puts("Draw"); &#125; &#125; else if(a) puts("Alice"); else if(b) puts("Bob"); return true; &#125; return false;&#125;bool pd3()&#123; if(suma&gt;sumb) puts("Alice"); else if(suma&lt;sumb) puts("Bob"); else puts("Draw"); return true;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; for(int i=0;i&lt;10;i++) cnta[i]=cntb[i]=0; suma=0,sumb=0; for(int i=0;i&lt;3;i++)&#123; int x; scanf("%d",&amp;x); suma+=x; if(x==1) x=7; cnta[x]++; &#125; for(int i=0;i&lt;3;i++)&#123; int x; scanf("%d",&amp;x); sumb+=x; if(x==1) x=7; cntb[x]++; &#125; if(pd1()); else if(pd2()); else if(pd3()); &#125;&#125; 1251 Colombian Number简单数学，注意到[1,1000000000]区间内数位和在[1,81]内，所以只需在区间[n-81,n]内枚举k看是否能使k+sum(k)==n成立即可 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int calc(int x)&#123; int sum=0; while(x)&#123; sum+=x%10; x/=10; &#125; return sum;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); bool ok=false; for(int i=max(1,n-100);i&lt;n;i++)&#123; if(i+calc(i)==n)&#123; ok=true; break; &#125; &#125; if(ok) puts("No"); else puts("Yes"); &#125;&#125; 1253 Robot贪心，如果在中途转弯肯定不如每次从头走到尾，可以证明最多转n-1次，时间复杂度O($n^2$) 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3+5;int vis[maxn],a[maxn];int main()&#123; int n; while(~scanf("%d",&amp;n))&#123; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; int cnt=0,ans=0; while(1)&#123; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i]&amp;&amp;cnt&gt;=a[i])&#123; vis[i]=1; cnt++; &#125; &#125; if(cnt==n) break; else ans++; for(int i=n;i&gt;=1;i--)&#123; if(!vis[i]&amp;&amp;cnt&gt;=a[i])&#123; vis[i]=1; cnt++; &#125; &#125; if(cnt==n) break; else ans++; &#125; printf("%d\n",ans); &#125;&#125; 1252 Matrix Word统计每个字符在每一行每一列的出现次数，最后判断是否都为1即可 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;char s[maxn][maxn];int x[maxn][26],y[maxn][26];int main()&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; memset(x,0,sizeof(x)); memset(y,0,sizeof(y)); for(int i=1;i&lt;=n;i++)&#123; scanf("%s",s[i]+1); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; x[i][s[i][j]-'a']++; y[j][s[i][j]-'a']++; &#125; &#125; string ans=""; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; if(x[i][s[i][j]-'a']==1 &amp;&amp; y[j][s[i][j]-'a']==1) ans+=s[i][j]; &#125; &#125; cout&lt;&lt;ans&lt;&lt;'\n'; &#125;&#125; 1261 Duplicate Elementsunordered_map或map或set记录每个值是否出现即可,当然也可以用其他的哈希方法 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;using namespace std;const int maxn = 1e4+5;unordered_map&lt;int,int&gt;mp;vector&lt;int&gt;ans;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int main()&#123; int T;T=read(); while(T--)&#123; mp.clear(); int n;n=read(); ans.clear(); for(int i=0;i&lt;n;i++)&#123; int x;x=read(); if(mp.find(x)==mp.end())&#123; ans.push_back(x); mp[x]=1; &#125; &#125; for(int i=0;i&lt;ans.size();i++)&#123; printf("%d%c",ans[i],i==ans.size()-1?'\n':' '); &#125; &#125;&#125; 1263 矩形面积的并哪一年的蓝桥杯原题来着，求出相交矩形的边界,判掉不会相交的情况，在不知道位置相对位置的情况下计算面积注意取绝对值，面积并=两矩形面积和-两矩形面积交 l=max(min(x1,x2),min(x3,x4));r=min(max(x1,x2),max(x3,x4));d=max(min(y1,y2),min(y3,y4));u=min(max(y1,y2),max(y3,y4)); 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int main()&#123; int x1,y1,x2,y2,x3,y3,x4,y4,a,b,c,d; while(~scanf("%d%d%d%d%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;x3,&amp;y3,&amp;x4,&amp;y4))&#123; a=max(min(x1,x2),min(x3,x4)); b=min(max(x1,x2),max(x3,x4)); c=max(min(y1,y2),min(y3,y4)); d=min(max(y1,y2),max(y3,y4)); int sum=abs(x2-x1)*abs(y2-y1)+abs(x4-x3)*abs(y4-y3); if(a&gt;=b||c&gt;=d) printf("%d\n",sum); else printf("%d\n",sum-(b-a)*(d-c)); &#125;&#125; 1268 鞍点输入的时候就记录每行每列的最值即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int minx[maxn],miny[maxn],maxx[maxn],maxy[maxn];int a[maxn][maxn];struct Ans&#123; int x,y,v; Ans()&#123;&#125; Ans(int x,int y,int v):x(x),y(y),v(v)&#123;&#125;&#125;ans[maxn*maxn];inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int main()&#123; int T;T=read(); while(T--)&#123; int n,m;n=read(),m=read(); for(int i=0;i&lt;n;i++) minx[i]=1001,maxx[i]=-1; for(int j=0;j&lt;m;j++) miny[j]=1001,maxy[j]=-1; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; a[i][j]=read(); minx[i]=min(minx[i],a[i][j]); miny[j]=min(miny[j],a[i][j]); maxx[i]=max(maxx[i],a[i][j]); maxy[j]=max(maxy[j],a[i][j]); &#125; &#125; int cnt=0; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if((a[i][j]==minx[i]&amp;&amp;a[i][j]==maxy[j])||(a[i][j]==maxx[i]&amp;&amp;a[i][j]==miny[j]))&#123; ans[cnt++]=Ans(i,j,a[i][j]); &#125; &#125; &#125; if(!cnt) puts("None"); else&#123; printf("%d\n",cnt); for(int i=0;i&lt;cnt;i++)&#123; printf("%d %d %d\n",ans[i].x,ans[i].y,ans[i].v); &#125; &#125; &#125;&#125; 1272 Robot统计L,R,U,D的个数，假定其中有一种没有，那么剩下三种中使多余的那一种变为另外两种的其中一种看是否这两种数目相等 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char s[205]; int L,R,U,D; while(~scanf(&quot;%s&quot;,s))&#123; L=R=U=D=0; int lens=strlen(s); for(int i=0;i&lt;lens;i++)&#123; if(s[i]==&apos;L&apos;) L++; else if(s[i]==&apos;R&apos;) R++; else if(s[i]==&apos;U&apos;) U++; else D++; &#125; bool ok=false; if(!L)&#123; if(R+U==D||R+D==U) ok=true; &#125; else if(!R)&#123; if(L+U==D||L+D==U) ok=true; &#125; else if(!U)&#123; if(R+D==L||L+D==R) ok=true; &#125; else if(!D)&#123; if(R+U==L||L+U==R) ok=true; &#125; if(ok) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125;&#125; 1277 Tri-Triangle找规律然后直接输出 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main() &#123; char ch; while(scanf("%c",&amp;ch)!=EOF) &#123; int n=ch-'A'+1; int space=2*n-1; for(int i=1; i&lt;=n; i++) &#123; for(int j=1;j&lt;=space;j++) printf(" "); for(int k=1;k&lt;=i;k++) printf("%c",64+k); for(int k=i-1;k&gt;=1;k--) printf("%c",64+k); puts(""); space--; &#125; space=n-1; for(int i=1; i&lt;=n; i++) &#123; for(int j=1;j&lt;=space;j++) printf(" "); for(int k=1;k&lt;=i;k++) printf("%c",64+k); for(int k=i-1;k&gt;=1;k--) printf("%c",64+k); for(int j=1;j&lt;=2*space+1;j++) printf(" "); for(int k=1;k&lt;=i;k++) printf("%c",64+k); for(int k=i-1;k&gt;=1;k--) printf("%c",64+k); puts(""); space--; &#125; &#125;&#125; 1280 String Hash就是26进制转10进制 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;typedef __int64 ll;const int P = 1e9+7;const int maxn = 1e3+5;char s[maxn];int main()&#123; while(~scanf("%s",s+1)) &#123; s[0]='b'; int lens=strlen(s); ll ans=0; for(int i=0;i&lt;lens;i++)&#123; ans=(ans*26%P+(s[i]-'a'))%P; &#125; printf("%lld\n",ans); &#125;&#125; 1281 Cute String输入用gets或者循环getchar()，跳过字符串首部空格后，统计中间空格个数便可知道单词个数，看空格个数是否&gt;9和字母种类个数&gt;10即可 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;unordered_map&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; char s[205],ch; while(1)&#123; int cnt=0; ch=getchar(); if(ch==-1) break; s[cnt++]=ch; while(ch=getchar())&#123; if(ch=='\n') break; s[cnt++]=ch; &#125; s[cnt]='\0'; int space=0,lens=strlen(s); int p=0; unordered_map&lt;char,int&gt;mp; while(s[p++]==' '); for(int i=p;i&lt;lens;i++)&#123; if(s[i]==' ') space++; else mp[s[i]]=1; &#125; if(mp.size()&gt;10||space&gt;9) puts("No"); else puts("Yes"); &#125;&#125; 1284 多项式直接求和，求和过程中取模 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;using namespace std;typedef __int64 ll;const int maxn = 1e4+5;ll qpow(ll a,ll b,ll p)&#123; ll res=1%p; while(b)&#123; if(b&amp;1) res=res*a%p; a=a*a%p; b&gt;&gt;=1; &#125; return res;&#125;int a[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,m,x; scanf("%d%d%d",&amp;n,&amp;m,&amp;x); for(int i=n;i&gt;=0;i--) scanf("%d",&amp;a[i]); ll ans=0; for(int i=0;i&lt;=n;i++)&#123; ans=(ans+a[i]*qpow(x,i,m)%m)%m; &#125; printf("%lld\n",ans); &#125;&#125; 1286 比赛当时找的规律+猜结论？ 好像是dp[i]表示冠军最多打i场需要的最多选手人数，那么容易退推出前几项dp[0]=1,dp[1]=2,dp[2]=4… dp[i]=dp[i-1]+dp[i-2]+1，如果n&lt;=dp[i]，那么答案就是i 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;typedef __int64 ll;ll f[105];int main()&#123; f[0]=1; f[1]=2; for(int i=2;i&lt;=85;i++) f[i]=f[i-1]+f[i-2]+1; ll n; while(~scanf("%I64d",&amp;n))&#123; for(int i=0;i&lt;=85;i++)&#123; if(n&lt;=f[i])&#123; printf("%d\n",i); break; &#125; &#125; &#125;&#125; 1291 Buying Gifts要想最大值和最小值相差最小，那么连续的m长连续段礼物价格序列是最有可能的 将价格升序排序后以长度m尺取找出最小价格差即可，由于排好序所以总和肯定取之前的更小 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#define inf 0x3f3f3f3fusing namespace std;typedef __int64 ll;const int maxn = 1e3+5;int a[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); &#125; sort(a,a+n); int d=inf,pos=0; for(int i=0;i&lt;n-m+1;i++)&#123; if(a[i+m-1]-a[i]&lt;d)&#123; d=a[i+m-1]-a[i]; pos=i; &#125; &#125; int sum=0; for(int i=pos;i&lt;=pos+m-1;i++) sum+=a[i]; printf("%d %d\n",d,sum); &#125;&#125; 1292 Co-stringhash预处理+枚举最大长度或者暴力枚举左右端点+剪枝 看statu应该有更简单的解法（直接枚举最大可能长度，找到了就退出 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;string.h&gt;const int maxn = 1e3+5;typedef unsigned long long ull;using namespace std;char s[maxn];int lens;ull base=233;ull p[maxn],hs[maxn];ull geths(int l,int r)&#123; return (ull)hs[r]-p[r-l+1]*hs[l-1];&#125;bool pd(int k)&#123; for(int i=1;i+2*k-1&lt;=lens;i++)&#123; if(geths(i,i+k-1)==geths(i+k,i+2*k-1)) return true; &#125; return false;&#125;int main()&#123; p[0]=1; for(int i=1;i&lt;maxn;i++)&#123; p[i]=p[i-1]*base; &#125; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%s",s+1); lens=strlen(s+1); for(int i=1;i&lt;=lens;i++)&#123; hs[i]=hs[i-1]*base+s[i]; &#125; bool ok=false; for(int i=lens/2;i&gt;=1;i--)&#123; if(pd(i))&#123; ok=true; printf("%d\n",i*2); break; &#125; &#125; if(!ok) puts("0"); &#125;&#125; 1293 Diamond找规律直接输出 1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int T,n; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); for(int i=1; i&lt;=n; i++) &#123; for(int j=1;j&lt;=n-i;j++)printf(" "); for(int j=1;j&lt;=i;j++) printf("%c",65+n-j); for(int j=1;j&lt;=i-1;j++)printf("%c",65+n-i+j); puts(""); &#125; for(int i=n-1;i&gt;=1;i--) &#123; for(int j=1;j&lt;=n-i;j++)printf(" "); for(int j=1;j&lt;=i;j++) printf("%c",65+n-j); for(int j=1;j&lt;=i-1;j++)printf("%c",65+n-i+j); puts(""); &#125; &#125;&#125; 1294 Enquiry维护一个前缀和,sum[i]表示1…i有多少男女相邻的个数 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;const int maxn = 1e4+5;char s[maxn];int sum[maxn];int main()&#123; int T,n; scanf("%d",&amp;T); while(T--)&#123; scanf("%s",s); int lens=strlen(s),cnt=0; sum[0]=0; for(int i=1; i&lt;lens; i++)&#123; if(s[i]!=s[i-1]) cnt++; sum[i]=cnt; &#125; scanf("%d",&amp;n); while(n--) &#123; int l,r; scanf("%d%d",&amp;l,&amp;r); printf("%d\n",sum[r-1]-sum[l-1]); &#125; &#125;&#125; 1296 GCD容斥，与6互素就不会有和6一样的因子2,3，所以[l,r]区间的数减去2和3的倍数再加上6的倍数(计算2和3的倍数时多减了一次)即为答案 12345678910111213#include&lt;stdio.h&gt;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); int cnt2=r/2-(l-1)/2; int cnt3=r/3-(l-1)/3; int cnt6=r/6-(l-1)/6; printf("%d\n",r-l+1-cnt2-cnt3+cnt6); &#125;&#125; 1299 String按题意模拟即可 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char s[105]; while(~scanf("%s",s))&#123; char op[5]; int lens=strlen(s),step=0; while(scanf("%s",op)&amp;&amp;strcmp(op,"END")!=0)&#123; if(op[0]=='S')&#123; int l,r;char ch[5]; scanf("%d%d%s",&amp;l,&amp;r,ch);l--,r--; for(int i=l;i&lt;=r;i++) s[i]=ch[0]; &#125; else&#123; char ss[5],tt[5]; scanf("%s%s",ss,tt); for(int i=0;i&lt;lens;i++) if(s[i]==ss[0]) s[i]=tt[0]; &#125; printf("%d:%s\n",++step,s); &#125; puts(""); &#125;&#125; 1300 Dice按题意模拟即可 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int T; scanf("%d",&amp;T); char s[10]; int n,m,k,cnt[10]; while(T--)&#123; scanf("%s",s); for(int i=1;i&lt;=6;i++) cnt[i]=0; for(int i=0;i&lt;6;i++) cnt[s[i]-'0']++; scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;n,&amp;k); int num=cnt[k]; if(k!=1) num+=cnt[1]; printf("%d:%s\n",i,num&gt;=n?"true":"false"); &#125; puts(""); &#125;&#125; 1301 Zeroes按题意模拟循环1000次即可 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;algorithm&gt;int main()&#123; int T; scanf("%d",&amp;T); int a[20]; while(T--)&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); bool ok; for(int k=0;k&lt;=1000;k++)&#123; ok=true; for(int i=0;i&lt;n;i++)&#123; if(a[i]) ok=false; &#125; if(ok)&#123; printf("%d\n",k); break; &#125; int tmp=a[0]; for(int i=0;i&lt;n-1;i++)&#123; a[i]=abs(a[i]-a[i+1]); &#125; a[n-1]=abs(a[n-1]-tmp); &#125; if(!ok) puts("Impossible"); &#125;&#125; 1305 斐波那契区间直接扫描一遍即可，注意防止越界，如果中途a[i]+a[i+1]!=a[i+2],那么左端点起点重新从i+1开始 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;algorithm&gt;const int maxn = 1e4+5;int a[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); int ans=0; for(int i=0;i&lt;n;i++)&#123; int cnt=2; while(i+2&lt;n&amp;&amp;a[i]+a[i+1]==a[i+2])&#123; cnt++; i++; &#125; if(cnt&gt;ans) ans=cnt; &#125; printf("%d\n",ans); &#125;&#125; 1308 比赛按题意模拟计算即可 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;algorithm&gt;const int maxn = 1e4+5;int a[maxn];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); int rounds=0,fields=0; while(n&gt;1)&#123; int k=2; while(k&lt;=n) k*=2; k/=2; fields+=k/2; rounds++; n-=k/2; &#125; printf("%d %d\n",rounds,fields); &#125;&#125; 1239 2048巨恶心的大模拟，建议直接写相关函数每次调用，方便调试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;int a[5][5],tmp[5];void gatherL(int k)&#123; int cnt=0; for(int j=1;j&lt;=4;j++)&#123; if(a[k][j]) tmp[++cnt]=a[k][j]; a[k][j]=0; &#125; for(int i=1;i&lt;=cnt;i++) a[k][i]=tmp[i];&#125;void gatherR(int k)&#123; int cnt=4; for(int j=4;j&gt;=1;j--)&#123; if(a[k][j]) tmp[cnt--]=a[k][j]; a[k][j]=0; &#125; for(int i=4;i&gt;cnt;i--) a[k][i]=tmp[i];&#125;void gatherU(int k)&#123; int cnt=0; for(int i=1;i&lt;=4;i++)&#123; if(a[i][k]) tmp[++cnt]=a[i][k]; a[i][k]=0; &#125; for(int i=1;i&lt;=cnt;i++) a[i][k]=tmp[i];&#125;void gatherD(int k)&#123; int cnt=4; for(int i=4;i&gt;=1;i--)&#123; if(a[i][k]) tmp[cnt--]=a[i][k]; a[i][k]=0; &#125; for(int i=4;i&gt;cnt;i--) a[i][k]=tmp[i];&#125;void LEFT() &#123; for(int i=1;i&lt;=4;i++)&#123; gatherL(i); for(int j=1;j&lt;=3;j++)&#123; if(a[i][j]==a[i][j+1])&#123; a[i][j]*=2; a[i][j+1]=0; gatherL(i); &#125; &#125; &#125;&#125;void RIGHT() &#123; for(int i=1;i&lt;=4;i++)&#123; gatherR(i); for(int j=4;j&gt;=2;j--)&#123; if(a[i][j]==a[i][j-1])&#123; a[i][j]*=2; a[i][j-1]=0; gatherR(i); &#125; &#125; &#125;&#125;void UP() &#123; for(int j=1;j&lt;=4;j++)&#123; gatherU(j); for(int i=1;i&lt;=3;i++)&#123; if(a[i][j]==a[i+1][j])&#123; a[i][j]*=2; a[i+1][j]=0; gatherU(j); &#125; &#125; &#125;&#125;void DOWN() &#123; for(int j=1;j&lt;=4;j++)&#123; gatherD(j); for(int i=4;i&gt;=2;i--)&#123; if(a[i][j]==a[i-1][j])&#123; a[i][j]*=2; a[i-1][j]=0; gatherD(j); &#125; &#125; &#125;&#125;int main() &#123; int T; scanf("%d",&amp;T); while(T--) &#123; for(int i=1; i&lt;=4; i++) &#123; for(int j=1; j&lt;=4; j++) &#123; scanf("%d",&amp;a[i][j]); &#125; &#125; char op[10]; scanf("%s",op); if(op[0]=='L') LEFT(); else if(op[0]=='R') RIGHT(); else if(op[0]=='U') UP(); else DOWN(); for(int i=1; i&lt;=4; i++) &#123; for(int j=1; j&lt;=4; j++) &#123; printf("%d%c",a[i][j],j==4?'\n':' '); &#125; &#125; puts(""); &#125;&#125; 1264 字符不重复子串如果是简单的求长度就直接用两个指针+标记数组做就好了，有点像滑动窗口 这里要用动态规划，pre[s[i]]为前一个s[i]的位置，f[i]表示以s[i]结尾的最长不重复子串长度 那么对于s[i]有两种情况，一是s[i]在前面未出现，那么f[i]=f[i-1]+1；二是前面已经出现了s[i]，如果控制的区间左端点l在pre[s[i]]前面，说明当前控制的区间中有部分要跳过，f[i]=i-pre[s[i]]，区间要缩小，否则依然是f[i]=f[i-1]+1 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e4+5;char s[maxn];int pre[26],f[maxn];int main() &#123; ios::sync_with_stdio(false); cin.tie(0); while(cin&gt;&gt;s)&#123; for(int i=0;i&lt;26;i++) pre[i]=-1; int ans=1,lens=strlen(s); int l=0; pre[s[0]-'a']=0; f[0]=1; for(int i=1;i&lt;lens;i++)&#123; int ch=s[i]-'a'; if(pre[ch]==-1) f[i]=f[i-1]+1; else&#123; if(l&lt;=pre[ch])&#123; f[i]=i-pre[ch]; l=pre[ch]+1; &#125; else&#123; f[i]=f[i-1]+1; &#125; &#125; pre[s[i]-'a']=i; ans=max(ans,f[i]); &#125; string ss=s; set&lt;string&gt;anss; for(int i=0;i&lt;lens;i++)&#123; if(f[i]==ans)&#123; anss.insert(ss.substr(i-ans+1,ans)); &#125; &#125; cout&lt;&lt;ans&lt;&lt;'\n'; for(set&lt;string&gt;::iterator it=anss.begin();it!=anss.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;'\n'; &#125; &#125;&#125; 1273 Set用set或map或其他容器等统计数字种类数，种类数&lt;=3肯定可以，&gt;4肯定不行，==4特判一下 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;inline int read(int &amp;x)&#123; x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); vector&lt;int&gt;v; for(int i=0;i&lt;n;i++)&#123; int x;read(x); v.push_back(x); &#125; sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end()); bool ok=false; if(v.size()&lt;=3) ok=true; else if(v.size()&gt;4) ok=false; else &#123; if(v[0]+v[1]==v[2]+v[3]||v[0]+v[2]==v[1]+v[3]||v[0]+v[3]==v[1]+v[2]) ok=true; &#125; if(ok) puts("Yes"); else puts("No"); &#125;&#125; 1274 Matrix很容易看出规律$ans=1+2^2+2^2+1+4^2+4^2+1+…+(2n)^2+(2n)^2+1$ 由于$1^2+2^2+3^2+…+n^2=n(n+1)(2n+1)/6$ 可以推出$2^2+4^2+6^2+…+(2n)^2=2n(n+1)(2n+1)/3$ 因为答案要取模,又因为公式中有除法需用到数论中逆元的知识解决，即(a/b)%p=a*(b^(p-2))%p，p为素数 当然也可以直接上Java大数，最终结果再取模 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;typedef __int64 ll;const int P = 1e9+7;ll qmul(ll a,ll b,ll p)&#123; ll res=0; while(b)&#123; if(b&amp;1) res=res+a%p; a=a+a%p; b&gt;&gt;=1; &#125; return res;&#125;ll qpow(ll a,ll b,ll p)&#123; ll res=1; while(b)&#123; if(b&amp;1) res=res*a%p; a=a*a%p; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; ll n; while(scanf("%I64d",&amp;n)&amp;&amp;n)&#123; ll num1=(n+1)/2; ll m=n/2; ll ans=(num1+(4*(m*(m+1)%P*(2*m+1)%P)%P)*qpow(3,P-2,P)%P)%P; if(n%2==0) ans-=qmul(n,n,P); while(ans&lt;0) ans+=P; printf("%I64d\n",ans); &#125;&#125; 1275 Exam Schedule直接模拟 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;string.h&gt;int sche[10][20];struct Ans&#123; int d,s,t;&#125;ans[30];char table[5][10]=&#123;"Mon","Tue","Wen","Thur","Fri"&#125;;int pd(int d,int s,int t)&#123; for(int i=s;i&lt;=t;i++)&#123; if(sche[d][i]) return 0; &#125; return 1;&#125;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; memset(sche,0,sizeof(sche)); int n,k; scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;n;i++)&#123; char day[5];int s,t; scanf("%s%d%d",day,&amp;s,&amp;t); if(strcmp(day,"Mon")==0)&#123; for(int i=s;i&lt;=t;i++) sche[1][i]=1; &#125; else if(strcmp(day,"Tue")==0)&#123; for(int i=s;i&lt;=t;i++) sche[2][i]=1; &#125; else if(strcmp(day,"Wen")==0)&#123; for(int i=s;i&lt;=t;i++) sche[3][i]=1; &#125; else if(strcmp(day,"Thur")==0)&#123; for(int i=s;i&lt;=t;i++) sche[4][i]=1; &#125; else if(strcmp(day,"Fri")==0)&#123; for(int i=s;i&lt;=t;i++) sche[5][i]=1; &#125; &#125; int cnt=0; for(int d=1;d&lt;=5;d++)&#123; for(int i=1;i&lt;=4;i++)&#123; if(4-i+1&gt;=k&amp;&amp;pd(d,i,i+k-1))&#123; ans[cnt].d=d-1; ans[cnt].s=i; ans[cnt].t=i+k-1; cnt++; &#125; &#125; for(int i=5;i&lt;=8;i++)&#123; if(8-i+1&gt;=k&amp;&amp;pd(d,i,i+k-1))&#123; ans[cnt].d=d-1; ans[cnt].s=i; ans[cnt].t=i+k-1; cnt++; &#125; &#125; for(int i=9;i&lt;=11;i++)&#123; if(11-i+1&gt;=k&amp;&amp;pd(d,i,i+k-1))&#123; ans[cnt].d=d-1; ans[cnt].s=i; ans[cnt].t=i+k-1; cnt++; &#125; &#125; &#125; printf("%d\n",cnt); for(int i=0;i&lt;cnt;i++)&#123; printf("%s %d %d\n",table[ans[i].d],ans[i].s,ans[i].t); &#125; &#125;&#125; 1170 ICPC统计每列的最高等级和所有列最高等级的出现次数即可 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;char s[3][105];int cnt[5],Min[105];int main()&#123; int n; while(scanf("%d",&amp;n),n)&#123; for(int i=0;i&lt;3;i++)&#123; scanf("%s",s[i]); &#125; for(int i=0;i&lt;5;i++) cnt[i]=0; for(int j=0;j&lt;n;j++)&#123; Min[j]=10; for(int i=0;i&lt;3;i++)&#123; Min[j]=min(Min[j],s[i][j]-'A'); &#125; for(int i=0;i&lt;5;i++)&#123; if(Min[j]==i) cnt[i]++; &#125; &#125; for(int j=0;j&lt;n;j++) printf("%c",Min[j]+'A');puts(""); for(int i=0;i&lt;5;i++) printf("%d%c",cnt[i],i==4?'\n':' '); &#125;&#125; 1241 Permutation首先先学习一下置换的定义和置换乘法的性质，离散数学刘任任版P190 其实就是要通过不断映射使得序列回到初始序列 如果暴力模拟，可能会卡成O(n!)的复杂度，即全排列的情况 其实只需要计算对每一个数使a[i]变为i的次数，然后计算所有次数的最小公倍数即为答案 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;typedef __int64 ll;using namespace std;const int maxn = 105;int a[maxn];int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; int ans=1; for(int i=1;i&lt;=n;i++)&#123; int cnt=1,p=a[i]; while(p!=i)&#123; cnt++; p=a[p]; &#125; ans=ans/__gcd(ans,cnt)*cnt; &#125; printf("%d\n",ans); &#125;&#125; 1249 Alice’s Prime首先一位的素数只有2,3,5,7，然后dfs将这四个数后面不断添加1,3,5,7,9再判断素数，最后排个序 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;typedef __int64 ll;using namespace std;vector&lt;int&gt;ans;bool pd(ll x)&#123; for(ll i=2;i*i&lt;=x;i++)&#123; if(x%i==0) return false; &#125; return true;&#125;void dfs(ll x)&#123; if(x&gt;INT_MAX) return; for(int i=1;i&lt;=9;i+=2)&#123; if(pd(x*10+i))&#123; ans.push_back(x*10+i); dfs(x*10+i); &#125; &#125;&#125;int main() &#123; ans.push_back(2); ans.push_back(3); ans.push_back(5); ans.push_back(7); for(int i=0;i&lt;4;i++)&#123; dfs(ans[i]); &#125; sort(ans.begin(),ans.end()); for(int i=0;i&lt;ans.size();i++)&#123; printf("%d %d\n",i+1,ans[i]); &#125;&#125; 1266 RGB统计R,G,B的出现次数，在0…R-1统计G,B的出现次数，记为R1,R2，在R…R+G-1统计R,B的出现次数，记为G1,G2，在R+G…lens-1统计R,G的出现次数，记为B1,B2 那么首先肯定是两个两个区间互相交换，R1,G1交换，R2,B1交换和G2,B2交换，有可能交换不完，成为0…R-1还有’G’，R…R+G-1还有’B’，R+G…lens-1还有’R’的情况，那对于每个未交换字符的需要交换2次 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;typedef __int64 ll;using namespace std;const int maxn = 1e4+5;char s[maxn];int main() &#123; while(~scanf("%s",s))&#123; int lens=strlen(s); int R=0,G=0,B=0; for(int i=0;i&lt;lens;i++)&#123; if(s[i]=='R') R++; else if(s[i]=='G') G++; else B++; &#125; int R1=0,R2=0; //0...R-1 G,B for(int i=0;i&lt;R;i++)&#123; if(s[i]=='G') R1++; else if(s[i]=='B')R2++; &#125; int G1=0,G2=0; //R...R+G-1 R,B for(int i=R;i&lt;R+G;i++)&#123; if(s[i]=='R') G1++; else if(s[i]=='B') G2++; &#125; int B1=0,B2=0; //R+G...lens-1 R,G for(int i=R+G;i&lt;lens;i++)&#123; if(s[i]=='R') B1++; else if(s[i]=='G') B2++; &#125; int tmp=0,ans=0; if(R1&amp;&amp;G1)&#123; tmp=min(R1,G1); ans+=tmp; R1-=tmp; G1-=tmp; &#125; if(R2&amp;&amp;B1)&#123; tmp=min(R2,B1); ans+=tmp; R2-=tmp; B1-=tmp; &#125; if(G2&amp;&amp;B2)&#123; tmp=min(G2,B2); ans+=tmp; G2-=tmp; B2-=tmp; &#125; ans+=(R1+R2+G1+G2+B1+B2)/3*2; printf("%d\n",ans); &#125;&#125; 1267 Matrix直接模拟 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 15;int a[maxn][maxn],b[maxn][maxn];int tmp[maxn];int n,m;void swapx(int x,int y)&#123; for(int i=1;i&lt;=m;i++) tmp[i]=a[x][i]; for(int i=1;i&lt;=m;i++) a[x][i]=a[y][i]; for(int i=1;i&lt;=m;i++) a[y][i]=tmp[i];&#125;void swapy(int x,int y)&#123; for(int i=1;i&lt;=n;i++) tmp[i]=a[i][x]; for(int i=1;i&lt;=n;i++) a[i][x]=a[i][y]; for(int i=1;i&lt;=n;i++) a[i][y]=tmp[i];&#125;int main()&#123; char op[5]; int x,y; while(~scanf("%s",op))&#123; if(strcmp(op,"IN")==0)&#123; scanf("%d%d",&amp;n,&amp;m); int num=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; a[i][j]=++num; &#125; &#125; &#125; else if(strcmp(op,"SR")==0)&#123; scanf("%d%d",&amp;x,&amp;y); swapx(x,y); &#125; else if(strcmp(op,"SC")==0)&#123; scanf("%d%d",&amp;x,&amp;y); swapy(x,y); &#125; else if(strcmp(op,"TR")==0)&#123; for(int j=1;j&lt;=m;j++)&#123; for(int i=1;i&lt;=n;i++)&#123; b[j][i]=a[i][j]; &#125; &#125; swap(n,m); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; a[i][j]=b[i][j]; &#125; &#125; &#125; else if(strcmp(op,"FR")==0)&#123; for(int i=1,j=n;i&lt;=n/2;i++,j--)&#123; swapx(i,j); &#125; &#125; else if(strcmp(op,"FC")==0)&#123; for(int i=1,j=m;i&lt;=m/2;i++,j--)&#123; swapy(i,j); &#125; &#125; else if(strcmp(op,"PR")==0)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; printf("%d%c",a[i][j],j==m?'\n':' '); &#125; &#125; puts(""); &#125; &#125;&#125; 1279 Dual Prime素数打表，1e6以内最多不到1e5个素数，然后枚举任意两个不同的素数，弄个前缀和维护1..i 内符合条件的个数 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;int p[maxn],sum[maxn];int cnt=0;bool isp[maxn];void getprime()&#123; memset(isp,true,sizeof(isp)); isp[0]=isp[1]=false; isp[2]=true; for(int i=2;i&lt;maxn;i++)&#123; if(isp[i]) p[cnt++]=i; for(int j=0;j&lt;cnt&amp;&amp;p[j]*i&lt;maxn;j++)&#123; isp[p[j]*i]=false; &#125; &#125;&#125;void getsum()&#123; for(int i=0;i&lt;cnt;i++)&#123; for(int j=0;j&lt;cnt;j++)&#123; if(i==j) continue; if(p[i]*p[j]&lt;maxn) sum[p[i]*p[j]]=1; else break; &#125; &#125; for(int i=1;i&lt;maxn;i++)&#123; sum[i]+=sum[i-1]; &#125;&#125;int main() &#123; getprime(); getsum(); int T; scanf("%d",&amp;T); while(T--)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); printf("%d\n",sum[r]-sum[l-1]); &#125;&#125; 1283 Good Number首先n位数第一位必须是1，满足条件只需要n-1个数中的1的个数&gt;=0的个数，那么对n-1分奇偶谈论 n-1为奇，$ans=C_{n-1}^{n/2}+C_{n-1}^{n/2+1}+…+C_{n-1}^{n-1}$ n-1为偶，$ans=C_{n-1}^{n-1/2}+C_{n-1}^{n-1/2+1}+…+C_{n-1}^{n-1}$ n==1特判下，组合数用杨辉三角打表就好 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;ll C[70][70];void getC()&#123; for(int i=1;i&lt;=65;i++)&#123; C[i][0]=C[i][i]=1; for(int j=1;j&lt;i;j++)&#123; C[i][j]=C[i-1][j-1]+C[i-1][j]; &#125; &#125;&#125;int main() &#123; getC(); int n; while(~scanf("%d",&amp;n))&#123; if(n==1)&#123; puts("1"); continue; &#125; ll ans=0; if(n-1%2)&#123; for(int i=n/2;i&lt;=n-1;i++)&#123; ans+=C[n-1][i]; &#125; &#125; else&#123; for(int i=(n-1)/2;i&lt;=n-1;i++)&#123; ans+=C[n-1][i]; &#125; &#125; printf("%I64d\n",ans); &#125;&#125; 1287 银行因为所有业务在当天，则可以把时间化为分钟数，然后枚举一天的所有分钟24*60=1440 对于每一分钟，如果有新的用户来了，则加入优先队列；如果过了上一个业务办理的时间，把队列中等待超时的出队列，然后队列中选一个优先级最高的业务开始处理 每个业务的等待时间：超时的就是最大等待时间，没超时的就是当前处理时间-业务开始时间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 205;struct user&#123; string id; int i,s,t,d,ans; bool done; user()&#123;&#125; user(string id,int i,int s,int t,int d,bool done):id(id),i(i),s(s),t(t),d(d),done(done)&#123;&#125; bool operator &lt; (const user &amp;hs)const&#123; if(id[0]!=hs.id[0]) return id[0]!='V'; return s&gt;hs.s; &#125;&#125;p[maxn];int main()&#123; char id[10]; int h,m,t,d,cnt=0; while(~scanf("%s%d:%d%d%d",id,&amp;h,&amp;m,&amp;t,&amp;d))&#123; p[cnt]=user(id,cnt,h*60+m,t,d,false); p[cnt].ans=p[cnt].d; cnt++; &#125; int nowtime=0,k=0; priority_queue&lt;user&gt;pq; for(int i=1;i&lt;=1440;i++)&#123; if(k&lt;cnt&amp;&amp;i&gt;=p[k].s)&#123; pq.push(p[k++]); &#125; if(i&gt;=nowtime)&#123; while(!pq.empty()&amp;&amp;pq.top().s+pq.top().d&lt;nowtime) pq.pop(); if(!pq.empty())&#123; user tmp=pq.top(); pq.pop(); p[tmp.i].done=true; p[tmp.i].ans=i-tmp.s; nowtime=i+tmp.t; &#125; &#125; &#125; for(int i=0;i&lt;cnt;i++)&#123; cout&lt;&lt;p[i].id&lt;&lt;' '&lt;&lt;p[i].ans&lt;&lt;' '&lt;&lt;(p[i].done?"Yes":"No")&lt;&lt;'\n'; &#125;&#125; 1295 Flawless Prime首先判断数位是否有0，存在0肯定不是，然后依次去掉最高位暴力判断是否为素数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;bool has0(int x)&#123; while(x)&#123; if(x%10==0) return true; x/=10; &#125; return false;&#125;bool isprime(int x)&#123; if(x==1) return false; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0) return false; &#125; return true;&#125;int len(int x)&#123; int res=0; while(x)&#123; res++; x/=10; &#125; return res;&#125;bool pd(int x)&#123; while(x)&#123; if(!isprime(x)) return false; int cnt=len(x); int tmp=1; for(int i=1;i&lt;cnt;i++) tmp*=10; x%=tmp; &#125; return true;&#125;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); if(has0(n) || !pd(n)) puts("No"); else puts("Yes"); &#125;&#125; 1297 Homework发现与题目号无关，只需要通过学号和排名的关系来用map记录对应学号的积分，最后算出成绩排个序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;unordered_map&lt;int,int&gt;mp;struct stu&#123; int sid,grade; stu()&#123;&#125; stu(int a,int b):sid(a),grade(b)&#123;&#125; bool operator &lt; (const stu &amp;b)const&#123; if(grade==b.grade) return sid&lt;b.sid; return grade&gt;b.grade; &#125;&#125;s[maxn];int main()&#123; int pid,sid,prank; int MaxS=0; while(~scanf("%d%d%d",&amp;pid,&amp;sid,&amp;prank))&#123; if(1&lt;=prank&amp;&amp;prank&lt;=12)&#123; mp[sid]+=32; &#125; else if(13&lt;=prank&amp;&amp;prank&lt;=24)&#123; mp[sid]+=16; &#125; else if(25&lt;=prank&amp;&amp;prank&lt;=48)&#123; mp[sid]+=8; &#125; else if(49&lt;=prank&amp;&amp;prank&lt;=96)&#123; mp[sid]+=4; &#125; else if(97&lt;=prank&amp;&amp;prank&lt;=192)&#123; mp[sid]+=2; &#125; else&#123; mp[sid]+=1; &#125; MaxS=max(MaxS,mp[sid]); &#125; int cnt=0; for(unordered_map&lt;int,int&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123; s[cnt++]=stu(it-&gt;first,round(100+10*log(it-&gt;second*1.0/MaxS))); &#125; sort(s,s+cnt); for(int i=0;i&lt;cnt;i++)&#123; printf("%d %d\n",s[i].sid,s[i].grade); &#125;&#125; 1304 ZUMA!模拟把c放到第i个和第i+1个之间后的结果，然后答案取最大值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 105;int n,c;int b[maxn];int tmp[maxn],a[maxn];int func(int x)&#123; for(int i=0;i&lt;n;i++) a[i]=b[i]; int cnt=1; int i=x,j=x+1,p=0; while(i&gt;=0&amp;&amp;a[i]==c)&#123; i--; cnt++; &#125; while(j&lt;n&amp;&amp;a[j]==c)&#123; j++; cnt++; &#125; if(cnt&lt;3) return 0; else&#123; for(int k=0;k&lt;=i;k++) tmp[p++]=a[k]; for(int k=j;k&lt;n;k++) tmp[p++]=a[k]; &#125; for(int i=0;i&lt;p;i++) a[i]=tmp[i]; while(1)&#123; int pp=0; for(int i=0;i&lt;p;i++)&#123; cnt=1; while(i+1&lt;p&amp;&amp;a[i]==a[i+1])&#123; cnt++; i++; &#125; if(cnt&lt;3)&#123; for(int k=i-cnt+1;k&lt;=i;k++) tmp[pp++]=a[k]; &#125; &#125; if(pp==p) break; for(int i=0;i&lt;pp;i++) a[i]=tmp[i]; p=pp; &#125; return n-p;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;c); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;b[i]); &#125; int ans=0; for(int i=0;i&lt;n-1;i++)&#123; ans=max(ans,func(i)); &#125; printf("%d\n",ans); &#125;&#125; 1307 Beautiful Number二进制枚举0的位置和二进制串的长度，对于64位整数第63位是符号位，唯一的0前面必须有1，不然就会成为前导0，如果0…61个位置中的第i个位置为0，那么len…i+1的位置为1，i-1…0的位置也为1， 计算出所有这样的数后排序，求答案每次遍历即可 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;int main()&#123; vector&lt;ll&gt;v; for(int i=0;i&lt;62;i++)&#123; for(int len=62;len&gt;=i+1;len--)&#123; ll res=0; for(int j=len;j&gt;=i+1;j--)&#123; res=res*2+1; &#125; res*=2; for(int j=i-1;j&gt;=0;j--)&#123; res=res*2+1; &#125; v.push_back(res); &#125; &#125; sort(v.begin(),v.end()); int T; scanf("%d",&amp;T); while(T--)&#123; ll l,r; scanf("%I64d%I64d",&amp;l,&amp;r); int ans=0; for(int i=0;i&lt;v.size();i++)&#123; if(l&lt;=v[i]&amp;&amp;v[i]&lt;=r) ans++; else if(v[i]&gt;r) break; &#125; printf("%d\n",ans); &#125;&#125; 1309 唯一的子串枚举左端点取出子串丢到set或map中去重，自动排序 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int m;char str[105]; scanf("%d%s",&amp;m,str); string s=str; map&lt;string,int&gt;mp; for(int i=0;i+m-1&lt;s.length();i++)&#123; mp.insert(&#123;s.substr(i,m),1&#125;); &#125; for(map&lt;string,int&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123; cout&lt;&lt;it-&gt;first&lt;&lt;'\n'; &#125; puts(""); &#125;&#125; 1270 Unique Digit Number看top应该可以推公式，根据排列组合可以算出位数为1…10的符合条件数的个数…然后不会了 只会暴力dfs打表，根据位数打表就可以确保大小顺序，然后注意0不能作为前导 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 9e6+5;ll ans[maxn];int cnt,vis[10];void dfs(ll x,int k,int len)&#123; if(k==len)&#123; ans[++cnt]=x; return; &#125; for(int i=0;i&lt;10;i++)&#123; if(i==0&amp;&amp;k&gt;0&amp;&amp;!vis[0])&#123; vis[i]=1; dfs(x*10+i,k+1,len); vis[i]=0; &#125; if(i&amp;&amp;!vis[i])&#123; vis[i]=1; dfs(x*10+i,k+1,len); vis[i]=0; &#125; &#125;&#125;int main()&#123; ans[++cnt]=0; for(int len=1;len&lt;=10;len++)&#123; dfs(0,0,len); &#125; int n; while(~scanf("%d",&amp;n))&#123; printf("%I64d\n",ans[n]); &#125;&#125; 1289 3的倍数一道神奇的动态规划，输入为s[]字符串数组，能被3整除说明新的数的数位和%3=0 f[i][j]表示以s[i]为前导的所有新正整数数中 %3==j 的种类数 对于s[i]分数码%3=0,1,2的3种情况讨论，且对于每个s[i]又分取和不取2种情况，这样f[i]可由f[i+1]递推而来，最后f[0][0]是包含所有s[i]为前导的数%3=0的种类数，此时答案包含前导0的情况 因为不能有前导0，所以去掉所有以s[i]==0为前导的的种类数，就是f[0][0]-(f[i+1][0]+1)，即当前位是0，后面符合条件共有f[i+1][0]种，然后后面全部不选，只选0也满足，所以减掉f[i+1]+1 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 5005;const int P = 1e9+7;char s[maxn];int f[maxn][3];int main()&#123; while(~scanf("%s",s))&#123; int lens=strlen(s); f[lens][0]=f[lens][1]=f[lens][2]=0; for(int i=lens-1;i&gt;=0;i--)&#123; int x=(s[i]-'0')%3; if(x==0)&#123; f[i][0]=(f[i+1][0]+f[i+1][0]+1)%P; f[i][1]=(f[i+1][1]+f[i+1][1])%P; f[i][2]=(f[i+1][2]+f[i+1][2])%P; &#125; else if(x==1)&#123; f[i][0]=(f[i+1][0]+f[i+1][2])%P; f[i][1]=(f[i+1][1]+f[i+1][0]+1)%P; f[i][2]=(f[i+1][2]+f[i+1][1])%P; &#125; else &#123; f[i][0]=(f[i+1][0]+f[i+1][1])%P; f[i][1]=(f[i+1][1]+f[i+1][2])%P; f[i][2]=(f[i+1][2]+f[i+1][0]+1)%P; &#125; &#125; int ans=f[0][0]; for(int i=0;i&lt;lens;i++)&#123; if(s[i]=='0') ans=(ans-(f[i+1][0]+1))%P; &#125; while(ans&lt;0) ans+=P; printf("%d\n",ans); &#125;&#125; 1303 Sequence乍一看以为是贪心，每次取较大的一端，其实这样有问题 记忆化搜索（备忘录），直接深搜的话对于当前长度都有两个选择，要么取左端点要么取右端点，时间复杂度O($2^n$) ans[l][r]表示区间l,r的最优解，回溯的时候如果已经求出了子区间的，直接返回对应值即可，不必重复计算 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 65;ll a[maxn],b[maxn];ll ans[maxn][maxn];ll dfs(int l,int r,int k)&#123; if(l&gt;r) return 0; if(ans[l][r]) return ans[l][r]; return ans[l][r]=min(a[l]*b[k-1]+dfs(l+1,r,k+1),a[r]*b[k-1]+dfs(l,r-1,k+1));&#125;int main()&#123; b[0]=1; for(int i=1;i&lt;60;i++) b[i]=b[i-1]*2; int T; scanf("%d",&amp;T); while(T--)&#123; memset(ans,0,sizeof(ans)); int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%I64d",&amp;a[i]); &#125; printf("%I64d\n",dfs(1,n,1)); &#125;&#125; 1244 Estrella’s Chocolate求最小的最大值，二分最大热量 以当前最大热量值吃完所有巧克力所需天数&gt;m，说明最大热量需要再大一些，左指针右移；反过来同理 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e4+5;int n,m;int a[maxn];int pd(int x)&#123; int day=1,sum=0; for(int i=0;i&lt;n;i++)&#123; if(sum+a[i]&lt;=x) sum+=a[i]; else&#123; day++; sum=a[i]; &#125; &#125; return day&lt;=m;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); &#125; int l=*max_element(a,a+n),r=1e9; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(pd(mid)) r=mid; else l=mid+1; &#125; printf("%d\n",l); &#125;&#125; 1269 Craftman求制作手套最大值，二分手套件数 如果制作当前x件所需多余原料数&gt;k，说明原材料不够，右指针左移；反过来同理 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e3+5;int n,k;ll a[maxn],b[maxn];bool pd(ll x)&#123; ll need=0; for(int i=0;i&lt;n;i++)&#123; need+=(x*a[i]-b[i]&gt;0?x*a[i]-b[i]:0); &#125; return need&lt;=k;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;n;i++) scanf("%I64d",&amp;a[i]); for(int i=0;i&lt;n;i++) scanf("%I64d",&amp;b[i]); ll l=0,r=*max_element(b,b+n)+k; while(l&lt;r)&#123; ll mid=(l+r+1)&gt;&gt;1; if(pd(mid)) l=mid; else r=mid-1; &#125; printf("%I64d\n",l); &#125;&#125; 1167 逆序数（大数据）既然是大数据，暴力O($n^2$)肯定T 树状数组或者归并排序O(nlogn) 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e4+5;int n;int a[maxn],b[maxn],c[maxn];int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int v)&#123; while(x&lt;=n)&#123; c[x]+=v; x+=lowbit(x); &#125;&#125;int sum(int x)&#123; int res=0; while(x)&#123; res+=c[x]; x-=lowbit(x); &#125; return res;&#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; memset(c,0,sizeof(c)); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); b[i]=a[i]; &#125; sort(b,b+n); int m=unique(b,b+n)-b; for(int i=0;i&lt;n;i++)&#123; a[i]=lower_bound(b,b+m,a[i])-b+1; &#125; int ans=0; for(int i=n-1;i&gt;=0;i--)&#123; ans+=sum(a[i]-1); add(a[i],1); &#125; printf("%d\n",ans); &#125;&#125; 1160 猜数字需要满足所有的k个条件，则需要把询问存起来离线操作，然后枚举$C_n^4$个的所有组合，回溯法或者直接枚举，对于每个组合看是否满足这k个询问 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 3e5+5;const int maxk = 105;int n,K;int x[maxk],y[maxk];int a[maxk][5],b[5],vis[maxn],cnt;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;bool pd()&#123; for(int k=0;k&lt;K;k++)&#123; int xx=0,yy=0; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; if(i==j&amp;&amp;a[k][i]==b[j]) xx++; if(i!=j&amp;&amp;a[k][i]==b[j]) yy++; &#125; &#125; if(x[k]!=xx||y[k]!=yy)return false; &#125; return true;&#125;void dfs(int k)&#123; if(k==4)&#123; if(pd())&#123; cnt++; printf("%d %d %d %d\n",b[0],b[1],b[2],b[3]); &#125; return; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i])&#123; vis[i]=1; b[k]=i; dfs(k+1); vis[i]=0; &#125; &#125;&#125;int main()&#123; while(n=read())&#123; K=read(); for(int i=0;i&lt;K;i++)&#123; for(int j=0;j&lt;4;j++) a[i][j]=read(); x[i]=read(),y[i]=read(); &#125; cnt=0; dfs(0); printf("%d\n",cnt); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 3e5+5;const int maxk = 105;int n,K;int x[maxk],y[maxk];int a[maxk][5];int ans[maxn][5],cnt;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;bool pd(int b[])&#123; for(int k=0;k&lt;K;k++)&#123; int xx=0,yy=0; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; if(i==j&amp;&amp;a[k][i]==b[j]) xx++; if(i!=j&amp;&amp;a[k][i]==b[j]) yy++; &#125; &#125; if(x[k]!=xx||y[k]!=yy)return false; &#125; return true;&#125;int main()&#123; while(n=read())&#123; K=read(); for(int i=0;i&lt;K;i++)&#123; for(int j=0;j&lt;4;j++) a[i][j]=read(); x[i]=read(),y[i]=read(); &#125; cnt=0; int b[5]; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; for(int k=1;k&lt;=n;k++)&#123; for(int l=1;l&lt;=n;l++)&#123; if(i==j||i==k||i==l||j==k||j==l||k==l) continue; b[0]=i,b[1]=j,b[2]=k,b[3]=l; if(pd(b))&#123; ans[cnt][0]=i,ans[cnt][1]=j,ans[cnt][2]=k,ans[cnt][3]=l; cnt++; &#125; &#125; &#125; &#125; &#125; for(int i=0;i&lt;cnt;i++)&#123; printf("%d %d %d %d\n",ans[i][0],ans[i][1],ans[i][2],ans[i][3]); &#125; printf("%d\n",cnt); &#125;&#125; 1179 Shortest PathDijkstra求k+1次最短路然后求和，注意指定的城市只能走一次，所以跑Dij的时候需要稍稍标记即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3ftypedef __int64 ll;using namespace std;const int maxn = 1e3+5;const int maxm = 1e4+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n,m,k;int city[5];struct node&#123; int val,id; node(int id,int val):id(id),val(val) &#123;&#125; bool operator &lt;(const node &amp;hs)const&#123; return val&gt;hs.val; &#125;&#125;;struct edge&#123; int next,to,w;&#125;e[maxm*2];int head[maxn],cnt;void addedge(int u,int v,int w)&#123; e[++cnt]=edge&#123;head[u],v,w&#125;; head[u]=cnt;&#125;int dis[maxn],vis[maxn];void dijkstra(int from,int to)&#123; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++) dis[i]=INF; for(int i=0;i&lt;=k+1;i++) vis[city[i]]=true; vis[from]=vis[to]=false; priority_queue&lt;node&gt;q; q.push(node(from,0)); dis[from]=0; while(!q.empty())&#123; int cur=q.top().id; q.pop(); if(vis[cur])continue; vis[cur]=true; for(int i=head[cur]; i ; i=e[i].next)&#123; int v=e[i].to; if(dis[cur]+e[i].w &lt; dis[v])&#123; dis[v]=dis[cur]+e[i].w; q.push(node(v,dis[v])); &#125; &#125; &#125;&#125;int main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;k)&amp;&amp;(n||m||k))&#123; cnt=0; memset(head,0,sizeof(head)); for(int i=0;i&lt;m;i++)&#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; city[0]=1;city[k+1]=n; for(int i=1;i&lt;=k;i++)&#123; city[i]=read(); &#125; bool ok=true; int ans=0; for(int i=0;i&lt;=k;i++)&#123; dijkstra(city[i],city[i+1]); if(dis[city[i+1]]==INF)&#123; ok=false; break; &#125; ans+=dis[city[i+1]]; &#125; if(!ok) puts("Impossible"); else printf("%d\n",ans); &#125;&#125; 1186 Tourist 2经典的TSP问题，回溯法O(n!)求出最优值并记录路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3ftypedef __int64 ll;using namespace std;const int maxn = 15;int n,c[maxn][maxn];inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int ans,ways;int vis[maxn],path[maxn][maxn],tmp[maxn];void dfs(int k,int cur,int cost)&#123; if(cost&gt;ans) return; if(k==n)&#123; cost+=c[cur][0]; if(cost&lt;ans)&#123; ans=cost; for(int i=0;i&lt;n;i++) path[0][i]=tmp[i]; ways=1; &#125; else if(cost==ans&amp;&amp;ways&lt;10)&#123; for(int i=0;i&lt;n;i++) path[ways][i]=tmp[i]; ways++; &#125; return; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i])&#123; vis[i]=1; tmp[k]=i; dfs(k+1,i,cost+c[cur][i]); vis[i]=0; &#125; &#125;&#125;int main()&#123; int T=read(); while(T--)&#123; n=read(); for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=n;j++)&#123; c[i][j]=read(); &#125; &#125; ans=INF,ways=0; dfs(0,0,0); printf("%d\n",ans); for(int i=0;i&lt;ways;i++)&#123; for(int j=0;j&lt;n;j++)&#123; printf("%d%c",path[i][j],j==n-1?'\n':' '); &#125; &#125; &#125;&#125; 1195 Large Population要求边最少，互相连通且边权最大，就是求最大生成树，把边按边权降序排然后Kruskal跑一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3ftypedef __int64 ll;using namespace std;const int maxn = 1e3+5;const int maxm = 1e4+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n,m;int f[maxn];struct edge&#123; int u,v,w; bool operator &lt; (const edge &amp;hs)const&#123; return w&gt;hs.w; &#125;&#125;e[maxm];int Find(int x)&#123; return x==f[x]?x:f[x]=Find(f[x]);&#125;int main()&#123; int T=read(); while(T--)&#123; n=read(); m=read(); for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=0;i&lt;m;i++)&#123; e[i]=edge&#123;read(),read(),read()&#125;; &#125; sort(e,e+m); int cnt=0,ans=0; for(int i=0;i&lt;m;i++)&#123; int u=e[i].u,v=e[i].v,w=e[i].w; int fu=Find(u),fv=Find(v); if(fu!=fv)&#123; f[fu]=fv; cnt++; ans+=w; &#125; if(cnt==n-1) break; &#125; printf("%d\n",ans); &#125;&#125; 1245 Lisa’s Puzzle把二进制反过来看做求前缀，构造一个只有01结点的trie树，就是哈夫曼树，把每个数化为二进制01串插入到trie树，并记录每个结点经过的次数，每个数的答案就是该数最后一个结点的下面两个结点的经过次数和，下面没有结点说明该数不是其他数的前缀了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e6+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int tot=0;int a[maxn];unordered_map&lt;int,int&gt;cnt;int trie[maxn][2],vis[maxn],End[maxn];int len(int x)&#123; int res=0; while(x)&#123; res++; x&gt;&gt;=1; &#125; return res;&#125;void Insert(int k,int x)&#123; int now=0; for(int i=0;i&lt;cnt[x];i++)&#123; int next=((1&lt;&lt;i)&amp;x)?1:0; if(!trie[now][next]) trie[now][next]=++tot; now=trie[now][next]; vis[now]++; &#125; End[k]=now;&#125;int query(int k,int x)&#123; return vis[trie[End[k]][0]]+vis[trie[End[k]][1]];&#125;int main()&#123; int n=read(); for(int i=0;i&lt;n;i++)&#123; a[i]=read(); cnt[a[i]]=len(a[i]); Insert(i,a[i]); &#125; for(int i=0;i&lt;n;i++)&#123; printf("%d\n",query(i,a[i])); &#125;&#125; 1250 Bonus把输入看做有向图，从出度为0的开始拓扑排序，也就是和常规的反过来，求出每个人的等级即可算工资 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1e4+5;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;vector&lt;int&gt;V[maxn];int n,m;int out[maxn],Rank[maxn];bool topu()&#123; queue&lt;int&gt;q; for(int i=1;i&lt;=n;i++)&#123; if(out[i]==0) q.push(i); &#125; int cnt=0; while(!q.empty())&#123; int x=q.front(); q.pop(); cnt++; for(int i=0;i&lt;V[x].size();i++)&#123; int next=V[x][i]; if(--out[next]==0) q.push(next); Rank[next]=Rank[x]+1; &#125; &#125; return cnt==n;&#125;int main()&#123; int T=read(); while(T--)&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++)&#123; V[i].clear(); Rank[i]=out[i]=0; &#125; for(int i=0;i&lt;m;i++)&#123; int u=read(),v=read(); V[v].push_back(u); out[u]++; &#125; if(topu())&#123; int sum=0; for(int i=1;i&lt;=n;i++)&#123; sum+=Rank[i]*1000+888; &#125; printf("%d\n",sum); for(int i=1;i&lt;=n;i++)&#123; printf("%d%c",Rank[i]*1000+888,i==n?'\n':' '); &#125; &#125; else&#123; printf("%d\n",n*888); for(int i=0;i&lt;n;i++)&#123; printf("888%c",i==n-1?'\n':' '); &#125; &#125; &#125;&#125; 1288 Binary Search Tree用new和free动态开结点再释放不是MLE就是TLE 因为最多100个数，可以把静态数组空间分配给新节点，但也不能用数组下标直接将左儿子下标为父节点的2倍，右儿子下标为父节点的2倍+1，100个数可以卡成$2^{100}$，明显数组不够大 其实只要空间为100的结构体数组给新节点使用就行了，每次建树初始化一个递增值记录下标用到第几个即可，其他就和数据结构课上实现的差不多，最后左右递归比较 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 105;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct node&#123; int v; node *l,*r;&#125;tree[2][maxn];int tot;node* Newnode(int k,int x)&#123; tree[k][tot].v=x; tree[k][tot].l=NULL; tree[k][tot].r=NULL; return &amp;tree[k][tot++];&#125;void Insert(int k,node *root,int x)&#123; if(x &lt; root-&gt;v)&#123; if(root-&gt;l==NULL) root-&gt;l=Newnode(k,x); else Insert(k,root-&gt;l,x); &#125; else&#123; if(root-&gt;r==NULL) root-&gt;r=Newnode(k,x); else Insert(k,root-&gt;r,x); &#125;&#125;bool same(node *root0,node *root1)&#123; if(root0==NULL&amp;&amp;root1==NULL) return true; if(root0!=NULL&amp;&amp;root1!=NULL)&#123; return same(root0-&gt;l,root1-&gt;l)&amp;&amp;same(root0-&gt;r,root1-&gt;r); &#125; return false;&#125;int main()&#123; int T=read(); while(T--)&#123; int n=read(),m=read(); tot=0; node *root0 = Newnode(0,read()); for(int i=1;i&lt;n;i++)&#123; Insert(0,root0,read()); &#125; for(int ca=1;ca&lt;=m;ca++)&#123; tot=0; node *root1 = Newnode(1,read()); for(int i=1;i&lt;n;i++)&#123; Insert(1,root1,read()); &#125; printf("%d: ",ca); if(same(root0,root1)) puts("Yes"); else puts("No"); &#125; puts(""); &#125;&#125; 1302 Balance Tree和上一题差不多，静态开结点建树，然后dfs求每个结点的左子树高度和右子树高度判断是否平衡 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;typedef __int64 ll;using namespace std;const int maxn = 1005;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct node&#123; int v; node *l,*r;&#125;tree[maxn];int tot;node* Newnode(int x)&#123; tree[tot].v=x; tree[tot].l=NULL; tree[tot].r=NULL; return &amp;tree[tot++];&#125;void Insert(node *root,int x)&#123; if(x &lt; root-&gt;v)&#123; if(root-&gt;l==NULL) root-&gt;l=Newnode(x); else Insert(root-&gt;l,x); &#125; else&#123; if(root-&gt;r==NULL) root-&gt;r=Newnode(x); else Insert(root-&gt;r,x); &#125;&#125;bool ok;int dfs(node *root)&#123; if(root==NULL) return 0; int lh=dfs(root-&gt;l); int rh=dfs(root-&gt;r); if(abs(lh-rh)&gt;1) ok=false; return max(lh,rh)+1;&#125;int main()&#123; int T=read(); while(T--)&#123; int n=read(); tot=0; node *root = Newnode(read()); for(int i=1;i&lt;n;i++)&#123; Insert(root,read()); &#125; ok=true; dfs(root); if(ok) puts("Yes"); else puts("No"); &#125;&#125; 模拟测试1 E-合并堆典型的区间dp，和矩阵连乘、石子合并等问题相似，可是考试的时候读错了题以为是贪心，气气+1 维护一个前缀和为了方便计算两两区间合并代价值，首先算出短区间最小代价，再自底向上算出长区间最小代价，转移方程看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 305;ll dp[maxn][maxn],h[maxn];ll inf = (1LL&lt;&lt;63)-1;ll sum[maxn];ll cost(int i,int j,int ii,int jj)&#123; ll H1=sum[j]-sum[i-1]; ll H2=sum[jj]-sum[ii-1]; ll a=min(H1,H2); ll b=max(H1,H2); return a*(log2(b)+1);&#125;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;h[i]); sum[i]=sum[i-1]+h[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; dp[i][j]=inf; &#125; dp[i][i]=0; &#125;//dp[i][j]表示区间[i,j]合并的最小代价，那么自己和自己合并dp[i][i]为0//把区间[i,j]分为两部分[i,k]和[k+1,j]，由最优子结构性质可知dp[i][j]=dp[i][k]+dp[k+1][j]//这样只要在每个长度区间下每次枚举k的位置就行了 for(int len=2;len&lt;=n;len++)&#123; for(int i=1;i+len-1&lt;=n;i++)&#123; int j=i+len-1; for(int k=i;k&lt;=j-1;k++)&#123; dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+cost(i,k,k+1,j)); &#125; &#125; &#125; printf("%lld\n",dp[1][n]); &#125;&#125; 模拟测试2 F-Split去年期末+补考原题 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3fusing namespace std;typedef long long ll;ll dp[55][55];ll a[55],sum[55];int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); sum[i]=sum[i-1]+a[i]; &#125; //dp[i][j]表示前i个数分为j段的最大价值 //起始全部状态初始为负无穷大,dp[i][1]和dp[i][i]容易求得 dp[1][1]=a[1]; for(int i=2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; dp[i][j]=-inf; &#125; dp[i][1]=abs(a[i]-a[1])*i; dp[i][i]=sum[i]; &#125; //对于每个a[i]就两种情况,要么单独作为一段,要么和前面的最后一段合并 for(int i=2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; //i个数最多分为i段 //将a[i]单独作一段 dp[i][j]=max(dp[i][j],dp[i-1][j-1]+a[i]); //将a[i]与前面第j段合并 for(int k=j;k&lt;=i-1;k++)&#123; //枚举前i-1个数第j段的所有可能起始位置,这样就是[1,k-1]分为j-1段,[k-1,i]作为第j段 dp[i][j]=max(dp[i][j],dp[k-1][j-1]+abs(a[i]-a[k])*(i-k+1)); &#125; &#125; &#125; &#125;&#125; 期末考试 E给一个无向带权图，其中图中有k个点是救助站，问图中所有点到最近救助站路程的总和 其实是很简单的一道最短路模板题，稍微改改就行了，考试想复杂了，气气+2 首先我们把k个点看作一个超级源点，那么图中其他点到源点的最短路就也是这个源点到其他所有点的最短路 把这个超级源点和这k个救助站分别加上一条边权为0的边，从这个源点开始跑dij就相当于把这k个点同时丢到优先队列中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3ftypedef __int64 ll;using namespace std;const int maxn = 1e3+5;const int maxm = 1e4+5;int n,m,k;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct node&#123; int val,id; node(int id,int val):id(id),val(val) &#123;&#125; bool operator &lt;(const node &amp;hs)const&#123; return val&gt;hs.val; &#125;&#125;;struct edge&#123; int next,to,w;&#125;e[maxm*2];int head[maxn],cnt;void addedge(int u,int v,int w)&#123; e[++cnt]=edge&#123;head[u],v,w&#125;; head[u]=cnt;&#125;int dis[maxn],vis[maxn];void dijkstra(int from)&#123; for(int i=1;i&lt;=n+1;i++)&#123; dis[i]=INF; vis[i]=0; &#125; priority_queue&lt;node&gt;q; q.push(node(from,0)); dis[from]=0; while(!q.empty())&#123; int cur=q.top().id; q.pop(); if(vis[cur])continue; vis[cur]=true; for(int i=head[cur]; i ; i=e[i].next)&#123; int v=e[i].to; if(dis[cur]+e[i].w &lt; dis[v])&#123; dis[v]=dis[cur]+e[i].w; q.push(node(v,dis[v])); &#125; &#125; &#125;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; n=read(),m=read(),k=read(); cnt=0; for(int i=1;i&lt;=n+1;i++)&#123; head[i]=0; &#125; for(int i=0;i&lt;m;i++)&#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; int X=n+1; for(int i=0;i&lt;k;i++)&#123; int x=read(); addedge(X,x,0); addedge(x,X,0); &#125; dijkstra(X); ll sum=0; bool ok=true; for(int i=1;i&lt;=n;i++)&#123; if(dis[i]==INF)&#123; ok=false; break; &#125; sum+=dis[i]; &#125; if(ok) printf("%I64d\n",sum); else puts("-1"); &#125;&#125; 2019程序设计实践总结就到这，总的来说不是特别满意(还被ericxie点名批评了)，图论和动态规划不是特别掌握，毕竟我主数据结构的呀qwq 一门课程的结束不代表以后永远不会再接触，我觉得程设就是对之前所学的C语言、离散数学、数据结构、Java等课程结合的实践性特别强的一门课程，在职场也一样，面试要求的算法都是平时积累起来的，包括编程语言的掌握程度，所以如果你对算法和编程感兴趣，欢迎通过自己的努力加入湘潭大学ACM集训队。]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>STL</tag>
        <tag>暴力</tag>
        <tag>程序设计实践</tag>
        <tag>模拟</tag>
        <tag>动态规划</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[湖南大学第15届校赛 H-Longest Common Palindrome Substring]]></title>
    <url>%2F%E6%B9%96%E5%8D%97%E5%A4%A7%E5%AD%A6%E7%AC%AC15%E5%B1%8A%E6%A0%A1%E8%B5%9B-H-Longest-Common-Palindrome-Substring.html</url>
    <content type="text"><![CDATA[原题链接 题意：给两个1e5长的字符串，求两者最长公共回文子串长度 思路： manacher 分别求出s,t串的mp[]数组，同时也可以求出对应最长奇回文子串长度(a,c)和最长偶回文子串长度(c,d) 由于manacher求出的是以i为中心的最长回文半径，且长度为len的子串为回文子串,len-2的的子串也为回文子串 那么s,t的最长公共回文子串长度可能是[0,1,3,5,…min(a,c)]和[0,2,4,6,…,min(b,d)]这两个区间内的一个长度 hash预处理字符串，然后分别二分这两个区间，check的时候就要用到mp[]数组来判断二分的长度子串是否为回文子串，注意分奇偶讨论 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn = 1e5+5;char ma[maxn*2];int mp[2][maxn*2];void manacher(char s[],int len,int k)&#123; int l=0; ma[l++]='$'; ma[l++]='#'; for(int i=1;i&lt;=len;i++)&#123; ma[l++]=s[i]; ma[l++]='#'; &#125; ma[l]=0; int mx=0,id=0; for(int i=0;i&lt;l;i++)&#123; mp[k][i]=mx&gt;i?min(mp[k][2*id-i],mx-i):1; while(ma[i+mp[k][i]]==ma[i-mp[k][i]]) mp[k][i]++; if(i+mp[k][i]&gt;mx)&#123; mx=i+mp[k][i]; id=i; &#125; &#125;&#125;char s[maxn],t[maxn];int lens,lent;ull base=233;ull p[maxn],hs[maxn],ht[maxn];ull geths(int l,int r)&#123; return (ull)hs[r]-p[r-l+1]*hs[l-1];&#125;ull getht(int l,int r)&#123; return (ull)ht[r]-p[r-l+1]*ht[l-1];&#125;vector&lt;ull&gt;tmp;bool check(int k)&#123; tmp.clear(); ull ss,tt; for(int i=0;i&lt;2*lens+2;i++)&#123; if(mp[0][i]-1&gt;=k)&#123; if((mp[0][i]-1)&amp;1)&#123; ss=geths(i/2-k/2,i/2+k/2); &#125; else&#123; ss=geths(i/2-k/2+1,i/2+k/2); &#125; tmp.push_back(ss); &#125; &#125; sort(tmp.begin(),tmp.end()); for(int i=0;i&lt;2*lent+2;i++)&#123; if(mp[1][i]-1&gt;=k)&#123; if((mp[1][i]-1)&amp;1)&#123; tt=getht(i/2-k/2,i/2+k/2); &#125; else&#123; tt=getht(i/2-k/2+1,i/2+k/2); &#125; if(binary_search(tmp.begin(),tmp.end(),tt)) return true; &#125; &#125; return false;&#125;int main() &#123; //freopen("in.txt","r",stdin); p[0]=1; for(int i=1;i&lt;maxn;i++)&#123; p[i]=p[i-1]*base; &#125; vector&lt;int&gt;len; while(~scanf("%s%s",s+1,t+1))&#123; lens=strlen(s+1); lent=strlen(t+1); for(int i=1;i&lt;=lens;i++)&#123; hs[i]=hs[i-1]*base+s[i]-'a'; &#125; for(int i=1;i&lt;=lent;i++)&#123; ht[i]=ht[i-1]*base+t[i]-'a'; &#125; int a=0,b=0,c=0,d=0; manacher(s,lens,0); for(int i=0;i&lt;2*lens+2;i++)&#123; int k=mp[0][i]-1; if(k&amp;1) a=max(a,k); else b=max(b,k); &#125; manacher(t,lent,1); for(int i=0;i&lt;2*lent+2;i++)&#123; int k=mp[1][i]-1; if(k&amp;1) c=max(c,k); else d=max(d,k); &#125; int Maxodd=min(a,c),Maxeven=min(b,d); len.clear(); len.push_back(0); for(int i=1;i&lt;=Maxodd;i+=2)&#123; len.push_back(i); &#125; int l=0,r=len.size()-1,ans=0; while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(check(len[mid])) l=mid; else r=mid-1; &#125; ans=max(ans,len[l]); len.clear(); for(int i=0;i&lt;=Maxeven;i+=2)&#123; len.push_back(i); &#125; l=0,r=len.size()-1; while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(check(len[mid])) l=mid; else r=mid-1; &#125; ans=max(ans,len[l]); printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>manacher</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template of ACM]]></title>
    <url>%2FTemplate-of-ACM.html</url>
    <content type="text"><![CDATA[快读1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//C++关闭同步流 切记不要和C风格混用ios::sync_with_stdio(false);cin.tie(0);//正负整数inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;//O2优化#pragma GCC optimize(2)//javaclass InputReader &#123; BufferedReader buf; StringTokenizer tok; InputReader() &#123; buf = new BufferedReader(new InputStreamReader(System.in)); &#125; boolean hasNext() &#123; while (tok == null || !tok.hasMoreElements()) &#123; try &#123; tok = new StringTokenizer(buf.readLine()); &#125; catch (Exception e) &#123; return false; &#125; &#125; return true; &#125; String next() &#123; if (hasNext()) return tok.nextToken(); return null; &#125; int nextInt() &#123; return Integer.parseInt(next()); &#125; long nextLong() &#123; return Long.parseLong(next()); &#125; double nextDouble() &#123; return Double.parseDouble(next()); &#125; BigInteger nextBigInteger() &#123; return new BigInteger(next()); &#125; BigDecimal nextBigDecimal() &#123; return new BigDecimal(next()); &#125;&#125; STL1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;ext/pb_ds/assoc_container.hpp&gt;#include&lt;ext/pb_ds/tree_policy.hpp&gt;//用tree#include&lt;ext/pb_ds/hash_policy.hpp&gt;//用hash#include&lt;ext/pb_ds/trie_policy.hpp&gt;//用trie#include&lt;ext/pb_ds/priority_queue.hpp&gt;//用priority_queueusing namespace __gnu_pbds;//hash表 用法类似map,时间复杂度O(n)cc_hash_table&lt;int,bool&gt; h; //拉链法较慢gp_hash_table&lt;int,bool&gt; h; //探测法较快// 平衡树 以下操作时间复杂度均为O(logn)struct team&#123; int t,p,id; bool operator &lt;(const team&amp;hs)const&#123; return t!=hs.t?t&gt;hs.t:p!=hs.p?p&lt;hs.p:id&lt;hs.id; &#125;&#125;typedef tree&lt;team,null_type,less&lt;team&gt;,rb_tree_tag,tree_order_statistics_node_update&gt; rebtree;null_type //无映射(低版本g++为null_mapped_type)less&lt;T&gt; //从小到大排序rb_tree_tag //红黑树tree_order_statistics_node_update //更新方式tr.insert(x); //插入;tr.erase(x); //删除;tr.order_of_key(x); //求比x小的个数 rank=res+1tr.find_by_order(k-1); //找k小值,返回迭代器 k值非法，则会返回end()tr.join(b); //将b并入tr,前提是两棵树类型一样且没有重复元素tr.split(v,b); //分裂,key小于等于v的元素属于tr,其余的属于btr.lower_bound(x); //返回第一个&gt;=x的元素的迭代器 x的前驱 *--tr.lower_bound(x)tr.upper_bound(x); //返回第一个&gt;x的元素的迭代器 x的后继 *tr.lower_bound(x)//迭代器支持++,--操作//堆priority_queue&lt;int,greater&lt;int&gt;,TAG&gt; Q; //注意命名空间别和std中的那个重了/*其中的TAG为类型，有以下几种：pairing_heap_tag //最快thin_heap_tagbinomial_heap_tagrc_binomial_heap_tagbinary_heap_tag*/__gnu_pbds::priority_queue&lt;int&gt;::point_iterator it; //支持迭代器Q.push(x); //push()会返回迭代器,用一个迭代器数组保存所有进队列的元素的迭代器，就可以持久化操作Q.pop();Q.top();Q.join(b);Q.empty();Q.size();Q.modify(it,6);Q.erase(it);//rope 时间复杂度O(logN)#include &lt;ext/rope&gt;using namespace __gnu_cxx;rope&lt;int&gt; r;push_back(x) 在末尾添加xinsert(pos,x) 在pos插入xerase(pos,x) 从pos开始删除x个copy(pos,len,x) 从pos开始到pos+len为止用x代替replace(pos,x) 从pos开始换成xsubstr(pos,x) 提取pos开始x个at(x)/[x] 访问第x个元素//可持久化 O(1)复制根节点rope&lt;char&gt; *his[maxn];his[0] = new rope&lt;char&gt;();his[i] = new rope&lt;char&gt;(*his[i-1]);//list 合并操作void merge(list &lt;T&gt; &amp; x) //将链表x合并进来并清空x,要求链表自身和x都是有序的void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x ); //在position后把list&amp;x所有的元素到剪接到要操作的list对象void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x, iterator it ); //只会把it的值剪接到要操作的list对象中void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x, iterator first, iterator last ); //把first到last剪接到要操作的list对象中//O(n)查询第k大nth_element(a+1,a+k,a+1+n); ST表12345678910111213141516171819202122232425262728293031323334353637383940414243444546//f[i][j]表示区间[i,i+2^j-1]的最值//一维void ST()&#123; for(int i=1;i&lt;=n;i++) d[i][0]=f[i][0]=a[i]; int t=log(n)/log(2); for(int j=1;j&lt;=t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125;int querymax(int l,int r)&#123; int k=log(r-l+1)/log(2); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125;//二维void init() &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; scanf("%d", &amp;val[i][j]); dp[i][j][0][0] = val[i][j]; &#125; for (int i = 0; (1 &lt;&lt; i) &lt;= n; i++) &#123; for (int j = 0; (1 &lt;&lt; j) &lt;= m; j++) &#123; if (i == 0 &amp;&amp; j == 0) continue; for (int row = 1; row + (1 &lt;&lt; i) - 1 &lt;= n; row++) for (int col = 1; col + (1 &lt;&lt; j) - 1 &lt;= m; col++) &#123; //当x或y等于0的时候，就相当于一维的RMQ if (i == 0) dp[row][col][i][j] = max(dp[row][col][i][j - 1], dp[row][col + (1 &lt;&lt; (j - 1))][i][j - 1]); else if (j == 0) dp[row][col][i][j] = max(dp[row][col][i - 1][j], dp[row + (1 &lt;&lt; (i - 1))][col][i - 1][j]); else dp[row][col][i][j] = max(dp[row][col][i][j - 1], dp[row][col + (1 &lt;&lt; (j - 1))][i][j - 1]); &#125; &#125; &#125;&#125;int Query(int x1, int y1, int x2, int y2) &#123; int kx = 0, ky = 0; while (x1 + (1 &lt;&lt; (1 + kx)) - 1 &lt;= x2) kx++; while (y1 + (1 &lt;&lt; (1 + ky)) - 1 &lt;= y2) ky++; int m1 = dp[x1][y1][kx][ky]; int m2 = dp[x2 - (1 &lt;&lt; kx) + 1][y1][kx][ky]; int m3 = dp[x1][y2 - (1 &lt;&lt; ky) + 1][kx][ky]; int m4 = dp[x2 - (1 &lt;&lt; kx) + 1][y2 - (1 &lt;&lt; ky) + 1][kx][ky]; return max(max(m1, m2), max(m3, m4));&#125; KMP123456789101112131415161718192021222324//next[i] 表示t[i-next[i]...i-1]=t[0...next[i]-1]//循环节len=m%(m-next[m])==0?m-next[m]:1void getNext(char t[],int m)&#123; int i,j; j=Next[0]=-1; i=0; while(i&lt;m)&#123; while(j!=-1&amp;&amp;t[i]!=t[j]) j=Next[j]; Next[++i]=++j; //if(t[++i]==t[++j]) Next[i]=Next[j]; //优化 //else Next[i]=j; &#125;&#125;int kmp(char s[],int n,char t[],int m)&#123; getNext(t,m); int i=0,j=0; while(i&lt;n)&#123; while(j==-1&amp;&amp;s[i]!=t[j]) j=next[j]; i++,j++; if(j&gt;=m)&#123; //匹配成功 ; &#125; &#125;&#125; ExtendKMP12345678910111213141516171819202122232425262728293031323334353637383940//next[i]表示t[i...m-1]与t[0...m-1]的最长公共前缀//extend[i]表示s[i...n-1]与t[0...m-1]的最长公共前缀int Next[maxn],extend[maxn];void getNext(char t[],int m)&#123; Next[0]=m; int j=0; while(j+1&lt;m&amp;&amp;t[j]==t[j+1]) j++; Next[1]=j; int k=1; for(int i=2;i&lt;m;i++)&#123; int p=Next[k]+k-1; int L=Next[i-k]; if(i+L&lt;p+1) Next[i]=L; else &#123; j=max(0,p-i+1); while(i+j&lt;m&amp;&amp;t[i+j]==t[j]) j++; Next[i]=j; k=i; &#125; &#125;&#125;void extendkmp(char t[],int m,char s[],int n)&#123; getNext(t,m); int j=0; while(j&lt;n&amp;&amp;j&lt;m&amp;&amp;t[j]==s[j]) j++; extend[0]=j; int k=0; for(int i=1;i&lt;n;i++)&#123; int p=extend[k]+k-1; int L=Next[i-k]; if(i+L&lt;p+1) extend[i]=L; else &#123; j=max(0,p-i+1); while(i+j&lt;n&amp;&amp;j&lt;m&amp;&amp;s[i+j]==t[j]) j++; extend[i]=j; k=i; &#125; &#125;&#125; 最小表示法123456789101112131415161718//取得最小表示法下标的开始位置int getmin(char s[],int n)&#123; for(int i=1;i&lt;=n;i++) s[n+i]=s[i]; int i=1,j=2,k; while(i&lt;=n&amp;&amp;j&lt;=n)&#123; for(k=0;k&lt;=n&amp;&amp;s[i+k]==s[j+k];k++); if(k==n) break; if(s[i+k]&gt;s[j+k])&#123; //s[i+k]&lt;s[j+k]最大表示法 i=i+k+1; if(i==j) i++; &#125; else&#123; j=j+k+1; if(i==j) i++; &#125; &#125; return min(i,j);&#125; 字符串Hash1234567891011121314151617181920typedef unsigned long long ull;char s[maxn],t[maxn];int lens,lent;ull base=233; //冲突可换其它素数ull p[maxn],hs[maxn];ull geths(int l,int r)&#123; return (ull)hs[r]-p[r-l+1]*hs[l-1];&#125;p[0]=1;for(int i=1;i&lt;maxn;i++)&#123; p[i]=p[i-1]*base;&#125;scanf("%s%s",s+1,t+1);lens=strlen(s+1);lent=strlen(t+1);for(int i=1;i&lt;=lens;i++)&#123; hs[i]=hs[i-1]*base+s[i];&#125; Manacher1234567891011121314151617181920212223//mp[i]表示以i为中心的最长回文的半径，mp[i]-1为原串中最长回文串的长度//mp[0...2*n+1]/2 求和即为所有子串中回文子串个数char ma[maxn*2];int mp[maxn*2];void manacher(char s[],int len)&#123; int l=0; ma[l++]='$'; ma[l++]='#'; for(int i=0;i&lt;len;i++)&#123; ma[l++]=s[i]; ma[l++]='#'; &#125; ma[l]=0; int mx=0,id=0; for(int i=0;i&lt;l;i++)&#123; mp[i]=mx&gt;i?min(mp[2*id-i],mx-i):1; while(ma[i+mp[i]]==ma[i-mp[i]]) mp[i]++; if(i+mp[i]&gt;mx)&#123; mx=i+mp[i]; id=i; &#125; &#125;&#125; Trie1234567891011121314151617181920212223struct trie &#123; int nex[maxn][26],cnt; bool exist[maxn]; // 该结点结尾的字符串是否存在 void Insert(char s[], int len) &#123; int p = 0; for (int i = 0; i &lt; len; i++) &#123; int c = s[i] - 'a'; if (!nex[p][c]) nex[p][c] = ++cnt; p = nex[p][c]; &#125; exist[p] = 1; &#125; bool Find(char s[], int len) &#123; int p = 0; for (int i = 0; i &lt; len; i++) &#123; int c = s[i] - 'a'; if (!nex[p][c]) return 0; p = nex[p][c]; &#125; return exist[p]; &#125;&#125;; AC自动机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124//查询多个模式串在文本串中出现了多少次#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e6+6;namespace AC&#123; int tr[N][26],tot; int e[N],fail[N]; void init()&#123; memset(tr,0,sizeof(tr)); memset(e,0,sizeof(e)); memset(fail,0,sizeof(fail)); tot=0; &#125; void Insert(char *s)&#123; int u=0; for(int i=1;s[i];i++)&#123; if(!tr[u][s[i]-'a'])tr[u][s[i]-'a']=++tot; u=tr[u][s[i]-'a']; &#125; e[u]++; &#125; queue&lt;int&gt; q; void build()&#123; for(int i=0;i&lt;26;i++)if(tr[0][i])q.push(tr[0][i]); while(q.size())&#123; int u=q.front();q.pop(); for(int i=0;i&lt;26;i++)&#123; if(tr[u][i])fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]); else tr[u][i]=tr[fail[u]][i]; &#125; &#125; &#125; int query(char *t)&#123; int u=0,res=0; for(int i=1;t[i];i++)&#123; u=tr[u][t[i]-'a'];// 转移 for(int j=u;j&amp;&amp;e[j]!=-1;j=fail[j])&#123; res+=e[j],e[j]=-1; &#125; &#125; return res; &#125;&#125;char s[N];int main()&#123; int T;scanf("%d",&amp;T); while(T--)&#123; int n;scanf("%d",&amp;n); AC::init(); for(int i=1;i&lt;=n;i++)scanf("%s",s+1),AC::Insert(s); scanf("%s",s+1); AC::build(); printf("%d\n",AC::query(s)); &#125; return 0;&#125;/*有N个由小写字母组成的模式串以及一个文本串T每个模式串可能会在文本串中出现多次。你需要找出哪些模式串在文本串T中出现的次数最多*/#include&lt;bits/stdc++.h&gt;using namespace std;const int N=155,L=1e6+5;namespace AC&#123; const int SZ=N*80; int tot,tr[SZ][26]; int fail[SZ],idx[SZ],val[SZ]; int cnt[N];// 记录第 i 个字符串的出现次数 void init()&#123; memset(fail,0,sizeof(fail)); memset(tr,0,sizeof(tr)); memset(val,0,sizeof(val)); memset(cnt,0,sizeof(cnt)); memset(idx,0,sizeof(idx)); tot=0; &#125; void Insert(char *s,int id)&#123;//id 表示原始字符串的编号 int u=0; for(int i=1;s[i];i++)&#123; if(!tr[u][s[i]-'a'])tr[u][s[i]-'a']=++tot; u=tr[u][s[i]-'a']; &#125; idx[u]=id; &#125; queue&lt;int&gt; q; void build()&#123; for(int i=0;i&lt;26;i++)if(tr[0][i])q.push(tr[0][i]); while(q.size())&#123; int u=q.front();q.pop(); for(int i=0;i&lt;26;i++)&#123; if(tr[u][i])fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]); else tr[u][i]=tr[fail[u]][i]; &#125; &#125; &#125; int query(char *t)&#123;// 返回最大的出现次数 int u=0,res=0; for(int i=1;t[i];i++)&#123; u=tr[u][t[i]-'a']; for(int j=u;j;j=fail[j])val[j]++; &#125; for(int i=0;i&lt;=tot;i++)if(idx[i])res=max(res,val[i]),cnt[idx[i]]=val[i]; return res; &#125;&#125;int n;char s[N][100],t[L];int main()&#123; while(~scanf("%d",&amp;n))&#123;if(n==0)break; AC::init(); for(int i=1;i&lt;=n;i++)scanf("%s",s[i]+1),AC::Insert(s[i],i); AC::build(); scanf("%s",t+1); int x=AC::query(t); printf("%d\n",x); for(int i=1;i&lt;=n;i++)if(AC::cnt[i]==x)printf("%s\n",s[i]+1); &#125; return 0;&#125; 回文自动机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/*1.求串S前缀0~i内本质不同回文串的个数（两个串长度不同或者长度相同且至少有一个字符不同便是本质不同）2.求串S内每一个本质不同回文串出现的次数3.求串S内回文串的个数（其实就是1和2结合起来） p-24.求以下标i结尾的回文串的个数*/#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 300005 ;const int N = 26 ;struct Palindromic_Tree &#123; int next[maxn][N] ;//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成 int fail[maxn] ;//fail指针，失配后跳转到fail指针指向的节点 int cnt[maxn] ; //在最后统计后它可以表示形如以i为结尾的回文串中最长的那个串个数 int num[maxn] ; //表示以i结尾的回文串的种类数 int len[maxn] ;//len[i]表示节点i表示的回文串的长度 int S[maxn] ;//存放添加的字符 int last ;//指向上一个字符所在的节点，方便下一次add int n ;//字符数组指针 int p ;//节点指针 int newnode ( int l ) &#123; for ( int i = 0 ; i &lt; N ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123;//初始化 p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1 ; &#125; int get_fail ( int x ) &#123;//和KMP一样，失配后找一个尽量最长的 while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; void add ( int c ) &#123; c -= 'a' ; S[++ n] = c ; int cur = get_fail ( last ) ;//通过上一个回文串找这个回文串的匹配位置 if ( !next[cur][c] ) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode ( len[cur] + 2 ) ;//新建节点 fail[now] = next[get_fail ( fail[cur] )][c] ;//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; &#125; last = next[cur][c] ; cnt[last] ++ ; &#125; void Count () &#123; for ( int i = p - 1 ; i &gt;= 0 ; -- i ) cnt[fail[i]] += cnt[i] ; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！ ll ans=0; for(int i=p-1;i&gt;=0;--i)&#123; ans=max(ans,cnt[i]*(ll)len[i]); &#125; printf("%lld\n",ans); &#125;&#125; ptree;char s[maxn];int main()&#123;// scanf("%s",s);// ptree.init();// int lens=strlen(s);// for(int i=0;i&lt;lens;i++)&#123;// ptree.add(s[i]);// &#125;// ptree.Count(); int T;scanf("%d",&amp;T); for(int ca=1;ca&lt;=T;ca++)&#123; scanf("%s",s); int lens=strlen(s); ptree.init(); for(int i=0;i&lt;lens;i++)&#123; ptree.add(s[i]); &#125; printf("Case #%d: %d\n",ca,ptree.p-2); &#125;&#125; 二维树状数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//单点修改+区间查询/*求(x1,y1)~(x2,y2)的sumsum=sum(x2,y2)-sum(x1-1,y2)-sum(x2,y1-1)+sum(x1-1,y1-1)*/void add(int x,int y,int v) &#123; while(x&lt;=n) &#123; int ty=y; while(ty&lt;=n) c[x][ty]+=v,ty+=lowbit(ty); x+=lowbit(x); &#125;&#125;int sum(int x,int y) &#123; int res=0; while(x) &#123; int ty=y; while(ty) res+=c[x][ty],ty-=lowbit(ty); x-=lowbit(x); &#125; return res;&#125;//区间修改+单点查询void add(int x,int y,int v) &#123; while(x&lt;=n) &#123; int ty=y; while(ty&lt;=n) c[x][ty]+=v,ty+=lowbit(ty); x+=lowbit(x); &#125;&#125;void real_add(int x1,int y1,int x2,int y2,int v) &#123; add(x1,y1,v); add(x1,y2+1,-v); add(x2+1,y1,-v); add(x2+1,y2+1,v);&#125;int sum(int x, int y) &#123; int res=0; while(x) &#123; int ty=y; while(ty) res+=c[x][ty],ty-=lowbit(ty); x-=lowbit(x); &#125; return res;&#125;//区间修改+区间查询void add(int x,int y,int v) &#123; for(int i=x; i&lt;=n; i+=lowbit(i)) for(int j=y; j&lt;=m; j+=lowbit(j)) &#123; t1[i][j]+=v; t2[i][j]+=v*x; t3[i][j]+=v*y; t4[i][j]+=v*x*y; &#125;&#125;void real_add(int x1,int y1,int x2,int y2,int v) &#123; add(x1,y1,v); add(x1,y2+1,-v); add(x2+1,y1,-v); add(x2+1,y2+1,v);&#125;int sum(int x, int y) &#123; int res=0; for(int i=x; i; i-=lowbit(i)) for(int j=y; j; j-=lowbit(j)) res+=(x+1)*(y+1)*t1[i][j]-(y+1)*t2[i][j]-(x+1)*t3[i][j]+t4[i][j]; return res;&#125;int real_sum(int x1,int y1,int x2,int y2) &#123; return sum(x2,y2)-sum(x2,y1-1)-sum(x1-1,y2)+sum(x1-1,y1-1);&#125; 树链剖分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202//点权版#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1const int maxn = 1e5+10;const int maxm = 1e5+10;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;struct edge&#123; int next,to;&#125;e[maxm*2];int head[maxn],cnt;void addedge(int u,int v)&#123; e[++cnt]=edge&#123;head[u],v&#125;; head[u]=cnt;&#125;int n,m,root,P;int w[maxn];int fa[maxn],deep[maxn],siz[maxn],son[maxn],rk[maxn],top[maxn],id[maxn];void dfs1(int u,int pre,int dep)&#123; fa[u]=pre;deep[u]=dep;siz[u]=1; for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v==pre)continue; dfs1(v,u,dep+1); siz[u]+=siz[v]; if(siz[v]&gt;siz[son[u]])son[u]=v; &#125;&#125;void dfs2(int u,int t)&#123; top[u]=t;id[u]=++cnt;rk[cnt]=u; if(!son[u])return; dfs2(son[u],t); for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v!=son[u]&amp;&amp;v!=fa[u])dfs2(v,v); &#125;&#125;/*************************************/int sum[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2];void push_up(int o)&#123; sum[o]=sum[o&lt;&lt;1]+sum[o&lt;&lt;1|1];&#125;void push_down(int ls,int rs,int o)&#123; if(lazy[o])&#123; sum[o&lt;&lt;1]=(sum[o&lt;&lt;1]+lazy[o]*ls)%P; sum[o&lt;&lt;1|1]=(sum[o&lt;&lt;1|1]+lazy[o]*rs)%P; lazy[o&lt;&lt;1]=(lazy[o&lt;&lt;1]+lazy[o])%P; lazy[o&lt;&lt;1|1]=(lazy[o&lt;&lt;1|1]+lazy[o])%P; lazy[o]=0; &#125;&#125;void build(int l,int r,int o)&#123; if(l==r)&#123; sum[o]=w[rk[l]]; //重新编号后的 return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(o);&#125;void update(int L,int R,int v,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; sum[o]=(sum[o]+v*(r-l+1))%P; lazy[o]=(lazy[o]+v)%P; return; &#125; int mid=(l+r)&gt;&gt;1; push_down(mid-l+1,r-mid,o); if(L&lt;=mid) update(L,R,v,lson); if(R&gt;mid) update(L,R,v,rson); push_up(o);&#125;int querysum(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return sum[o]; &#125; int mid=(l+r)&gt;&gt;1,ret=0; push_down(mid-l+1,r-mid,o); if(L&lt;=mid) ret=(ret+querysum(L,R,lson))%P; if(R&gt;mid) ret=(ret+querysum(L,R,rson))%P; return ret;&#125;void PathUpdate(int x,int y,int v)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); update(id[top[x]],id[x],v,1,n,1); x=fa[top[x]]; &#125; if(id[x]&gt;id[y]) swap(x,y); update(id[x],id[y],v,1,n,1);&#125;int PathQuery(int x,int y)&#123; int ret=0; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); ret=(ret+querysum(id[top[x]],id[x],1,n,1))%P; x=fa[top[x]]; &#125; if(id[x]&gt;id[y])swap(x,y); ret=(ret+querysum(id[x],id[y],1,n,1))%P; return ret;&#125;int main()&#123; n=read(),m=read(),root=read(),P=read(); for(int i=1;i&lt;=n;i++)&#123; w[i]=read(); &#125; cnt=0; for(int i=1;i&lt;=n;i++) head[i]=0; for(int i=0;i&lt;n-1;i++)&#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; cnt=0; dfs1(root,0,1); //注意根节点不一定是1 dfs2(root,root); build(1,n,1); while(m--)&#123; int op=read(),x,y,z; if(op==1)&#123; //更新x-y最短路径上所有点 x=read(),y=read(),z=read(); PathUpdate(x,y,z); &#125; else if(op==2)&#123; //查询x-y最短路径上所有点 x=read(),y=read(); printf("%d\n",PathQuery(x,y)); &#125; else if(op==3)&#123; //更新以x为根节点的子树 x=read(),z=read(); update(id[x],id[x]+siz[x]-1,z,1,n,1); &#125; else&#123; //查询以x为根节点的子树 x=read(); printf("%d\n",querysum(id[x],id[x]+siz[x]-1,1,n,1)); &#125; &#125;&#125;//边权版int fa[maxn],deep[maxn],siz[maxn],son[maxn],rk[maxn],top[maxn],id[maxn];int dis[maxn],w[maxn];void dfs1(int u,int pre,int dep)&#123; fa[u]=pre;deep[u]=dep;siz[u]=1; for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v==pre)continue; dis[v]=dis[u]+e[i].v; dfs1(v,u,dep+1); siz[u]+=siz[v]; if(siz[v]&gt;siz[son[u]])son[u]=v; &#125;&#125;void dfs2(int u,int t)&#123; top[u]=t;id[u]=++cnt;rk[cnt]=u; if(!son[u])return; dfs2(son[u],t); for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(v!=son[u]&amp;&amp;v!=fa[u])dfs2(v,v); &#125;&#125;int PathQuery(int x,int y)&#123; int ans=0; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); ans=max(ans,query(id[top[x]],id[x],1,n,1)); x=fa[top[x]]; &#125; if(x==y)return ans; if(deep[x]&gt;deep[y]) swap(x,y); ans=max(ans,query(id[son[x]],id[y],1,n,1)); return ans;&#125;void PathUpdate(int x,int y,int v)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); update(id[top[x]],id[x],v,1,n,1); x=fa[top[x]]; &#125; if(x==y)return; if(deep[x]&gt;deep[y]) swap(x,y); update(id[son[x]],id[y],v,1,n,1);&#125;for(int i=0;i&lt;n-1;i++)&#123; if(deep[E[i].u]&lt;deep[E[i].v]) swap(E[i].u,E[i].v); w[E[i].u]=E[i].w; //边权放在下面结点上变为点权&#125; LCA123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//倍增法int deep[maxn],f[maxn],dis[maxn],p[maxn][30];void dfs(int x,int pre,int d)&#123; deep[x]=d; f[x]=pre; for(int i=head[x];i;i=e[i].next)&#123; int to=e[i].to; if(to!=pre)&#123; dis[to]=dis[x]+e[i].w; dfs(to,x,d+1); &#125; &#125;&#125;void init()&#123; //p[i][j]表示i结点的第2^j祖先 for(int j=0;(1&lt;&lt;j)&lt;=n;j++) for(int i=1;i&lt;=n;i++) p[i][j]=-1; for(int i=1;i&lt;=n;i++)p[i][0]=f[i]; for(int j=1;(1&lt;&lt;j)&lt;=n;j++) for(int i=1;i&lt;=n;i++) if(p[i][j-1]!=-1) p[i][j]=p[p[i][j-1]][j-1];//i的第2^j祖先就是i的第2^(j-1)祖先的第2^(j-1)祖先&#125;int LCA(int a,int b)&#123; int i,j; if(deep[a]&lt;deep[b])swap(a,b); for(i=0;(1&lt;&lt;i)&lt;=deep[a];i++); i--; //使a,b两点的深度相同 for(j=i;j&gt;=0;j--) if(deep[a]-(1&lt;&lt;j)&gt;=deep[b]) a=p[a][j]; if(a==b)return a; //倍增法，每次向上进深度2^j，找到最近公共祖先的子结点 for(j=i;j&gt;=0;j--)&#123; if(p[a][j]!=-1&amp;&amp;p[a][j]!=p[b][j])&#123; a=p[a][j]; b=p[b][j]; &#125; &#125; return f[a];&#125;//树链剖分int query_lca(int x,int y)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]])swap(x,y); x=fa[top[x]]; &#125;return deep[x]&lt;deep[y]?x:y;&#125; 主席树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//静态区间第k小#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+10;int n,q,m,tot;int a[maxn],t[maxn];int T[maxn*20],lson[maxn*20],rson[maxn*20],c[maxn*20];void init_hs() &#123; for(int i=1; i&lt;=n; i++) &#123; t[i]=a[i]; &#125; sort(t+1,t+1+n); m = unique(t+1,t+1+n)-t-1;&#125;int build(int l,int r) &#123; int root=tot++; c[root]=0; if(l!=r) &#123; int mid=l+r&gt;&gt;1; lson[root]=build(l,mid); rson[root]=build(mid+1,r); &#125; return root;&#125;int hs(int x) &#123; return lower_bound(t+1,t+1+m,x)-t;&#125;int update(int root,int pos,int val) &#123; int newroot=tot++,tmp=newroot; c[newroot]=c[root]+val; int l=1,r=m; while(l&lt;r) &#123; int mid=l+r&gt;&gt;1; if(pos&lt;=mid) &#123; lson[newroot]=tot++; rson[newroot]=rson[root]; newroot=lson[newroot]; root=lson[root]; r=mid; &#125; else &#123; rson[newroot]=tot++; lson[newroot]=lson[root]; newroot=rson[newroot]; root=rson[root]; l=mid+1; &#125; c[newroot]=c[root]+val; &#125; return tmp;&#125;int query(int left_root,int right_root,int k) &#123; int l=1,r=m; while(l&lt;r) &#123; int mid=l+r&gt;&gt;1; if(c[lson[left_root]] - c[lson[right_root]] &gt;= k) &#123; r=mid; left_root=lson[left_root]; right_root=lson[right_root]; &#125; else &#123; l=mid+1; k-=c[lson[left_root]]-c[lson[right_root]]; left_root=rson[left_root]; right_root=rson[right_root]; &#125; &#125; return l;&#125;int main() &#123; while(~scanf("%d%d",&amp;n,&amp;q)) &#123; for(int i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;a[i]); &#125; tot=0; init_hs(); T[n+1]=build(1,m); for(int i=n; i; i--) &#123; int pos = hs(a[i]); T[i] = update(T[i+1],pos,1); &#125; while(q--) &#123; int l,r; scanf("%d%d",&amp;l,&amp;r); int len=r-l+1; ll ans=-1,x,y,z; for(int i=0; i&lt;len-2; i++) &#123; x = t[query(T[l],T[r+1],len-i)]; y = t[query(T[l],T[r+1],len-i-1)]; z = t[query(T[l],T[r+1],len-i-2)]; if(x&lt;y+z) &#123; ans=x+y+z; break; &#125; &#125; printf("%lld\n",ans); &#125; &#125;&#125; Splay123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379/*您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：1.插入 x 数2.删除 x 数(若有多个相同的数，因只删除一个)3.查询 x 数的排名(排名定义为比当前数小的数的个数 +1+1 。若有多个相同的数，因输出最小的排名)4.查询排名为 x 的数5.求 x 的前驱(前驱定义为小于 x ，且最大的数)6.求 x 的后继(后继定义为大于 x ，且最小的数)*/#include&lt;bits/stdc++.h&gt;#define mes(a,b) memset(a,b,sizeof(a))using namespace std;const int N = 1e5+5;int son[N][2],f[N],cou[N],siz[N],key[N];int root,sz;void clear(int x) &#123; son[x][0]=son[x][1]=cou[x]=f[x]=siz[x]=key[x]=0;&#125;bool get(int x) &#123; return son[f[x]][1]==x;&#125;void update(int x) &#123; if(x) &#123; siz[x]=cou[x]; if(son[x][0])siz[x]+=siz[son[x][0]]; if(son[x][1])siz[x]+=siz[son[x][1]]; &#125;&#125;void rotate(int x) &#123; int old=f[x],oldf=f[old],whichson=get(x); son[old][whichson]=son[x][whichson^1],f[son[old][whichson]]=old; son[x][whichson^1]=old,f[old]=x; f[x]=oldf; if(oldf) &#123; son[oldf][son[oldf][1]==old]=x; &#125; update(old); update(x);&#125;void splay(int x) &#123; for(int fa; (fa=f[x]); rotate(x)) &#123; if(f[fa]) &#123; rotate((get(x)==get(fa))?fa:x); &#125; &#125; root=x;&#125;void insert(int x) &#123; if(root==0) &#123; sz++; son[sz][0]=son[sz][1]=f[sz]=0; key[sz]=x; cou[sz]=siz[sz]=1; root=sz; return; &#125; int now=root,fa=0; while(1) &#123; if(x==key[now]) &#123; cou[now]++; update(now); update(fa); splay(now); break; &#125; fa=now; now=son[now][key[now]&lt;x]; if(now==0) &#123; sz++; f[sz]=fa; son[sz][0]=son[sz][1]=0; cou[sz]=siz[sz]=1; son[fa][key[fa]&lt;x]=sz; key[sz]=x; update(fa); splay(sz); break; &#125; &#125;&#125;int find(int x) &#123; int now=root,ans=0; while(1) &#123; if(x&lt;key[now]) &#123; now=son[now][0]; &#125; else &#123; ans+=(son[now][0]?siz[son[now][0]]:0); if(x==key[now]) &#123; splay(now); return ans+1; &#125; ans+=cou[now]; now=son[now][1]; &#125; &#125;&#125;int findx(int x) &#123; int now=root; while(1) &#123; if(son[now][0] &amp;&amp; x&lt;=siz[son[now][0]]) &#123; now=son[now][0]; &#125; else &#123; int temp=(son[now][0]?siz[son[now][0]]:0)+cou[now]; if(x&lt;=temp)return key[now]; x-=temp; now=son[now][1]; &#125; &#125;&#125;int pre() &#123; int now=son[root][0]; while(son[now][1])now=son[now][1]; return now;&#125;int next() &#123; int now=son[root][1]; while(son[now][0])now=son[now][0]; return now;&#125;void del(int x) &#123; int whatever=find(x); if(cou[root]&gt;1) &#123; cou[root]--; update(root); return; &#125; if(!son[root][0] &amp;&amp; !son[root][1]) &#123; clear(root); root=0; return; &#125; if(!son[root][0]) &#123; int oldroot=root; root=son[root][1]; f[root]=0; clear(oldroot); return; &#125; if(!son[root][1]) &#123; int oldroot=root; root=son[root][0]; f[root]=0; clear(oldroot); return; &#125; int leftbig=pre(),oldroot=root; splay(leftbig); son[root][1]=son[oldroot][1]; f[son[root][1]]=root; clear(oldroot); update(root); return;&#125;int main() &#123; int n; scanf("%d",&amp;n); int op,x; for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;op,&amp;x); switch(op)&#123; case 1:insert(x);break; case 2:del(x);break; case 3:printf("%d\n",find(x));break; case 4:printf("%d\n",findx(x));break; case 5:insert(x);printf("%d\n",key[pre()]);del(x);break; case 6:insert(x);printf("%d\n",key[next()]);del(x);break; &#125; &#125;&#125;/*给出一个数字序列，有6种操作： （1） ADD x y d： 第x个数到第y个数加d 。 （2） REVERSE x y ： 将区间[x,y]中的数翻转 。 （3） REVOLVE x y t ：将区间[x,y]旋转t次，如1 2 3 4 5 旋转2次后就变成4 5 1 2 3 。 （4） INSERT x p ：在第x个数后面插入p 。 （5）DELETE x ：删除第x个数 。 （6） MIN x y ： 查询区间[x,y]中的最小值 。*/#pragma GCC optimize(2)#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;const int maxn = 2e5+5;struct SplayTree &#123; int n, root; ll Val[maxn],Sum[maxn]; int Add[maxn], Min[maxn], Rev[maxn]; int fa[maxn], c[maxn][2], size[maxn]; void init() &#123; n = root = 0; memset(c, 0, sizeof(c)); memset(fa, 0, sizeof(fa)); &#125; void Push_up(int u) &#123; Min[u] = Val[u]; size[u] = size[c[u][0]] + size[c[u][1]] + 1; Sum[u] = Sum[c[u][0]] + Sum[c[u][1]] + Val[u]; if(c[u][0]) Min[u] = min(Min[u], Min[c[u][0]]); if(c[u][1]) Min[u] = min(Min[u], Min[c[u][1]]); &#125; void Push(int u) &#123; if(fa[u]) Push(fa[u]); Push_down(u); &#125; void Push_down(int u) &#123; if(Add[u]) &#123; ll w = Add[u]; if(c[u][0]) Add[c[u][0]]+=w,Val[c[u][0]]+=w,Min[c[u][0]]+=w,Sum[c[u][0]]+=w*size[c[u][0]]; if(c[u][1]) Add[c[u][1]]+=w,Val[c[u][1]]+=w,Min[c[u][1]]+=w,Sum[c[u][1]]+=w*size[c[u][1]]; &#125; if(Rev[u]) &#123; if(c[u][0]) Rev[c[u][0]] ^= 1; if(c[u][1]) Rev[c[u][1]] ^= 1; swap(c[u][0], c[u][1]); &#125; Add[u]=Rev[u]=0; &#125; int Newnode(int key) &#123; size[++n] = 1; Add[n] = Rev[n] = 0; Val[n] = Min[n] = Sum[n] = key; return n; &#125; void rotate(int u) &#123; int v = fa[u], w = fa[v], t = c[v][1] == u; fa[c[u][t^1]] = v, c[v][t] = c[u][t^1]; c[u][t^1] = v, fa[u] = w, fa[v] = u; if(root==v) root = u; else c[w][c[w][1]==v] = u; Push_up(v); &#125; void Splay(int u, int p) &#123; Push(u); while(fa[u] != p) &#123; int v = fa[u], w = fa[v]; if(fa[v] == p) rotate(u); else if((c[v][0] == u) == (c[w][0] == v)) rotate(v), rotate(u); else rotate(u), rotate(u); &#125; Push_up(u); &#125; void insert(int key) &#123; Newnode(key); c[root][1] = n; fa[n] = root; Splay(n, 0); &#125; int find(int u, int k) &#123; Push_down(u); int t = size[c[u][0]] + 1; if(t == k) return u; else &#123; if(t &gt; k) return find(c[u][0], k); else return find(c[u][1], k-t); &#125; &#125; void update(int u, int v, int w) &#123; int x = find(root, u), y = find(root, v+2); Splay(x, 0), Splay(y, root); Add[c[y][0]] += w; Val[c[y][0]] += w; Min[c[y][0]] += w; Sum[c[y][0]] += w*size[c[y][0]]; &#125; void Reverse(int u, int v) &#123; int x = find(root, u), y = find(root, v+2); Splay(x, 0), Splay(y, root); Rev[c[y][0]] ^= 1; &#125; void Revolve(int u, int v, int w) &#123; int m = v - u + 1; w %= m; w = (w + m) % m; int x = find(root, u), y = find(root, u+1); int _x = find(root, v-w+1), _y = find(root, v+2); Splay(_x, 0), Splay(_y, root); int p = c[_y][0]; c[_y][0] = 0; Splay(x, 0), Splay(y, root); c[y][0] = p; fa[p] = y; &#125; void Join(int u, int v) &#123; int x = find(root, u+1), y = find(root, u+2); Splay(x, 0), Splay(y, root); c[y][0] = Newnode(v); fa[n] = y; &#125; void del(int u) &#123; int x = find(root, u), y = find(root, u+2); Splay(x, 0), Splay(y, root); c[y][0] = 0; &#125; int querymin(int u, int v) &#123; int x = find(root, u), y = find(root, v+2); Splay(x, 0), Splay(y, root); return Min[c[y][0]]; &#125; ll querysum(int u,int v)&#123; int x = find(root, u), y = find(root, v+2); Splay(x, 0), Splay(y, root); return Sum[c[y][0]]; &#125; void inorder(int u)&#123; //中序遍历最后结果 if(!u) return; Push_down(u); inorder(c[u][0]); if(Val[u]!=INF) printf("%d ",Val[u]); inorder(c[u][1]); &#125;&#125; Spt;char s[10];int n,q,l,r,v;int main() &#123; while(~scanf("%d",&amp;n))&#123; Spt.init(); Spt.root = Spt.Newnode(INF); for(int i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;v); Spt.insert(v); &#125; Spt.insert(INF); scanf("%d", &amp;q); while(q--) &#123; scanf("%s", s); if(s[0] == 'A') &#123; scanf("%d%d%d", &amp;l, &amp;r, &amp;v); Spt.update(l, r, v); &#125; else if(s[0] == 'R' &amp;&amp; s[3] == 'E') &#123; scanf("%d%d", &amp;l, &amp;r); Spt.Reverse(l, r); &#125; else if(s[0] == 'R' &amp;&amp; s[3] == 'O') &#123; scanf("%d%d%d", &amp;l, &amp;r, &amp;v); Spt.Revolve(l, r, v); &#125; else if(s[0] == 'I') &#123; scanf("%d%d", &amp;l, &amp;r); Spt.Join(l, r); &#125; else if(s[0] == 'D') &#123; scanf("%d", &amp;l); Spt.del(l); &#125; else if(s[0] == 'M') &#123; scanf("%d%d", &amp;l, &amp;r); printf("%d\n", Spt.querymin(l, r)); &#125; &#125; //Spt.inorder(Spt.root); &#125;&#125; Treap(无旋)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e6+5;#define ls(x) arr[x].ch[0]#define rs(x) arr[x].ch[1]struct node&#123; int ch[2],siz,val,key;&#125;arr[maxn];int tot;void push_up(int o)&#123; arr[o].siz=arr[ls(o)].siz+arr[rs(o)].siz+1;&#125;void Split(int root,int &amp;x,int &amp;y,int value)&#123; if(!root)&#123; x=y=0; return; &#125; if(arr[root].val&lt;=value) x=root,Split(rs(root),rs(x),y,value); else y=root,Split(ls(root),x,ls(y),value); push_up(root);&#125;void Merge(int &amp;root,int x,int y)&#123; if(!x||!y)&#123; root=x+y; return; &#125; if(arr[x].key&lt;arr[y].key) root=x,Merge(rs(root),rs(x),y); else root=y,Merge(ls(root),x,ls(y)); push_up(root);&#125;void Insert(int &amp;root,int value)&#123; int x=0,y=0,z=++tot; arr[z].val=value,arr[z].siz=1,arr[z].key=rand(); Split(root,x,y,value); Merge(x,x,z); Merge(root,x,y);&#125;void Erase(int &amp;root,int value)&#123; int x=0,y=0,z=0; Split(root,x,y,value); Split(x,x,z,value-1); Merge(z,ls(z),rs(z)); Merge(x,x,z); Merge(root,x,y);&#125;int Kth(int root,int k)&#123; while(arr[ls(root)].siz+1!=k)&#123; if(arr[ls(root)].siz&gt;=k) root=ls(root); else k-=arr[ls(root)].siz+1,root=rs(root); &#125; return arr[root].val;&#125;int Rank(int &amp;root,int value)&#123; int x=0,y=0; Split(root,x,y,value-1); int res=arr[x].siz+1; Merge(root,x,y); return res;&#125;int Pre(int &amp;root,int value)&#123; int x=0,y=0; Split(root,x,y,value-1); int res=Kth(x,arr[x].siz); Merge(root,x,y); return res;&#125;int Suf(int &amp;root,int value)&#123; int x=0,y=0; Split(root,x,y,value); int res=Kth(y,1); Merge(root,x,y); return res;&#125;int n,op,x,root;int main()&#123; srand(19260817); scanf("%d",&amp;n); while(n--)&#123; scanf("%d%d",&amp;op,&amp;x); if(op==1) Insert(root,x); if(op==2) Erase(root,x); if(op==3) printf("%d\n",Rank(root,x)); if(op==4) printf("%d\n",Kth(root,x)); if(op==5) printf("%d\n",Pre(root,x)); if(op==6) printf("%d\n",Suf(root,x)); &#125;&#125;/*您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：1.查询k在区间内的排名2.查询区间内排名为k的值3.修改某一位值上的数值4.查询k在区间内的前驱(前驱定义为严格小于x，且最大的数，若不存在输出-2147483647)5.查询k在区间内的后继(后继定义为严格大于x，且最小的数，若不存在输出2147483647)*/#include&lt;bits/stdc++.h&gt;#define INF 0x7fffffffusing namespace std;typedef long long ll;const int maxn = 5e4+5;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1#define ls(x) arr[x].ch[0]#define rs(x) arr[x].ch[1]struct node&#123; int ch[2],siz,val,key;&#125;arr[maxn*25];int tot;void push_up(int o)&#123; arr[o].siz=arr[ls(o)].siz+arr[rs(o)].siz+1;&#125;void Split(int root,int &amp;x,int &amp;y,int value)&#123; if(!root)&#123; x=y=0; return; &#125; if(arr[root].val&lt;=value) x=root,Split(rs(root),rs(x),y,value); else y=root,Split(ls(root),x,ls(y),value); push_up(root);&#125;void Merge(int &amp;root,int x,int y)&#123; if(!x||!y)&#123; root=x+y; return; &#125; if(arr[x].key&lt;arr[y].key) root=x,Merge(rs(root),rs(x),y); else root=y,Merge(ls(root),x,ls(y)); push_up(root);&#125;void Insert(int &amp;root,int value)&#123; int x=0,y=0,z=++tot; arr[z].val=value,arr[z].siz=1,arr[z].key=rand(); Split(root,x,y,value); Merge(x,x,z); Merge(root,x,y);&#125;void Erase(int &amp;root,int value)&#123; int x=0,y=0,z=0; Split(root,x,y,value); Split(x,x,z,value-1); Merge(z,ls(z),rs(z)); Merge(x,x,z); Merge(root,x,y);&#125;int Kth(int root,int k)&#123; while(arr[ls(root)].siz+1!=k)&#123; if(arr[ls(root)].siz&gt;=k) root=ls(root); else k-=arr[ls(root)].siz+1,root=rs(root); &#125; return arr[root].val;&#125;int Rank(int &amp;root,int value)&#123; int x=0,y=0; Split(root,x,y,value-1); int res=arr[x].siz; Merge(root,x,y); return res;&#125;int Pre(int &amp;root,int value)&#123; int x=0,y=0; Split(root,x,y,value-1); int res= -INF; //可能无前驱 if(arr[x].siz) res=Kth(x,arr[x].siz); Merge(root,x,y); return res;&#125;int Suf(int &amp;root,int value)&#123; int x=0,y=0; Split(root,x,y,value); int res=INF; //可能无后继 if(arr[y].siz) res=Kth(y,1); Merge(root,x,y); return res;&#125;int T[maxn&lt;&lt;2],a[maxn&lt;&lt;2];void Add(int pos,int value,int l,int r,int o)&#123; Insert(T[o],value); if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) Add(pos,value,lson); else Add(pos,value,rson);&#125;void Delete(int pos,int value,int l,int r,int o)&#123; Erase(T[o],value); if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) Delete(pos,value,lson); else Delete(pos,value,rson);&#125;int Query_Rank(int L,int R,int value,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) return Rank(T[o],value); int mid=(l+r)&gt;&gt;1,res=0; if(L&lt;=mid) res+=Query_Rank(L,R,value,lson); if(R&gt;mid) res+=Query_Rank(L,R,value,rson); return res;&#125;int Query_Pre(int L,int R,int value,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) return Pre(T[o],value); int mid=(l+r)&gt;&gt;1,res=-INF; if(L&lt;=mid) res=max(res,Query_Pre(L,R,value,lson)); if(R&gt;mid) res=max(res,Query_Pre(L,R,value,rson)); return res;&#125;int Query_Suf(int L,int R,int value,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) return Suf(T[o],value); int mid=(l+r)&gt;&gt;1,res=INF; if(L&lt;=mid) res=min(res,Query_Suf(L,R,value,lson)); if(R&gt;mid) res=min(res,Query_Suf(L,R,value,rson)); return res;&#125;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n,m,op,l,r,pos,k,root;int main()&#123; srand(19260817); n=read(),m=read(); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); Add(i,a[i],1,n,1); &#125; while(m--)&#123; op=read(); if(op==1)&#123; l=read(),r=read(),k=read(); printf("%d\n",Query_Rank(l,r,k,1,n,1)+1); &#125; if(op==2)&#123; l=read(),r=read(),k=read(); int L=1,R=1e8; while(L&lt;R)&#123; int mid=(L+R+1)&gt;&gt;1; if(Query_Rank(l,r,mid,1,n,1)&lt;k) L=mid; else R=mid-1; &#125; printf("%d\n",L); &#125; if(op==3)&#123; pos=read(),k=read(); Delete(pos,a[pos],1,n,1); a[pos]=k; Add(pos,a[pos],1,n,1); &#125; if(op==4)&#123; l=read(),r=read(),k=read(); printf("%d\n",Query_Pre(l,r,k,1,n,1)); &#125; if(op==5)&#123; l=read(),r=read(),k=read(); printf("%d\n",Query_Suf(l,r,k,1,n,1)); &#125; &#125;&#125; 素数筛12345678910111213int p[maxn],cnt=0;bool isp[maxn];void getprime()&#123; memset(isp,true,sizeof(isp)); isp[0]=isp[1]=false; isp[2]=true; for(int i=2;i&lt;maxn;i++)&#123; if(isp[i]) p[cnt++]=i; for(int j=0;j&lt;cnt&amp;&amp;p[j]*i&lt;maxn;j++)&#123; isp[p[j]*i]=false; &#125; &#125;&#125; 质因数分解123456789101112131415//n的约数个数=(C_1+1)(C_2+1)*...*(C_cnt+1)int cnt=0;for(int i=2;i*i&lt;=n;i++)&#123; if(n%i==0)&#123; p[++cnt]=i,c[cnt]=0; while(n%i==0)&#123; n/=i; c[cnt]++; &#125; &#125;&#125;if(n&gt;1)&#123; p[++cnt]=n; c[cnt]=1;&#125; 因子个数1234567//dnum[i]表示i的因子数for(int i=1;i&lt;=n;i++)&#123; dnum[i]++; for(int j=i+i;j&lt;=n;j+=i)&#123; dnum[j]++; &#125;&#125; 快速幂/快速乘1234567891011121314151617181920//a^b%pll qpow(ll a,ll b,ll p)&#123; ll res=1; while(b)&#123; if(b&amp;1) res=(res*a)%p; a=(a*a)%p; b&gt;&gt;=1; &#125; return res;&#125;//a*b%pll qmul(ll a,ll b,ll p)&#123; ll res=0; while(b)&#123; if(b&amp;1) res=(res+a)%p; a=(a+a)%p; b&gt;&gt;=1; &#125; return res;&#125; Lucas求组合数取模1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//求解C(n,m)%P//P为素数且较小可以阶乘打表ll fac[maxn];ll C(ll n,ll m,ll p)&#123; if(m&gt;n) return 0; return fac[n]*qpow(fac[m]*fac[n-m],p-2,p)%p;&#125;ll Lucas(ll n,ll m,ll p)&#123; if(m==0) return 1; else return (C(n%p,m%p,p)*Lucas(n/p,m/p,p))%p;&#125;//P为素数且较大ll inv(ll x, ll p)&#123; return qpow(x,p-2,p);&#125;ll C(ll n,ll m,ll p)&#123; if(m&gt;n)return 0; ll up=1,down=1; for(int i=n-m+1;i&lt;=n;i++) up=up*i%p; for(int i=1;i&lt;=m;i++)down=down*i%p; return up*inv(down,p)%p;&#125;ll Lucas(ll n,ll m,ll p)&#123; if(m==0) return 1; return C(n%p,m%p,p)*Lucas(n/p,m/p,p)%p;&#125;//P不为素数ll extgcd(ll a,ll b,ll&amp; x,ll&amp; y)&#123; ll d = a; if(b)&#123; d=extgcd(b,a%b,y,x); y-=(a/b)*x; &#125; else x=1,y=0; return d;&#125;ll mod_inverse(ll a,ll m)&#123; ll x,y; ll d=extgcd(a,m,x,y); return d==1?(m+x%m)%m:-1;&#125;ll Mul(ll n,ll pi,ll pk)&#123; if(!n) return 1; ll ans=1; if(n/pk)&#123; for(ll i=2;i&lt;=pk;i++) if(i%pi)ans=ans*i%pk; ans=qpow(ans,n/pk,pk); &#125; for(ll i=2;i&lt;=n%pk;i++) if(i%pi) ans=ans*i%pk; return ans*Mul(n/pi,pi,pk)%pk;&#125;ll C(ll n,ll m,ll p,ll pi,ll pk)&#123; if(m&gt;n)return 0; ll a=Mul(n,pi,pk),b=Mul(m,pi,pk),c=Mul(n-m,pi,pk); ll k=0,ans; for(ll i=n;i;i/=pi) k+=i/pi; for(ll i=m;i;i/=pi) k-=i/pi; for(ll i=n-m;i;i/=pi) k-=i/pi; ans=a*mod_inverse(b,pk)%pk*mod_inverse(c,pk)%pk*qpow(pi,k,pk)%pk; ans=ans*(p/pk)%p*mod_inverse(p/pk,pk)%p; return ans;&#125;ll Lucas(ll n,ll m,ll p)&#123; ll x=p; ll ans=0; for(ll i=2;i&lt;=p;i++)&#123; if(x%i==0)&#123; ll pk=1; while(x%i==0) pk*=i,x/=i; ans=(ans+C(n,m,p,i,pk))%p; &#125; &#125; return ans;&#125; Miller_Pabin 素数判定1234567891011121314151617181920212223242526bool check(ll a,ll m,ll p,ll n) &#123; //对于每次随机的a进行测试 ll temp=qpow(a,m,n),ret=temp; for(int i=0;i&lt;p;++i) &#123; ret=qmul(temp,temp,n); if(ret==1&amp;&amp;temp!=n-1&amp;&amp;temp!=1) return true; temp=ret; &#125; return ret!=1;&#125;const int times = 50;bool Miller_Pabin(ll n) &#123; if(n&lt;2) return false; if(n==2) return true; if(n&amp;1==0) return false; ll p=0,x=n-1;//p为Miller测试的q，x为Miller测试的m while(x&amp;1==0)&#123; x&gt;&gt;=1; p++; &#125; srand(time(NULL)); for(int i=0;i&lt;times;++i)&#123; ll o=rand()%(n-1)+1;//Miller测试的底数a if(check(o,x,p,n)) return false; &#125; return true;&#125; 杜教递推12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1000000007;ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;// headint _,n;namespace linear_seq &#123; const int N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;int&gt; Md; void mul(ll *a,ll *b,int k) &#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int solve(ll n,VI a,VI b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+...// printf("%d\n",SZ(b)); ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt;p&gt;=0;p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; &#125; VI BM(VI s) &#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int gao(VI a,ll n) &#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); &#125;&#125;;int main() &#123; for (scanf("%d",&amp;_);_;_--) &#123; scanf("%d",&amp;n); printf("%d\n",linear_seq::gao(VI&#123;2,24,96,416,1536,5504,18944,64000,212992,702464&#125;,n-1)); &#125;&#125; 莫队1234567891011121314151617181920struct Query&#123; int L,R,id,block; Query()&#123;&#125; Query(int l, int r, int id):L(l), R(r), id(id)&#123; block = sqrt(n); &#125; bool operator &lt; (const Query &amp;hs) const &#123; if(block == hs.block) return R &lt; hs.R; return block &lt; hs.block; &#125;&#125;q[maxm];int L=1,R=1;for(int i=1;i&lt;=m;i++)&#123; while(R &lt; q[i].R) Insert(A[++R]); while(L &gt; q[i].L) Insert(A[--L]); while(R &gt; q[i].R) Erase(A[R--]); while(L &lt; q[i].L) Erase(A[L++]); ans[q[i].id]= ?;&#125; 二分123456789101112131415//找a[]中&gt;=x最小的那个while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(a[mid]&gt;=x) r=mid; else l=mid+1;&#125;return a[l];//找a[]中&lt;=x最大的那个while(l&lt;r)&#123; int mid=(l+r+1)&gt;&gt;1; if(a[mid]&lt;=x) l=mid; else r=mid-1;&#125;return a[l]; 线性基123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114const int MN=62;ll p[65],tmp[65];bool flag;void ins(ll x)&#123; for(int i=MN;~i;i--) if(x&amp;(1LL&lt;&lt;i)) if(!p[i])&#123;p[i]=x;return;&#125; else x^=p[i]; flag=true;&#125;//判断是否可以异或出结果xbool check(ll x)&#123; for(int i=MN;~i;i--) if(x&amp;(1LL&lt;&lt;i)) if(!p[i])return false; else x^=p[i]; return true;&#125;//查询异或最大ll qmax(ll res=0)&#123; for(int i=MN;~i;i--) res=max(res,res^p[i]); return res;&#125;//查询异或最小ll qmin()&#123; if(flag)return 0; for(int i=0;i&lt;=MN;i++) if(p[i])return p[i];&#125;//查询异或第k大ll query(ll k)&#123; ll res=0;int cnt=0; k-=flag;if(!k)return 0; for(int i=0;i&lt;=MN;i++)&#123; for(int j=i-1;~j;j--) if(p[i]&amp;(1ll&lt;&lt;j))p[i]^=p[j]; if(p[i])tmp[cnt++]=p[i]; &#125; if(k&gt;=(1ll&lt;&lt;cnt))return -1; for(int i=0;i&lt;cnt;i++) if(k&amp;(1ll&lt;&lt;i))res^=tmp[i]; return res;&#125;//区间异或值最大#pragma GCC optimize(2)#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+5;int b[N][32],p[N][32];//p[r][i] 表示满足下列条件的最大的 l,线性基第 i 位有值且 l≤r//b[r][i] 表示此时第 i 位的线性基void add(int x, int k, int r) &#123; for(int i=0;i&lt;=30;i++)&#123; b[r][i]=b[r-1][i]; p[r][i]=p[r-1][i]; &#125; for (int i = 30; i &gt;= 0; i--) if ((x &gt;&gt; i) &amp; 1) &#123; if (!b[r][i]) &#123; b[r][i] = x; p[r][i] = k; return; &#125; if (p[r][i] &lt; k) &#123; swap(p[r][i], k); swap(x, b[r][i]); &#125; x ^= b[r][i]; &#125;&#125;int ask(int l, int r) &#123; int ans = 0; for (int i = 30; i &gt;= 0; i--) if (p[r][i] &gt;= l) ans = max(ans, ans ^ b[r][i]); return ans;&#125;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; memset(b,0,sizeof(b)); memset(p,0,sizeof(p)); int n,m; scanf("%d%d",&amp;n,&amp;m); for(int r=1;r&lt;=n;r++)&#123; int x;scanf("%d",&amp;x); add(x,r,r); &#125; int lastans=0; while(m--)&#123; int op,x,l,r; scanf("%d",&amp;op); if(op==1)&#123; scanf("%d",&amp;x); x^=lastans; ++n; add(x,n,n); &#125; else&#123; scanf("%d%d",&amp;l,&amp;r); l=(l^lastans)%n+1; r=(r^lastans)%n+1; if(l&gt;r) swap(l,r); int res=ask(l,r); printf("%d\n",res); lastans=res; &#125; &#125; &#125;&#125; 拓扑排序12345678910111213141516171819//求有向图顺序或判有环bool topu()&#123; queue&lt;int&gt;q; //要求字典序改优先队列 for(int i=1;i&lt;=n;i++)&#123; if(in[i]==0) q.push(i); &#125; int cnt=0; while(!q.empty())&#123; int x=q.front(); q.pop(); cnt++; for(int i=0;i&lt;V[x].size();i++)&#123; int next=V[x][i]; if(--in[next]==0) q.push(next); Rank[next]=Rank[x]+1; &#125; &#125; return cnt==n;&#125; Dijkstra1234567891011121314151617181920212223242526272829303132333435363738394041//求由form到图中其他点的最短路径struct node&#123; int val,id; node(int id,int val):id(id),val(val) &#123;&#125; bool operator &lt;(const node &amp;hs)const&#123; return val&gt;hs.val; &#125;&#125;;struct edge&#123; int next,to,w;&#125;e[maxm*2];int head[maxn],cnt;void addedge(int u,int v,int w)&#123; e[++cnt]=edge&#123;head[u],v,w&#125;; head[u]=cnt;&#125;int dis[maxn],vis[maxn];void dijkstra(int from)&#123; for(int i=1;i&lt;=n;i++)&#123; dis[i]=INF; vis[i]=0; &#125; priority_queue&lt;node&gt;q; q.push(node(from,0)); dis[from]=0; while(!q.empty())&#123; int cur=q.top().id; q.pop(); if(vis[cur])continue; vis[cur]=true; for(int i=head[cur]; i ; i=e[i].next)&#123; int v=e[i].to; if(dis[cur]+e[i].w &lt; dis[v])&#123; dis[v]=dis[cur]+e[i].w; q.push(node(v,dis[v])); &#125; &#125; &#125;&#125; Floyd12345678//dis[i][i]=0,dis[i][j]表示i到j的最短路径for(int k=1;k&lt;=n;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); &#125; &#125;&#125; Java大数开方1234567891011121314151617181920//判断是否为完全平方数public static boolean check(BigInteger now) &#123; if (now.compareTo(BigInteger.ZERO) == 0 || now.compareTo(BigInteger.ONE) == 0) return true; if (now.mod(BigInteger.valueOf(3)).compareTo(BigInteger.valueOf(2)) == 0) return false; String s = now.toString(); if (s.length() % 2 == 0) s = s.substring(0, s.length() / 2 + 1); else s = s.substring(0, (1 + s.length()) / 2); BigInteger res = BigInteger.ZERO; BigInteger m = new BigInteger(s); BigInteger two = new BigInteger("2"); if (s == "1") res = BigInteger.ONE; else &#123; while (now.compareTo(m.multiply(m)) &lt; 0) &#123; m = (m.add(now.divide(m))).divide(two); &#125; res = m; &#125; if (res.multiply(res).compareTo(now) == 0) return true; return false;&#125; C++大数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#define MM 10000#define DLEN 4struct bigint&#123; int a[10000],len; // bool flag; bigint()&#123; memset(a,0,sizeof(a)); len=1; flag=true; &#125; bigint(int v)&#123; memset(a,0,sizeof(a)); len=0; flag=true; if(v&lt;0)&#123; flag=false; v=-v; &#125; do&#123; a[len++]=v%MM; v/=MM; &#125;while(v); &#125; bigint(char* s)&#123; memset(a,0,sizeof(a)); int L=strlen(s); flag=true; if(s[0]=='-')&#123; flag=false; s++; L--; &#125; len=L/DLEN; if(L%DLEN)len++; int index=0; for(int i=L-1;i&gt;=0;i-=DLEN) &#123; int t=0; int k=i-DLEN+1; if(k&lt;0)k=0; for(int j=k;j&lt;=i;j++) t=t*10+s[j]-'0'; a[index++]=t; &#125; &#125; void output()&#123; if(!flag)printf("-"); printf("%d",a[len-1]); for(int i=len-2;i&gt;=0;i--)printf("%04d",a[i]); printf("\n"); &#125; friend inline bool bigintcmp(const bigint&amp; u,const bigint&amp; v); friend inline void bigintadd(const bigint&amp; u,const bigint&amp; v,bigint&amp; res); friend inline void bigintdec(const bigint&amp; u,const bigint&amp; v,bigint&amp; res); friend bool operator &lt; (const bigint&amp; u,const bigint&amp; v); friend bigint operator + (const bigint&amp; u,const bigint&amp; v); friend bigint operator - (const bigint&amp; u,const bigint&amp; v); friend bigint operator * (const bigint&amp; u,const bigint&amp; v); friend bigint operator / (const bigint&amp; u,const int&amp; v); friend int operator % (const bigint&amp; u,const int&amp; v);&#125;;inline bool bigintcmp(const bigint&amp; u,const bigint&amp; v)&#123; if(u.len&lt;v.len)return true; if(u.len&gt;v.len)return false; for(int i=u.len-1;i&gt;=0;i--)&#123; if(u.a[i]!=v.a[i])return u.a[i]&lt;v.a[i]; &#125; return false;&#125;bool operator &lt; (const bigint&amp; u,const bigint&amp; v)&#123; if(u.flag!=v.flag)return u.flag&lt;v.flag; if(u.flag)return bigintcmp(u,v); else return bigintcmp(v,u);&#125;inline void bigintadd(const bigint&amp; u,const bigint&amp; v,bigint&amp; res)&#123; res.len=max(u.len,v.len); for(int i=0;i&lt;res.len;i++)&#123; res.a[i]+=u.a[i]+v.a[i]; if(res.a[i]&gt;=MM)&#123; res.a[i+1]++; res.a[i]-=MM; &#125; &#125; if(res.a[res.len]&gt;0)res.len++;&#125;inline void bigintdec(const bigint&amp; u,const bigint&amp; v,bigint&amp; res)&#123; res.len=u.len; for(int i=0;i&lt;res.len;i++)&#123; res.a[i]+=u.a[i]-v.a[i]; if(res.a[i]&lt;0)&#123; res.a[i+1]--; res.a[i]+=MM; &#125; &#125; while(res.len&gt;1&amp;&amp;res.a[res.len-1]==0)res.len--;&#125;bigint operator + (const bigint &amp;u,const bigint&amp; v)&#123; bigint res; memset(res.a,0,sizeof(res.a)); if(u.flag==v.flag)&#123; res.flag=u.flag; bigintadd(u,v,res); &#125;else&#123; if(u.flag)&#123; if(bigintcmp(u,v))&#123; bigintdec(v,u,res); res.flag=false; &#125;else&#123; bigintdec(u,v,res); res.flag=true; &#125; &#125;else&#123; if(bigintcmp(v,u))&#123; bigintdec(u,v,res); res.flag=false; &#125;else&#123; bigintdec(v,u,res); res.flag=true; &#125; &#125; &#125; return res;&#125;bigint operator - (const bigint&amp; u,const bigint&amp; v)&#123; bigint res; memset(res.a,0,sizeof(res.a)); if(u.flag!=v.flag)&#123; res.flag=u.flag; bigintadd(u,v,res); &#125;else&#123; if(u.flag)&#123; if(bigintcmp(u,v))&#123; bigintdec(v,u,res); res.flag=false; &#125;else&#123; bigintdec(u,v,res); res.flag=true; &#125; &#125;else&#123; if(bigintcmp(v,u))&#123; bigintdec(u,v,res); res.flag=false; &#125;else&#123; bigintdec(v,u,res); res.flag=true; &#125; &#125; &#125; return res;&#125;bigint operator * (const bigint&amp; u,const bigint&amp; v)&#123; bigint res; memset(res.a,0,sizeof(res.a)); res.flag=!u.flag^v.flag; for(int i=0;i&lt;u.len;i++)&#123; int up=0; for(int j=0;j&lt;v.len;j++)&#123; int temp=u.a[i]*v.a[j]+res.a[i+j]+up; res.a[i+j]=temp%MM; up=temp/MM; &#125; res.a[i+v.len]+=up; &#125; res.len=u.len+v.len; while(res.a[res.len-1]&gt;=MM)&#123; res.a[res.len]+=res.a[res.len-1]/MM; res.a[res.len-1]%=MM; res.len++; &#125; while(res.len&gt;1&amp;&amp;res.a[res.len-1]==0)res.len--; if(res.len==1&amp;&amp;res.a[0]==0)res.flag=true; return res;&#125;bigint operator / (const bigint&amp; u,const int&amp; v)&#123; bigint ret; memset(ret.a,0,sizeof(ret.a)); int down=0; for(int i=u.len-1;i&gt;=0;i--)&#123; ret.a[i]=(u.a[i]+down*MM)/v; down=u.a[i]+down*MM-ret.a[i]*v; &#125; ret.len=u.len; while(ret.len&gt;1&amp;&amp;ret.a[ret.len-1]==0)ret.len--; return ret;&#125;int operator % (const bigint&amp; u,const int&amp; v)&#123; int d=0; for(int i=u.len-1;i&gt;=0;i--)d=(d*MM%v+u.a[i])%v; return d;&#125; 其他 输出保留c位小数点 1printf("%.*f\n", c, (double)a/b); 平方和公式$1^2+2^2+3^2+…+n^2 = n(n+1)(2n+1)/6$ $2^2+4^2+6^2+…+(2n)^2=2n(n+1)(2n+1)/3$ 立方和公式$1^3+2^3+3^3+…+n^3=（n(n+1)/2)^2$ 等差数列求和公式$S_n=n(a_1+a_n)/2$ 等比数列求和公式:$S_n=a_1(1-q^n)/(1-q)$ 组合数性质 $C_n^0+C_n^1+…+C_n^n=2^n$ 错排公式：$D(1)=0,D(2)=1;D(n)=(n-1)[D(n-2)+D(n-1)]$ 斐波那契数列通项公式 \frac{1}{\sqrt{5}}[(\frac{1+\sqrt{5}}{2})^n-(\frac{1-\sqrt{5}}{2})^n](n>=1) 等价类划分 $S_0=1,S_n=C(n-1,0)*S_{n-1}+C(n-1,1)*S_{n-2}+…+C(n-1,n-1)*S_0$ 阶乘逼近函数 n!=\sqrt{2\pi n}(\frac{n}{e})^ne^{\frac{1}{12n}-\frac{\ln(9n)}{(9n)^{\pi}-(9n)^{-\pi}}} 三角形面积 $S = \frac{1}{2}absin(\theta )$ $p = \frac{1}{2}(a+b+c),S=\sqrt{p(p-a)(p-b)(p-c)}$]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARM嵌入式系统 学习笔记]]></title>
    <url>%2FARM%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[[TOC] 第1章 嵌入式系统概述 嵌入式系统定义：嵌入到对象体系中的专用计算机应用系统。 应用举例：手机、MP3、打印机、DV等。 嵌入式系统 分类 ①嵌入式微处理器（EMPU，基础是CPU，应用于专门设计的电路板上，满足嵌入式应用的特殊要求，在其工作温度、抗电磁干扰、可靠性等方面做了增强） ②微控制器（MCU，整个计算机系统集成到一块芯片中，适用于控制） ③DSP处理器（DSP，应用目标是大批量的消费类产品） ④片上系统（SOC，分通用和专用，专用芯片可用于互联网安全方面） 特点：嵌入性、专用性、计算机 嵌入式处理器：为了完成特殊的应用而设计的特殊目的处理器。 嵌入式最小系统：提供嵌入式处理器运行所必须的条件的电路与嵌入式处理器共同组成的系统。 嵌入式系统基本概念： 实时操作系统（RTOS）：一段在嵌入式系统启动后首先执行的背景程序，用户的应用程序是运行于RTOS之上的各个任务，RTOS根据各个任务的要求，进行资源管理、消息管理、任务调度及异常处理等工作。 资源：程序运行时可使用的软、硬件环境。 共享资源：被一个以上任务使用的资源。 任务：一个线程。 任务切换：保存当前运行任务的工作状态并入栈，把下一个要运行任务的当前状态从栈中装回CPU寄存器并开始运行。 内核：负责管理各个任务，提供任务切换的基本服务。 非占先式内核：中断后回到中断了的任务。 占先式内核：中断后让进入就绪态优先级最高的开始运行。 任务优先级：表示任务被调度的优先程度。 中断：一种硬件机制，用于通知CPU有个异步事件发生了。 常见嵌入式实时操作系统 μClinux：开源 Windows CE：开放 VxWorks：实时性卓越 μC/OS - ΙΙ：开源、抢占式 第2章 ARM7体系结构 ARM简介 ARM公司是一家知识产权(IP)供应商，它与一般的半导体公司最大的不同就是不制造芯片且不向终端用户出售芯片，而是通过转让设计方案，由合作伙伴生产出各具特色的芯片。 ARM架构是ARM公司面向市场设计的第一款低成本RISC微处理器。 ARM7后缀含义： 带M：64位乘法指令 带D：支持片上调试 带T：高密度16位Thumb指令集扩展 带I：Embedded ICE硬件仿真功能模块 ARM处理器使用冯·诺依曼结构，指令数据共用一条32位总线；直接支持8位字节(2^32)，16位半字(2^31)或者32位字(2^30)的数据类型。 如果一个数据是以字方式存储的，那么它就是字对齐的，否则就是非字对齐的；特征：bit0=bit1=0,其他任意。 如果一个数据是以半字方式存储的，那么它就是半字对齐的，否则就是非半字对齐的；特征：bit0=0,其他任意。 流水线 三级：①取指：从存储器装载一条指令 ②译码：识别将要执行的指令 ③执行：处理指令并将结果写回寄存器 ARM处理器状态 ARM指令集为32位长度，效率高，代码密度低，都是有条件执行，具有最完整的功能；Thumb指令集为16位长度，代码密度较高，只有一条具备有条件执行，能实现ARM指令集的大部分功能。在功能上可以认为Thumb是ARM的子集。 当前程序状态寄存器CPSR中的控制位T反映处理器正在操作的状态，T=0，处理器处于ARM状态，T=1，处理器处于Thumb状态。 从一个ARM例程调用另一个Thumb例程时，内核必须切换状态，反之亦然。BX分支将ARM内核的操作状态在ARM和Thumb之间进行切换。 &nbsp;&nbsp;&nbsp;&nbsp;7. ARM处理器模式 除了用户模式以外，其余所有6种模式称之为非用户模式 特权模式中除去系统模式外的5种模式称之为异常模式 用户(usr)、系统(sys)、管理(svc)、中止(abt)、未定义(und)、中断(irq)、快速中断(fiq) &nbsp;&nbsp;&nbsp;&nbsp;8. ARM内部寄存器 ARM处理器内部共有37个用户可访问的32位寄存器，其中有6个32位状态寄存器目前只使用了其中12位；31个通用寄存器+6个状态寄存器(1个CPSR+5个SPSR)；不可同时访问，对其访问取决于处理器状态和处理器模式。 堆栈指针R13(SP)，保存堆栈的出入口地址、待使用寄存器内容 链接寄存器R14(LR)，保存子程序和子程序的返回地址 程序计数器R15(PC)，总是指向“正在取指”的指令 所有模式共享一个程序状态寄存器CPSR，ARM通过此寄存器监视和控制内部操作的。SPSR为异常模式中保存CPSR当前值的备份程序寄存器。 程序状态寄存器格式 N Z C V … I F T M4 M3 M2 M1 M0 负 0 进位 溢出 保留 irq禁止 fiq禁止 状态位 模式位 . . . . &nbsp;&nbsp;&nbsp;&nbsp;9. 模式控制位 M[4:0] 模式 10000 用户 10001 快速中断 10010 中断 10011 管理 10111 中止 11011 未定义 11111 系统 &nbsp;&nbsp;&nbsp;&nbsp;10. 异常向量表 地址 异常 模式 0x0000 0000 复位 管理 0x0000 0004 未定义指令 未定义 0x0000 0008 软件中断 管理 0x0000 000C 中止（预取） 中止 0x0000 0010 中止（数据） 中止 0x0000 0014 保留 保留 0x0000 0018 IRQ 中断 0x0000 001C FIQ 快速中断 &nbsp;&nbsp;&nbsp;&nbsp;11. 中断优先级 优先级 异常 1 复位 2 数据中止 3 FIQ 4 IRQ 5 预取指中止 6 未定义指令 6 软件中断SWI &nbsp;&nbsp;&nbsp;&nbsp;12. ARM体系的储存系统 &nbsp;&nbsp;&nbsp;&nbsp;位于地址A的字包含的字节位于A、A+1、A+2、A+3； 小端格式：一个字中的最低地址被看作是最低位字节，最高地址的字节被看作是最高位字节，储存器系统字节0连接到数据线7~0； 大端格式：一个字中的最高位字节保存在最低地址，最低位字节保存在最高位地址，储存器系统字节0连接到数据线31~24； 第3章 ARM7TDMI（-S）指令系统 ARM处理器寻址方式 寄存器寻址： 寄存器编号 MOV R1,R2 ；将R2的值存入R1 SUB R0,R1,R2；将R1的值减R2的值结果存入R0 立即寻址： 操作数 SUBS R0,R0,#1；R0-1存入R0 MOV R0,#0xFF000；将立即数0xFF000装入R0 寄存器移位寻址： ASR(1-32)、LSL(1-31)、LSR(1-32)、ROR(1-31)、RRX(1) MOV R0,R2,LSL #3 ；R2的值左移3位结果存入R0 ANDS R1,R1,R2,LSL R3 ；R2的值左移R3位，结果与R1相与后存入R1 寄存器间接寻址： [] LDR R1,[R2] ；将R2指向的储存单元的数据读出存入R1 //加载字数据 SWP R1,R1,[R2]；将R2指向的储存单元的数据与R1的值交换 基址寻址 STR R1,[R0,#-4]！；将R1的值存入R0-4指定的储存单元 //存储字数据 多寄存器寻址：！，{ } LDMIA R1!,{R2-R7,R12}；将R1指向的单元中的数据读出到R2-R7,R12中，R1++；//多寄存器加载 STMIA R0!,{R2-R7,R12}；将R2-R7,R12的值保存到R0指向的存储单元中，R0++; //多寄存器存储 堆栈寻址 满堆栈：指向最后压入栈的有效数据项，向移动指针再写数据； 空堆栈：指向下一个待压入数据的空位置，先写入数据在移动指针； X递增：增大地址向上增长；X递减：减小地址向下增长。 相对寻址 程序计数器PC提供基准地址，地址码字段作为偏移量 第4章 LPC2000系列ARM硬件结构 为存储器分配地址的过程称为存储器映射；但为了增加系统的灵活性，系统中有部分存储单元（主要包括引导块(Boot Block)和用于保存向量表的少量存储单元）可以同时出现在不同地址上，则称为存储器重映射。 存储器重映射并不是对映射单元的内容进行了复制，只是将多个地址指向了同一个存储单元，通过“存储器管理部件”实现。即一个物理地址对应多个逻辑地址。 Boot Block是芯片设计厂家在LPC2000系列ARM内部固化的一段代码，用户无法对其修改或删除。这段代码在芯片复位后被首先运行，其功能主要是判断运行哪个存储器上的程序，检查用户代码是否有效，判断芯片是否被加密，芯片的在应用编程(IAP)以及在系统编程功能(ISP)。 系统启动代码(Boot Loader)：大部分由汇编指令构成，可以实现向量表定义、堆栈初始化、系统变量初始化、中断系统初始化、I/O初始化、外围初始化、地址重映射等操作。启动顺序：Boot Block-&gt;Boot Loader-&gt;操作系统 时钟系统概述：时钟是计算机系统的脉搏，处理器核在一拍接一拍的时钟驱动下完成指令执行、状态变换等动作。外设部件在时钟的驱动下进行着各种工作，比如串口数据的收发、A/D转换、定时器计数等。因此时钟对于一个计算机系统是至关重要的，通常时钟系统出现问题也是最致命的，比如振荡器不起振、振荡不稳、停振等。组成：晶体振荡器、唤醒定时器、锁相环（PLL）和VPB分频器。 晶体振荡器的两个模式：使用外部时钟源时，称为“从属模式”；使用外部晶体时，称为“振荡模式”。 LPC2000系列ARM两个复位源： 外部复位：通过把芯片的$\overline{RESET}$引脚拉为低电平使芯片复位。$\overline{RESET}$引脚为施密特触发输入引脚，带有一个额外的干扰滤波器，可以滤除非常短促的脉冲信号，使处理器不会被干扰脉冲意外复位，或者被不稳定的复位信号复位多次。 $\overline{RESET}$需要保持一段时间的低电平，必须在晶振稳定运行之后才能撤除。 在系统编程(ISP)：是一种非常实用的片内Flash烧写方式。ISP工作时，通过UART0使用约定协议与计算机上的ISP软件进行通信，并按用户的操作要求，调用内部的IAP代码实现各种功能。 看门狗复位：内置看门狗部件，可以利用此部件来复位处理器。 锁相环PLL 作用：将振荡器产生的时钟频率$F_{OSC}$进行升频。 LPC2000系列ARM是基于ARM7内核的，该内核的工作频率基本在100Mhz以下，所以LPC2000系列ARM大部分支持最高60MHz的内核时钟，少部分支持70MHz的内核时钟。 PLL频率计算：$F_{OSC}$经流控振荡器CCO得到$F_{CCO}$，$F_{CCO}$经过2P分频后得$F_{CCLK}=F_{CCO}/(2*P)$，$F_{CCO}/(2*P)$经M分频后得到$F_{CCO}/(2*P*M) = F_{OSC}$ PLL设置 参考链接 $F_{CCO}$取值必须在156～320MHz内 M取值1-32，将M-1放在PLLCFG[4:0] P取值1,2,4,8，将$log_2P$放在PLLCFG[6:5] PLLCON寄存器:包涵使能连接PLL的位,也就是控制PLL是否进行连接,这个连接需要在向PLLFEED发送正确的信息(馈送序列)的时候才生效,否则及时将使能位置位,PLL也不会连接到电路中。PLLCON必须在PLL开始连接之前就设置好,否则会造成系统不可预知的错误,先设置1后设置3。 PLLSTAT寄存器:从里面可以读出PLLCON,PLLCFG的值,但必须是在PLLFEED的馈送序列被发送,PLLCON,PLLCFG生效以后才可以读到正确的值(while(PLLSTAT &amp; (1&lt;&lt;10) == 0) ;) PLLFEED寄存器:向此寄存器以连续的VPB总线周期写入0xaa,0x55,即馈送序列，在正确的序列被写入PLLFEED之后,PLLCON,PLLCFG才生效,PLL电路才能正确的连接到电路中 12345678PLLCON = 1;PLLCFG = (M-1)|（log2(P)&lt;&lt;5）;PLLFEED = 0xaa;PLLFEED = 0x55;while(PLLSTAT &amp; (1&lt;&lt;10) == 0);PLLCON = 3;PLLFEED = 0xaa;PLLFEED = 0x55; &nbsp;&nbsp;9. VPB分频器 作用：将$F_{CCLK}$分频，方便外设工作、降低系统功耗 &nbsp;&nbsp;10. 两种节电模式： 空闲模式：处理器停止执行指令，使功耗最低降至1～2mA电流 掉电模式：振荡器关闭，芯片没有任何内部时钟，功耗降低到几乎为零 &nbsp;&nbsp;11. bank0~bank3的片选信号分别是CS0~CS3。 &nbsp;&nbsp;12. 外部存储器接口 LPC2200的外部存储器宽度可设定为8位，16位和32位 宽度为8位时，有效数据线D7~D0，只有BLS0有效 宽度为16位时，有效数据线D15~D0，BLS0、BLS1都有效 操作16位存储器时，需将LPC2200的地址线A1连接到存储器地址A0处 &nbsp;&nbsp;13. PSRAM读写数据 写入16位 123456789int main(void)&#123; uint16 *point16; uint16 data16 = 0x00; point16 = (uint16 *)0x80001020; while(1)&#123; *point16 = data16++; //循环向地址0x80001020处写入数据 &#125; return 0;&#125; 写入低8位 123456789int main(void)&#123; uint8 *point8; uint8 data8 = 0x00; point8 = (uint8 *)0x80001010; while(1)&#123; *point8 = data8++;//循环向地址0x80001010处写入数据 &#125; return 0;&#125; 写入高8位 123456789int main(void)&#123; uint8 *point8; uint8 data8 = 0x00; point8 = (uint8 *)0x80001011; while(1)&#123; *point8 = data8++;//循环向地址0x80001011处写入数据 &#125; return 0;&#125; 读取8位 1234567891011121314uint8 RcvDate8;int main(void)&#123; uint8 *point8; point8 = (uint*)0x80001010; while(1)&#123; RcvDate8 = *point8++;//读取0x80001010处的数据 RcvDate8 = *point8++;//读取0x80001011处的数据 RcvDate8 = *point8++;//读取0x80001012处的数据 RcvDate8 = *point8--;//读取0x80001013处的数据 point8--; point8--; &#125; return 0;&#125; &nbsp;&nbsp;14. ARM的大部分引脚都具有多种功能，即引脚复用。但是一个引脚在同一时刻只能使用其中一个功能，通过配置相关寄存器控制多路开关与片内外设。 &nbsp;&nbsp;15. GPIO的特性 可以独立控制每个GPIO口的方向（输入/输出模式） 可以独立设置每个GPIO口的输出状态（高/低电平） 所有GPIO口在复位后默认为输入状态 &nbsp;&nbsp;16. GPIO应用示例 ​ 设置P0.0为输出高电平 123PINSEL0 &amp;= 0xFFFFFFFC; //设置引脚连接模块，将P0.0设置为GPIO功能IO0DIR |= 0x00000001; //将P0.0设置为输出IOSET = 0x00000001; //设置P0.0输出高电平 使用GPIO控制蜂鸣器 123456789101112#define BEEPCON 0x00000080 //P0.7控制B1，低电平蜂鸣int main(void)&#123; PINSEL0 = 0x00000000; //设置引脚连接GPIO IO0DIR = BEEPCON; //设置I/O为输出 while(1)&#123; IO0SET = BEEPCON; //BEEPCON=1 Delay(10); IO0CLR = BEEPCON; //BEEPCON=0 Delay(10); &#125; reuturn 0;&#125; 读取P0.0引脚的电平状态 1234uint32 PinStat; //定义存放I/O状态的变量PINSEL0 &amp;= 0xFFFFFFFC; //设置引脚连接模块，将P0.0设置为GPIO功能IO0DIR &amp;= 0xFFFFFFFE; //将P0.0设置为输入PinStat = IO0PIN&amp;0x01; //通过IP0PIN寄存器获取P0.0当前电平状态 读取按键状态 12345678910111213#define BEEPCON 0x00000080#define PIN_P014 0x00004000 //定义P0.14屏蔽字int main(void)&#123; uint32 i; PINSEL0 = 0x00000000; //设置引脚连接GPIO IO0DIR = BEEPCON; //设置B1控制口为输出，其他I/O为输入 while(1)&#123; if((IO0DIR&amp;PIN_P014)!=0) IO0SET = BEEPCON; else IO0CLR = BEEPCON; Delay(10); &#125; return 0;&#125; 在多个I/O口线上输出数据 12345#define DataBus 0xFFPINSEL0 &amp;= 0xFFFF0000；//设置引脚连接模块，将P0.0~P0.7设置为GPIO功能IO0DIR |= DataBus; //将所有I/O口设置为输出IO0CLR = DataBus; //将所有I/O口设置为低电平输出IO0SET = Data; //将输出的数据从I/O口输出 &nbsp;&nbsp;17. 中断分类 快速中断请求（FIQ）：优先级最高 向量IRQ：中等优先级，16个优先级，每个中断源分别设置服务程序入口 非向量IRQ：优先级最低，支持一个非向量中断，所有中断共用一个服务程序入口 &nbsp;&nbsp;18. VIC可以管理32路中断请求。 &nbsp;&nbsp;19. 中断触发方式 边沿触发：上升沿触发、下降沿触发 电平触发：高电平触发、低电平触发 &nbsp;&nbsp;20. 外部中断应用示例 EINT0低电平中断初始化 12345678PINSEL1 = (PINSEL1&amp;0xFFFFFFFC)|0x01; //选择P0.16为EINT0EXTMODE = EXTMODE&amp;0x0E; //电平触发EXTPOLAR = EXTPOLAR&amp;0x0E; //低电平中断/*设置向量中断控制器*/VICIntSelect = VICIntSelect&amp;(~(1&lt;&lt;14)); //EINT0分配为IRQ中断VICVectCntl0 = 0x20|14; //EINT分配为向量IRQ通道0VICVectAddr0 = (uint32)EINT0_ISR; //向量IRQ通道0的中断服务程序地址为EINT0_ISRVICIntEnable = (1&lt;&lt;14); //EINT0中断使能 EINT0下降沿中断初始化 123PINSEL1 = (PINSEL1&amp;0xFFFFFFFC)|0x01;EXTMODE = EXTMODE|0x01;EXTPOLAR = EXTPOLAR&amp;0x0E; &nbsp;&nbsp;21. SPI总线系统是一种同步串行外设接口，允许MCU与各种外围设备一串行方式进行通信、数据交换。 &nbsp;&nbsp;22. $I^2C$BUS是NXP半导体公司推出的芯片间串行传输总线，它以2根连线实现了完善的双向数据传送，可以极方便的构成多机系统和外围器件拓展系统。 &nbsp;&nbsp;23. LPC2000系列ARM7微控制器包含有2个符合16C550工业标准的异步串行口（UART）：UART0和UART1。其中UART0只提供TXD（发送）和RXD（接受）信号引脚，而UART1增加了一个调制解调器（Modem）接口。 &nbsp;&nbsp;24. UART应用示例 UART0初始化 12345678910#define UART_BPS 115200void UART0_Ini(void)&#123; uint16 Fdiv; U0LCR = 0x83; //DLAB=1,可设置波特率 Fdiv = (Fpclk/16)/UART_BPS; //设置波特率 U0DLM = Fdiv/256; //除数锁存高位寄存器 U0DLL = Fdiv%256; //除数锁存低位寄存器 U0LCR = 0x03;&#125; UART0查询方式接受数据 123456uint8 UART0_RcvByte(void)&#123; uint8 rcv_data; while((U0LSR&amp;0x01)==0); //状态 rcv_data = U0RBR; //接受缓存 return rcv_data;&#125; UART0中断方式接受数据 12345678910111213141516171819void __irq UART_Exception(void)&#123; ... switch(U0IIR&amp;0x0f)&#123; case 0x04: //发生RDA中断 //从接受FIFO中读取数据 break; case 0x0c: //发生字符超时中断——CTI while((U0LSR&amp;0x01)==1)&#123; //如果接受FIFO中含有的有效数据，就读取UnRBR寄存器 RcvData[i++]=U0RBR; &#125; break; ... default: break; &#125; VICVectAddr = 0;&#125; &nbsp;&nbsp;25. 看门狗 带内部预分频器的可编程32位定时器]]></content>
      <categories>
        <category>嵌入式系统</category>
      </categories>
      <tags>
        <tag>嵌入式系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法设计与分析 学习笔记]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[第一章 算法概述算法的定义：是对特定问题求解步骤的一种描述，包含操作的有限规则和操作的有限序列 算法的性质：确定性（指令无歧义）、有限性（无死循环）、输入、输出 程序的定义：是算法用某种程序设计语言的具体实现 程序和算法的区别：程序不一定满足有限性，比如操作系统 算法复杂性决定于：(1)求解问题的规模；(2)具体的输入数据；(3)算法本身的设计 O(1)&lt;O(logn)&lt;O(n)&lt;O($n^c$)&lt;O($c^n$)&lt;O(n!) 如果存在正的常数c和自然数n0，使得n&gt;=n0时有f(n)&lt;=cg(n)，则称f(n)当n充分大时有上界，且g(n)是它的一个上界，记为f(n)=O(g(n))，还说f(n)的阶不高于f(n)的阶。 求上下界函数： \lim_{n\rightarrow\infty} \frac{f(n)}{g(n)} = \begin{cases}0, & \text{f(n)=O(g(n))}\\\infty, & \text{f(n)= $\Omega$(g(n))}\\c,& \text{f(n)=$\Theta$(g(n))} \end{cases}第二章 递归与分治一般递归方程时间复杂度分析 T(n)1} \end{cases}其中，a是子问题的个数，b是递减的步长，|表示递减方式，D(n)是合成子问题的开销 当|为减法： T(n)1}\\ O(n),&\text{a=1} \end{cases}当|为除法： $p=log_ba$ ①D(n)为常数 T(n)1}\\ O(log_bn),&\text{a=1} \end{cases}②D(n)为线性函数cn T(n)]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>算法设计与分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物联网概论 学习笔记]]></title>
    <url>%2F%E7%89%A9%E8%81%94%E7%BD%91%E6%A6%82%E8%AE%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[物联网（IoT）：Internet of Things 物联网是具有自我标示、感知和智能的物理实体基于通信技术相互连接形成的网络，这些物理设备可以在无需人工干预的条件下实现协同和互动，为人们提供智慧和集约的服务，传感网是物联网的基础，是物联网的组成部分 物联网三层体系结构：感知层、网络层和应用层 感知层是物联网的皮肤和五官——识别物体，采集信息； 网络层是物联网的神经中枢和大脑——信息传递和处理； 应用层是物联网的“社会分工”——与行业需求结合，实现广泛智能化 RFID全称：Radio Frequency Identification 射频识别 RFID系统的基本组成： ①硬件组成：RFID标签、识读器、天线和主机 ②软件组成：RFID系统软件、中间件和应用软件 RFID系统结构通过空中接口将电子标签与读写器连接 RFID系统的原理： ①耦合(Coupling)：根据需求和成本可利用电磁波和磁感应 ②磁耦合 ③电磁波耦合(反向散射原理) RFID频段分布 低频：125.124KHz 恶劣环境下使用 高频：13.56MHz 门禁卡、公交卡等 （ISO/IEC 14443标准 非接触集成电路接近卡） 超高频：433.92Mhz / 868-960Mhz 微波：2.45GHz 一般传感器的定义：测量装置、输入与输出有对应关系、有一定的精确度 一般传感器的组成： ①敏感元件：直接感受被测量、并输出与被测量成确定关系的某一物理量的元件 ②转换元件：敏感元件的输出就是它的输入，将感受到的非电量直接转换为电量的元件 ③测量电路：将转换元件输出的电量变换为便于显示、记录、控制、处理的有用电信号 传感器的静态特性： ①线性度：指其输出量与输入量之间的实际关系曲线(即静态特征曲线)偏离直线的程度，又称为非线性误差 ②灵敏度：指传感器在稳态下的输出变化量△y与引起变化的输入变化△x之比 ③迟滞：传感器在正(输入量增大)和反(输入量减小)行程期间，其输出-输入特性曲线不重合的现象 ④重复性：在输入按同一方向连续多次变动时得到特性曲线不一致的程度 ⑤分辨率：在测量方向内所能测量输入量的最小变化量△x ⑥漂移：在外界的干扰下，输出量发生与输入量无关的变化 应变效应：金属导体或者半导体在受外力作用时，会产生相应的应变，其阻值也随之发生变化 。 应变片式传感器——电桥 ①直流电桥（单臂电桥、惠斯通电桥）：$K_{u} = U/4$ ②半差动电桥(双臂电桥)：$K_{u} = U/2$ ③全桥电路（全臂电桥）：$K_{u} = U$ 变磁阻式(自感)传感器： 电感：在电路中电流发生变化时能产生电动势的性质成为电感，分为自感和互感 自感：当线圈中有电流通过时，线圈的周围就会产生磁场。当线圈中电流发生变化时，其周围的磁场也产生相应的变化，此变化的磁场可使线圈自身产生感应电动势。 互感：两个电感线圈相互靠近时，一个电感线圈的磁场变化将影响另一个电感线圈，这种影响就是互感。互感的大小取决于电感线圈的自感与两个电感线圈耦合的程度 。 应用范畴：微位移 分类： 变气隙式 &nbsp;&nbsp;工作原理：气隙厚度的改变，使得磁路中磁阻值变化，从而导致电路电感值变化 变截面式 螺管式 电容式传感器：$c_0 = \frac{\epsilon_0\epsilon_rS}{d_0}$ 分类：①变极距型②变面积型③变介质型（油箱测油位） 应用：手机指纹识别 ps:实验箱指纹识别模块使用的是光电式传感器 磁电式传感器-霍尔传感器 霍尔效应：置于磁场中的静止载流导体, 当它的电流方向与磁场方向不一致时, 载流导体上垂直于电流和磁场方向产生电动势。该电势称霍尔电势。 霍尔电势与控制电流和磁感应强度成正比 霍尔电势的灵敏度与霍尔常数RH正比而与霍尔片厚度成反比 应用：微位移、测转速(汽车轮胎)、测电流、计数、开关等 压电式传感器 压电效应：某些电介质,当沿着一定方向对其施力而使它变形时,其内部就产生极化现象,同时在它的两个表面上便产生符号相反的电荷,当外力去掉后,其又重新恢复到不带电状态。 Z为光轴，X为电轴，Y为机械轴 压电效应称为纵向压电效应，沿Y方向产生的为横向压电效应，沿Z轴不产生 侧压力时线性度不好，需要在力传递系统中加入预加力，称预载 光电式传感器 光电效应：光的频率越高，其光子能量就越大。当具有一定能量的光子作用到某些物体上转化为该物体中一些电子的能量而产生电效应。 分类： 外光电效应（光线照到某些物体上造成表面电子逸出的现象） 光电导效应、光生伏特效应(内光电效应) （物体受光照后，内部原子释放出电子不能逸出表面，使物体电阻率发生变化或产生光电动势的现象） 光电倍增管：对光电流放大以提高灵敏度,阳极最后收集到的电子数是阴极发射的$10^5～10^6$倍 应用：亮度传感器、烟雾报警器、光电鼠标等 无线传感器 定义：是大量的静止或移动的传感器以自组织和多跳的方式构成的无线网络，目的是协作地采集、处理、传输网络覆盖地域内感知对象的检测信息，并报告用户。 传感器节点 -&gt; 汇聚节点 -&gt; 管理节点 网络节点组成：传感模块—计算模块—通信模块——存储模块 无线传感网：WSN(Wireless sensor network) 电池供电，能量有限（耗能排序：发送&gt;接受&gt;空闲&gt;睡眠 短距离通讯（距离增加一倍，功耗增加三倍 节点生命周期 自适应网络 路由的性质： 路由策略分析：最大PA、最小能量消耗、最少跳转、最大最小PA节点 定向扩散路由：①兴趣扩散（洪泛方式）②梯度建立③加强路径 GPSR绕过路由空洞的步骤： 构造全网连接平面图 通过删边处理，变成可平面图（GG、RNG算法 通过右手法则，绕过路由空洞（每经过一个面，顺时针到的第一条边 MAC协议： 分类：时分复用无竞争接入方式(分配型）、随机竞争接入方式（竞争型）、竞争与固定分配相结合的接入方式（混合型） S-MAC协议： 优点： 周期性的侦听/睡眠的低占空比方式 虚拟簇的调度方式 自适应流量的侦听机制：通信结束继续侦听一段时间 串音避免：RTS/CTS/DATA/ACK 缺点：延迟受限于帧长度，不适合实时业务 分配性MAC协议： “隐藏终端”（Hidden Stations）：在通信领域，基站A向基站B发送信息，基站C未侦测到A也向B发送，故A和C同时将信号发送至B，引起信号冲突，最终导致发送至B的信号都丢失了。 暴露终端是指在发送节点的覆盖范围内而在接收节点的覆盖范围外的节点，暴露终端因听到发送节点的发送而可能延迟发送。但是，它其实是在接收节点的通信范围之外，它的发送不会造成冲突。这就引入了不必要的延时。 ZigBee 功能节点：协调者（COORDINATOR）、路由器（ROUTER）、终端设备（END DEVICE） 协调者（老大）功能：发送网络信标、建立一个PAN、管理网络节点、存储网络节点信息、寻找节点对路由信息 路由器功能：允许其它设备加入网络、跳跃路由、辅助子设备供电 终端设备功能：传感节点的载体、轻载化程序设计 网络拓扑结构：星型、网型、树形 模式：非信标模式（CSMA/CA）、信标模式（竞争和分配的混合性信道接入） CSMA/CA方式下通过三个参数的调节来实现冲突避免：退避次数（NB)、竞争窗口长度（CW)、退避指数（BE） 信标、超帧及其结构： 超帧包含活动部分和非活动部分，超帧以一个信标的开始为开始，信标定义超帧结构 CAP为自由竞争阶段、CFP为非竞争阶段、CFP内可以保证GTS（保证时隙）的传送 信标是子设备同步父设备的标记 耗能：传感模块的功耗远高于射频模块的功耗，这是因为传感模块大多采用模拟电路进行感测，需要一直恒定的加载电流。]]></content>
      <categories>
        <category>物联网概论</category>
      </categories>
      <tags>
        <tag>物联网概论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率论与数理统计 学习笔记]]></title>
    <url>%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[第一章 随机事件及其概率第一节 随机事件及其频率、概率的统计定义随机事件(偶然事件)：在试验的结果中，可能发生、也可能不发生的事件 随机事件的频率具有一定的稳定性 随机事件的概率为频率的近似值 $P(A) \approx f(A) = \frac{m}{n}$ 必然事件 P(U)=1；不可能事件 P(V)=0 第二节 样本空间样本点：随机试验的每一个可能出现的且是最简单的不可再分的结果 样本空间：所有的样本点构成的集合（分为可列个和不可列个(如误差范围)） 任一随机事件A都是样本空间Ω的一个子集 第三节 事件的关系及运算包含/包含于：$A \subset B$ 和(并)：$A∪B$ 积(交)：$A∩B 或 AB$ 互不相容(互斥)：两个互不相容事件的和 $A+B$ 对立(逆)：$\overline{A}=B$ 完备事件组：n个事件至少有一个事件一定发生 A发生但B不发生：$A-B=A\overline{B}=A-AB$ 运算性质：交换律、结合律、分配律、德摩根律（$\overline{A∪B}=\overline{A}&ensp;\overline{B},\overline{AB}=\overline{A}∪\overline{B}$） 第四节 概率的古典定义乘法定理：完成一件事需r步，第i步有$ m_ i $种方法，完成这件事总方法数 $ m_ 1m_ 2…m_ r $ 加法定理：完成一件事有r类方法，第i类有$ m_ i $种方法，完成这件事总方法数 $ m_ 1+m_ 2+…+m_ r $ 排列：$ A _ n ^m = \frac{n!}{(n-m)!} $ 组合：$ C _ n ^m = \frac{A _ n ^m}{P_ m} = \frac{n!}{(n-m)!m!}$ 概率的古典定义：试验样本总共有$ n_Ω$ 个等可能的基本事件，其中随机事件A包含$ n_A$个基本事件，($ n_A$&lt;=$ n_Ω$)，则 $P(A) = \frac{n_A}{n_Ω}$ 不放回依次抽样与一次抽样的一致性、抽签次序无关性 第五节 概率加法定理若随机事件A与B互斥，即$AB = \emptyset，则P(A+B)= P(A)+P(B) \Rightarrow P(A)+P(\overline{A})=1$ 若A、B是任意的两个随机事件，则二者和事件的概率为 $P(A∪B)=P(A)+P(B)-P(AB)$ $\Rightarrow P(A∪B∪C)=P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC) $ 第六节 条件概率与乘法定理已知事件A发生的条件下，事件B发生的概率：$P(B|A)=\frac{P(AB)}{P(A)}$ 若$P(A_1A_2…A_{n-1})&gt;0,则 P(A_1A_2…A_{n})=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1A_2…A_n-1)$ 第七节 全概率公式与贝叶斯公式&ensp;&ensp;先验，由因溯果 P(A) = \sum_{i=1}^nP(B_i)P(A|B_i) &ensp;&ensp;后验，由果溯因 P(B_i|A) = \frac{P(AB_i)}{P(A)} = \frac{P(B_i)P(A|B_i)}{\sum_{i=1}^nP(B_i)P(A|B_i)},i=1,2,...,n第八节 随机事件的独立性若两事件A与B满足$P(AB) = P(A)P(B)$，则称事件A与B相互独立 &ensp;&ensp;性质1：不可能事件及必然事件与任意的随机事件相互独立 &ensp;&ensp;性质2：A与B相互独立，则A与$\overline{B},\overline{A}与B,\overline{A}与\overline{B}$也相互独立&ensp;&ensp;（相互对称性） 第九节 贝努力概型事件A恰好发生k次的概率：$P_n(k) = C_n^kp^kq^{n-k},k=0,1,2,…,n$ $\sum_{k=0}^nP_n(k) = \sum_{k=0}^nC_n^kp^kq^{n-k} = (p+q)^n = 1$ 事件A发生次数介于$m_1$与$m_2$之间：$P_n(m_1 \leq k \leq m_2) = \sum_{k=m1}^{m2}P_n(k)$ 事件A至少发生r次：$P(k \geq r) = \sum_{k=r}^nP_n(k) = 1 - \sum_{k=0}^{r-1}P_n(k)$ 第十节 概率论的公理化体系非负性：P(A) $\leq$ 0; 规范性：P(Ω)=1; 可列可加性(可数可加性)：$A_1,A_2,…$ 两两互不相容，则$P(\sum_{i=1}^\infty A_i) = \sum_{i=1}^\infty P(A_i)$ 第二章 随机变量及其分布第一节 随机变量的概念设Ω为随机变量的样本空间，如果对每一个样本点$\omega \in Ω$，均有唯一确定的实数X($\omega$)与之对应，即存在一个定义于Ω的单值实函数X=X($\omega$)，则称X=X($\omega$)为样本空间Ω上的随机变量 第二节 离散型随机变量的概率分布性质： ①$p_k \geq 0 (k=1,2,..) $ ②$\sum_{k=1}^{\infty}p_k = 1$ 第三节 几种常用的离散型随机变量的分布 0-1分布：$P(X=1) = p，P(X=0) = q（0&lt;p&lt;1，p+q=1）$ 超几何分布：$P(X=m) = \frac{C_M^mC_{N-M}^{n-m}}{C_N^n} （n \leq N,M \leq N），记作X～H(n,M,N)$，N趋向无穷大时近似服从二项分布 二项分布：$P(X=k) = C_n^kp^kq^{n-k} （k=0,1,2,…,n） ，记作X ～B(n,p)$ ，n很大，p很小时，可用泊松分布近似替代二项分布 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;二项式分布的最可能取值( P(X=k)取得最大值的k )： &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;①若(n+1)p不是整数，则其整数部分[(n+1)p]即为所求； &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;②若(n+1)p=m是整数，则m和m-1即为所求 泊松分布：$P(X=k) = P_{\lambda}(k) = \frac{\lambda^k}{k!}e^{-\lambda} （k=0,1,2,…），记作X～P(\lambda)$ 几何分布：$P(X=k)=q^{k-1}p（k=1,2,…）， 记作X～G(p)$ 第四节 随机变量的分布函数$F(x) = P(X \leq x)$ 性质： $F(x) 单调不减，若x_1&lt;x_2,则F(x_1) \leq F(x_2)$ 对于任意x，P(x)=F(x)-F(x-0),即当前值-左极限值 $P(x_1&lt;X \leq x_2) = F(x_2)-F(x_1)$离散型随机变量只能用 $P(x_1 \leq X \leq x_2) =P(x_1&lt;X \leq x_2)=P(x_1 \leq X&lt;x_2)=P(x_1&lt;X&lt;x_2) =F(x_2)-F(x_1)$连续性随机变量都适用 离散型随机变量的F(x)含跳跃间断点；连续性随机变量F(x)连续且位于y=0与y=1之间 第五节 连续性随机变量的概率密度 分布函数F(x)与概率密度函数f(x)的关系： $f(x) = F^{′}(x) $ $F(x)=\int_{-\infty}^xf(t)dt$ 性质： $因为F(-\infty)=0,F(+\infty)=1,所以有\int_{-\infty}^{+\infty}f(x)dx = 1$ $P(x_1&lt;X \leq x_2)=F(x_2)-F(x_1)=\int_{x_1}^{x_2}f(x)dx$ 第六节 几种常用的连续随机变量的分布均匀分布 X~U(a,b) f(x)=\begin{cases} \frac{1}{b-a},&\text{a]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>概率论与数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛-41]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-41.html</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/contest/373#question A 翻硬币问题 题意：A和B玩游戏，A先手，要将n个正面硬币翻转为反面且每次只能翻转m个，B有一次可以在A翻转后将一枚硬币翻转的机会，给出n,m问A是否能将所有硬币翻转 思路： 简单签到题，容易想到： ​ 当n&lt;m时，A翻不了 ​ 当n==m时，A可以一下就翻完 ​ 当n&gt;m时，无论A是否刚好翻完，B都可以打乱 代码： 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main() &#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); if(n==m) puts("Yes"); else puts("No"); &#125; return 0;&#125; B 666RGP 题意：给出n个数(n&lt;=300,-666&lt;=ai&lt;=666)，分数开始初值为0，对于第i个数有两种操作，一是分数+a[i],二是分数*(-1)，问经过n个数后有多少种方法分数变为-666，且中间分数不能出现666，答案对1e8+7取模 思路：简单计数dp 设dp[i] [j]表示，经过第i个数后分数为j的答案，那么有dp[i] [j] = dp[i-1] [j - a[i]] + dp[i-1] [-j] 注意过滤掉j==666的情况 因为j最大会有2*300*666 这么大，如果开dp[300] [2*300*666] 肯定空间不够 考虑转移方程只和i 和 i-1有关，可以用滚动数组形式优化 代码： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxv = 700*300;const int P = 1e8+7;int dp[2][maxv*2];int a[305]; int main() &#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); dp[0][maxv]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=-666*n;j&lt;=666*n;j++)&#123; if(j==666) continue; dp[i&amp;1][j+maxv]=(dp[(i-1)&amp;1][-j+maxv]+dp[(i-1)&amp;1][j-a[i]+maxv])%P; &#125; &#125; printf("%d\n",dp[n&amp;1][-666+maxv]); return 0;&#125; C 抓捕盗窃犯 题意：在n点中，第i个点有ai个人，再给出下一时刻第i个点的所有人转移到vi点，问在m个地方建立哨卡（可以一直监控当地经过的人），最多可以监视到多少人 思路： n个点，每个点有一条有向出边 容易想到这些点将组成一些块 且每个块内都有一个环 这样，一个块的所有地点的人都会经过环 那么用并查集整合n个地点人口，再取前m大就行 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;int f[maxn];ll a[maxn],b[maxn]; int get(int x)&#123; return f[x]==x?x:f[x]=get(f[x]);&#125; int main() &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; f[i]=i; scanf("%lld",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; int to; scanf("%d",&amp;to); int x=get(i),y=get(to); if(x!=y)&#123; f[x]=y; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; int f=get(i); b[f]+=a[i]; &#125; sort(b+1,b+1+n); ll ans=0; for(int i=n;i&gt;n-m;i--)&#123; ans+=b[i]; &#125; printf("%lld\n",ans); return 0;&#125; D 最小相似度 题意：给出n个m长的二进制01串，问构造一个m长的01串使得这个串和这n个串对应位相同的数量最大的最小值 思路：将n个串都作为起点进行bfs，搜索完所有2^m内的数，dp[i]表示从某个起点到i需要翻转的位数，既有多少位与原先某个串不相同，m-max(dp[i]) 即为最小相同的位数 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn =3e5+5;int n,m;int dp[1&lt;&lt;20]; void bfs()&#123; queue&lt;int&gt;q; char s[25]; memset(dp,-1,sizeof(int)*((1&lt;&lt;m)+5)); for(int i=0;i&lt;n;i++)&#123; scanf("%s",s); int tmp=0; for(int j=0;j&lt;m;j++)&#123; tmp+=(1&lt;&lt;j)*(s[j]-'0'); &#125; dp[tmp]=0; q.push(tmp); &#125; while(!q.empty())&#123; int u=q.front(); q.pop(); for(int j=0;j&lt;m;j++)&#123; if(dp[u^(1&lt;&lt;j)]!=-1) continue; dp[u^(1&lt;&lt;j)]=dp[u]+1; q.push(u^(1&lt;&lt;j)); &#125; &#125;&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;m); bfs(); int ans=-1; for(int i=0;i&lt;(1&lt;&lt;m);i++) ans=max(ans,dp[i]); printf("%d\n",m-ans);&#125; E 球的体积并 题意：给出两个球的球心坐标和半径，求两球相交体积 思路：球冠体积公式(h为球冠高，r为球半径,d为球心距) V=PI*h(3a^2+h^2)/6=PI*h^2(3r-h)/3 h=r-(ra^2-rb^2+d^2)/2d注意外离、外切、内含的几种情况需特判 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const double PI = acos(-1);typedef struct point &#123; double x,y,z; point() &#123; &#125; point(double a, double b,double c) &#123; x = a; y = b; z = c; &#125; point operator -(const point &amp;b)const &#123; //返回减去后的新点 return point(x - b.x, y - b.y,z-b.z); &#125; point operator +(const point &amp;b)const &#123; //返回加上后的新点 return point(x + b.x, y + b.y,z+b.z); &#125; point operator *(const double &amp;k)const &#123; //返回相乘后的新点 return point(x * k, y * k,z*k); &#125; point operator /(const double &amp;k)const &#123; //返回相除后的新点 return point(x / k, y / k,z/k); &#125; double operator *(const point &amp;b)const &#123; //点乘 return x*b.x + y*b.y+z*b.z; &#125;&#125; point;double dist(point p1, point p2) &#123; //返回平面上两点距离 return sqrt((p1 - p2)*(p1 - p2));&#125;typedef struct sphere &#123;//球 double r; point centre; double v()&#123; return 4.0/3*PI*r*r*r; &#125;&#125; sphere;void Solve(sphere a, sphere b) &#123; double d = dist(a.centre, b.centre);//球心距 //double t = (d*d + a.r*a.r - b.r*b.r) / (2.0 * d);// //double h = sqrt((a.r*a.r) - (t*t)) * 2;//h1=h2，球冠的高 //double angle_a = 2 * acos((a.r*a.r + d*d - b.r*b.r) / (2.0 * a.r*d)); //余弦公式计算r1对应圆心角，弧度 //double angle_b = 2 * acos((b.r*b.r + d*d - a.r*a.r) / (2.0 * b.r*d)); //余弦公式计算r2对应圆心角，弧度 if(d-a.r-b.r&gt;=0)&#123; printf("%.10f\n",a.v()+b.v()); return; &#125; if(d+a.r&lt;b.r||d+b.r&lt;a.r)&#123; printf("%.10f\n",max(a.v(),b.v())); return; &#125; double l1 = (a.r*a.r - b.r*b.r + d*d) / (2*d); double l2 = (b.r*b.r - a.r*a.r + d*d) / (2*d); double h1 = a.r - l1, h2 = b.r - l2;//分别为两个球缺的高度 double v1 = PI*h1*h1*(a.r - h1 / 3);//相交部分r1圆所对应的球缺部分体积 double v2 = PI*h2*h2*(b.r - h2 / 3);//相交部分r2圆所对应的球缺部分体积 double v = v1 + v2;//相交部分体积 printf("%.10f\n",a.v()+b.v()-v); //double s1 = PI*a.r*x1; //r1对应球冠表面积 //double s2 = PI*a.r*x2; //r2对应球冠表面积 //double s = 4 * PI*(a.r*a.r + b.r*b.r) - s1 - s2;//剩余部分表面积&#125; int main() &#123; sphere a,b; scanf("%lf%lf%lf%lf",&amp;a.centre.x,&amp;a.centre.y,&amp;a.centre.z,&amp;a.r); scanf("%lf%lf%lf%lf",&amp;b.centre.x,&amp;b.centre.y,&amp;b.centre.z,&amp;b.r); Solve(a,b); return 0;&#125; F 简单数学题 数学弃… 岑巨出的题，难度适中，B题dp因为没注意要从dp[0] [maxv]开始初始化debug了很久 C题想到了并查集竟然不想写 E题内含的条件写错了，一直以为公式错了QAQ 还是大意了啊]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>bfs</tag>
        <tag>dp</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客OI周赛7-普及组]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2OI%E5%91%A8%E8%B5%9B7-%E6%99%AE%E5%8F%8A%E7%BB%84.html</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/contest/372#question A 救救猫咪 暴力 B 救救兔子 题意：给出n长数组，m个询问，每次询问给出一个x，要求数组中与x差距最小的数(如果差距相等，输出较小的那个) 思路： 二分，原数组排序后用upper_lowbound() 找出第一个比x大元素的位置，在分别比较当前位置和当前位置-1的数与x的差距，注意比第一个数小和最后一个数大的时候需特判 代码： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;int a[maxn]; int main()&#123; int n,q,x; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); sort(a,a+n); scanf("%d",&amp;q); while(q--)&#123; scanf("%d",&amp;x); if(x&gt;=a[n-1]) printf("%d\n",a[n-1]); else if(x&lt;=a[0]) printf("%d\n",a[0]); else&#123; int pos=upper_bound(a,a+n,x)-a; if(abs(a[pos-1]-x) &lt;= abs(a[pos]-x)) printf("%d\n",a[pos-1]); else printf("%d\n",a[pos]); &#125; &#125;&#125; C 救救企鹅 题意: 给出字符串s,a,b(长度&lt;=1e6),要求输出将s中所有a替换为b后的字符串 思路: kmp或hash求出s中与a匹配的位置,再替换一下即可 比赛的时候没有注意到a,b串的长度可以不相等 只过了50%qwq 赛后发现用Java或Python都可以直接秒这题tql 代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int maxn = 1e6+5;char s[maxn],a[maxn],b[maxn];int lens,lena,lenb;ull base=131;ull p[maxn],hs[maxn];ull geth(int l,int r)&#123; return (ull)hs[r]-hs[l-1]*p[r-l+1];&#125; vector&lt;int&gt;pos;int main()&#123; p[0]=1; for(int i=1;i&lt;maxn;i++) p[i]=p[i-1]*base; scanf("%s%s%s",s+1,a+1,b+1); lens=strlen(s+1); lena=lenb=strlen(a+1); ull tt=0; for(int i=1;i&lt;=lena;i++) tt=tt*base+(ull)a[i]; for(int i=1;i&lt;=lens;i++) hs[i]=hs[i-1]*base+(ull)s[i]; for(int i=1;i&lt;=lens-lena+1;i++)&#123; ull ss=geth(i,i+lena-1); if(ss==tt)&#123; pos.push_back(i); i+=lena-1; &#125; &#125; int k=1; for(int i=0;i&lt;pos.size();i++)&#123; while(k!=pos[i])&#123; putchar(s[k]); k++; &#125; printf("%s",b+1); k+=lena; &#125; while(k&lt;=lens)&#123; putchar(s[k]); k++; &#125; puts("");&#125; D 数糖纸 题意: 给出长度为n的数组(maxn=1e6),要求不含相同元素的最长连续区间长度 思路: 双指针(l,r)移动表示[l,r]内没有重复的元素,用个set记录当前区间已经出现了的数,如果枚举到一个没有出现的数,则加入set,++r,否则一直删除左端已经出现过的元素直到重复元素被删除 上面可以稍微优化一下,因为 Ai 最大1e9,我们先将原数组离散化,再用一个vis[] 记录Ai 是否出现过 代码1: 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;int a[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int ans=-1,l=1,r=1; set&lt;int&gt;s; while(r&lt;=n)&#123; if(s.find(a[r])==s.end())&#123; s.insert(a[r]); ans=max(ans,r-l+1); r++; &#125; else&#123; s.erase(a[l]); l++; &#125; &#125; printf("%d\n",ans);&#125; 代码2: 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;int a[maxn],b[maxn],pre[maxn],vis[maxn];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); b[i]=a[i]; &#125; sort(b+1,b+1+n); int m=unique(b+1,b+1+n)-b-1; for(int i=1;i&lt;=n;i++)&#123; a[i]=lower_bound(b+1,b+1+n,a[i])-b-1; &#125; int ans=-1,l=1; for(int i=1;i&lt;=n;i++)&#123; if(!vis[a[i]])&#123; vis[a[i]]=1; &#125; else&#123; while(a[l]!=a[i])&#123; vis[a[l]]=0; l++; &#125; l++; vis[a[i]]=1; &#125; ans=max(ans,i-l+1); &#125; printf("%d\n",ans);&#125; 一场比较简单的比赛,一点小粗心kmp就挂了 第一次在高铁上写博客,刺激~]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>二分</tag>
        <tag>字符串hash</tag>
        <tag>暴力</tag>
        <tag>kmp</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EOJ Monthly 2019.2]]></title>
    <url>%2FEOJ-Monthly-2019-2.html</url>
    <content type="text"><![CDATA[原题链接：https://acm.ecnu.edu.cn/contest/140/ A,B,C,E To be continue… D 进制转换 题意：求[l,r]中所有数的k进制末尾恰好有m个零的数有多少个 思路： x在k进制下末尾恰好有m个零说明x%(k^m)恒等于0，而x%(k^(m+1))不恒等于0，而x%(k^m)==0的情况包含了x%(k^(m+1))==0的情况，所以由容斥定理有[1,x]中满足题意的数有 x/(k^m) - x/(k^(m+1)) 个 代码： 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;ll calc(ll k,ll m,ll x)&#123; for(int i=1;i&lt;=m;i++)&#123; x/=k; &#125; return x;&#125;int main()&#123; ll l,r,k,m; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%lld%lld%lld%lld",&amp;l,&amp;r,&amp;k,&amp;m); printf("%lld\n",calc(k,m,r)-calc(k,m+1,r)-calc(k,m,l-1)+calc(k,m+1,l-1)); &#125;&#125; F 方差 题意： 在n个数中选m个数，使得这m个数的方差*(m^2)最小 思路： 首先想到要使方差越小，则要这m个数与平均数的差距越小，所以我们可以先排序再尺取m长; 不难发现将方差公式乘以m^2后可以化简得到 m(a_1^2+a_2^2+⋯+a_m^2) − (a_1+a_2+⋯+a_m)^2（MathJax真好用，小声哔哔 然后维护一个前缀和与一个前缀平方和即可 代码： 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+5;int a[maxn];ll sum1[maxn],sum2[maxn];int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; sort(a+1,a+1+n); for(int i=1;i&lt;=n;i++)&#123; sum1[i]=sum1[i-1]+a[i]; sum2[i]=sum2[i-1]+a[i]*a[i]; &#125; ll ans=-1; for(int i=m;i&lt;=n;i++)&#123; ll tmp=m*(sum2[i]-sum2[i-m])-(sum1[i]-sum1[i-m])*(sum1[i]-sum1[i-m]); if(ans==-1||ans&gt;tmp) ans=tmp; &#125; printf("%lld\n",ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客OI周赛7-提高组]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2OI%E5%91%A8%E8%B5%9B7-%E6%8F%90%E9%AB%98%E7%BB%84.html</url>
    <content type="text"><![CDATA[原题链接：https://ac.nowcoder.com/acm/contest/371#question A 小睿睿的等式 题意：有n根火柴棒，能摆成形如“A+B=n”的等式且使用的火柴棒数也恰好等于n/k的等式有多少种(B+A=n与A+B=n看作一种,“=”与“+”分别需要使用2根火柴棒,maxn=5e7) 思路：直接暴力拆分每组A+B写的挫会超时，比赛时没注意给出的空间很大(512MB)，先将所有5e7以内数所需火柴数打表即可 代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =5e7+5;int num[maxn];int main() &#123; num[0]=6; num[1]=2; num[2]=5; num[3]=5; num[4]=4; num[5]=5; num[6]=6; num[7]=3; num[8]=7; num[9]=6; int n; int k; scanf("%d%d",&amp;n,&amp;k); for(int i=10;i&lt;=n;i++)&#123; num[i]=num[i/10]+num[i%10]; &#125; int kk=n/k; int ans=0,x,y,z=num[n]; for(int a=0; a&lt;=n/2; a++) &#123; int b=n-a; x=num[a]; y=num[b]; if(x+y+z+4==kk) ans++; &#125; printf("%d\n",ans); return 0;&#125; B 小睿睿的询问 题意：给出随机生成一个n长数组的函数和生成区间查询L，R的函数，要求所有L，R区间生成数组中val[i]最大且较小下标异或值（maxn=1e5，maxm=5e7) 思路：最开始写的线段树（O(mlogn)），因为是随机数据没想到过了时间是全场最久的(4632/5000 ms),后来知道可以用ST表写，但自己写的挫，加了个二分查对应下标也用了2900+ms(O(nlognlogn))，再后来可以在ST表处直接用个pair，val[i]和i对应,每次查询O(1)，总体复杂度O(nlogn+m) 代码： 线段树版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =1e5+5;int n,m;int val[maxn],Max[maxn&lt;&lt;2],idx[maxn&lt;&lt;2]; void push_up(int l,int r,int o)&#123; Max[o]=max(Max[o&lt;&lt;1],Max[o&lt;&lt;1|1]); if(Max[o&lt;&lt;1] &gt;= Max[o&lt;&lt;1|1]) idx[o]=idx[o&lt;&lt;1]; else idx[o]=idx[o&lt;&lt;1|1];&#125; void build(int l,int r,int o)&#123; if(l==r)&#123; Max[o]=val[l]; idx[o]=l; return; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); push_up(l,r,o);&#125; int query(int L,int R,int l,int r,int o)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return idx[o]; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid&amp;&amp;R&gt;mid)&#123; int i=query(L,R,lson); int j=query(L,R,rson); if(val[i]&gt;=val[j]) return i; else return j; &#125; else if(L&lt;=mid)&#123; return query(L,R,lson); &#125; else if(R&gt;mid)&#123; return query(L,R,rson); &#125; return 0;&#125; void generate_array(int n,int seed) &#123; unsigned x = seed; for (int i=1; i&lt;=n; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; val[i]=x%100; &#125;&#125; int lastans=0,ans=0;void generate_ask(int n,int m,int seedx,int seedy) &#123; unsigned x=seedx,y=seedy; for (int i=1; i&lt;=m; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; y ^= y &lt;&lt; 13; y ^= y &gt;&gt; 17; y ^= y &lt;&lt; 5; int L=(x^lastans)%n+1,R=(y^lastans)%n+1; if (L&gt;R) swap(L,R); lastans=query(L,R,1,n,1); ans^=lastans; &#125; printf("%d\n",ans);&#125; int main() &#123; int seed,seedx,seedy; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;seed,&amp;seedx,&amp;seedy); //double ss=clock(); generate_array(n,seed); build(1,n,1); generate_ask(n,m,seedx,seedy); //printf("%.0fms\n",clock()-ss); return 0;&#125; 二分+ST版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =1e5+5;int n,m;int val[maxn];vector&lt;int&gt;idx[105];int f[maxn][20];void ST_pre()&#123; for(int i=1;i&lt;=n;i++)&#123; f[i][0]=val[i]; &#125; int t=log(n)/log(2)+1; for(int j=1;j&lt;t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]); &#125; &#125;&#125;int ST_query(int l,int r)&#123; int k=log(r-l+1)/log(2); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125; void generate_array(int n,int seed) &#123; unsigned x = seed; for (int i=1; i&lt;=n; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; val[i]=x%100; idx[val[i]].push_back(i); &#125;&#125; int lastans=0,ans=0;void generate_ask(int n,int m,int seedx,int seedy) &#123; unsigned x=seedx,y=seedy; for (int i=1; i&lt;=m; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; y ^= y &lt;&lt; 13; y ^= y &gt;&gt; 17; y ^= y &lt;&lt; 5; int L=(x^lastans)%n+1,R=(y^lastans)%n+1; if (L&gt;R) swap(L,R); int pos,Max=ST_query(L,R); int s=lower_bound(idx[Max].begin(),idx[Max].end(),L)-idx[Max].begin(); for(int k=s;k&lt;=idx[Max].size();k++)&#123; if(idx[Max][k]&gt;=L&amp;&amp;idx[Max][k]&lt;=R)&#123; pos=idx[Max][k]; break; &#125; &#125; lastans=pos; ans^=lastans; &#125; printf("%d\n",ans);&#125; int main() &#123; int seed,seedx,seedy; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;seed,&amp;seedx,&amp;seedy); //double ss=clock(); generate_array(n,seed); ST_pre(); generate_ask(n,m,seedx,seedy); //printf("%.0fms\n",clock()-ss); return 0;&#125; 优化ST版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define lson l,mid,o&lt;&lt;1#define rson mid+1,r,o&lt;&lt;1|1using namespace std;const int maxn =1e5+5;int n,m;int val[maxn];pair&lt;int,int&gt; f[maxn][20]; void ST_pre()&#123; for(int i=1;i&lt;=n;i++)&#123; f[i][0].first=i; f[i][0].second=val[i]; &#125; int t=log(n)/log(2)+1; for(int j=1;j&lt;t;j++)&#123; for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123; //f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]); f[i][j] = f[i][j-1].second &gt;= f[i+(1&lt;&lt;j-1)][j-1].second ? f[i][j-1]:f[i+(1&lt;&lt;j-1)][j-1]; &#125; &#125;&#125;int ST_query(int l,int r)&#123; int k=log(r-l+1)/log(2); return f[l][k].second &gt;= f[r-(1&lt;&lt;k)+1][k].second ? f[l][k].first : f[r-(1&lt;&lt;k)+1][k].first;&#125; void generate_array(int n,int seed) &#123; unsigned x = seed; for (int i=1; i&lt;=n; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; val[i]=x%100; &#125;&#125; int lastans=0,ans=0;void generate_ask(int n,int m,int seedx,int seedy) &#123; unsigned x=seedx,y=seedy; for (int i=1; i&lt;=m; ++i) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; y ^= y &lt;&lt; 13; y ^= y &gt;&gt; 17; y ^= y &lt;&lt; 5; int L=(x^lastans)%n+1,R=(y^lastans)%n+1; if (L&gt;R) swap(L,R); int pos=ST_query(L,R); lastans=pos; ans^=lastans; &#125; printf("%d\n",ans);&#125; int main() &#123; int seed,seedx,seedy; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;seed,&amp;seedx,&amp;seedy); //double ss=clock(); generate_array(n,seed); ST_pre(); generate_ask(n,m,seedx,seedy); //printf("%.0fms\n",clock()-ss); return 0;&#125; C 小睿睿的方案 To be continue… 这场Rating赛打得还是还算比较开心吧，学了一下ST表空间复杂度O(nlogn),区间查询O(1)很不错的算法，程序运算时间的计算和数组所占大概空间的计算，虽然理论课学了但一直没去实践QWQ另外牛客题目还不错~不说了EOJ的题还没补呢！]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>OI</tag>
        <tag>ST</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛 40A--小D的剧场]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-40A--%E5%B0%8FD%E7%9A%84%E5%89%A7%E5%9C%BA.html</url>
    <content type="text"><![CDATA[题意： 给出自然数1-49的49个数要求拼接成长度为n的序列，且要求任意相邻的三个不能为给出q个条件中任意一个条件的全排列，求所有合法序列数对 1e9+7 取模。 原题链接：https://ac.nowcoder.com/acm/contest/369/A Input: 123456789101110 10 //n q18 3 343 28 2242 28 348 48 429 9 3147 9 221 22 4915 48 292 8 274 24 34 Output: 1382785822 思路： 设dp[i] [j] [k]为放到第i位时，a[i-1]=j, a[i]==k的状态，提前将不合法字段标记，转移方程： dp_{i,k,l} = \sum_{i=1}^{49} (!ban_{j,k,l})*dp_{i-1,j,k}表示j,k,l可行时，可在 a[i-2]==j,a[i-1]==k的状态转移到 a[i-1]==k,a[i]==l的状态。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int P = 1e9+7;int dp[505][50][50];bool ban[50][50][50];int main()&#123; int n,q; scanf("%d%d",&amp;n,&amp;q); while(q--)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ban[a][b][c]=ban[a][c][b]=true; ban[b][a][c]=ban[b][c][a]=true; ban[c][a][b]=ban[c][b][a]=true; &#125; for(int i=1;i&lt;=49;i++)&#123; for(int j=1;j&lt;=49;j++)&#123; dp[2][i][j]=1; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=49;j++)&#123; for(int k=1;k&lt;=49;k++)&#123; for(int l=1;l&lt;=49;l++)&#123; if(!ban[j][k][l])&#123; dp[i][k][l]=(dp[i][k][l]+dp[i-1][j][k])%P; &#125; &#125; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=49;i++)&#123; for(int j=1;j&lt;=49;j++)&#123; ans=(ans+dp[n][i][j])%P; &#125; &#125; printf("%d\n",ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛 40C--小A与欧拉路]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-40C--%E5%B0%8FA%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%B7%AF.html</url>
    <content type="text"><![CDATA[题意： 小A给你了一棵树，对于这棵树上的每一条边，你都可以将它复制任意（可以为0）次（即在这条边连接的两个点之间再加一条边权相同的边），求所有可能新形成的图中欧拉路的最短长度 欧拉路：从图中任意一个点开始到图中任意一个点结束的路径，并且图中每条边只通过恰好一次。 原题链接：https://ac.nowcoder.com/acm/contest/369/C Input： 12344 //n 树的点数1 2 1 //u v w1 3 11 4 2 Output： 15 思路： 先考虑回路的情况。由于是一棵树，任两点间路径只有一条，从一条边走到深度更大的点，一定还会从同一条边返回以回到起点或者遍历其他子树，所以每条边需要复制一次，此时答案是边权和的两倍。 不是回路的情况可以减掉从终点回到起点的路径，要让这条路径尽量长，所以长度一定是直径的长度。 答案就是边权和的两倍减去直径长度。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2e5+5;struct EDGE&#123; int next,w,to;&#125;edge[maxn*2];int head[maxn];int cnt; void add(int u,int v,int w)&#123; edge[++cnt].next=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125; int pos,ans;int d[maxn];void dfs(int x,int pre)&#123; for(int i=head[x];i;i=edge[i].next)&#123; int to=edge[i].to; if(to==pre) continue; d[to]=d[x]+edge[i].w; dfs(to,x); &#125; if(d[x]&gt;ans)&#123; ans=d[x]; pos=x; &#125;&#125; int main()&#123; int n; scanf("%d",&amp;n); ll sum=0; for(int i=0;i&lt;n-1;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); sum+=2*w; &#125; dfs(1,-1); memset(d,0,sizeof(d)); dfs(pos,-1); printf("%lld\n",sum-ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>欧拉路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSU 1803--2016]]></title>
    <url>%2FCSU%201803--2016.html</url>
    <content type="text"><![CDATA[题意： 求[l,r]之间有多少种a*b=2016的组合。 思路： 首先2016的1倍情况下有1*2016 , 2*1008 , 3*637… 等情况，2倍情况就是把a或b扩大2倍就行，那么我们可以把a看做[1,2016]的数，a’ 看做[2017,4032]的数，这样每次跨2016个数就知道有多少倍数了。最后两层for循环找出i*j==2016的时候把对应的倍数种类乘起来加到答案就行了。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; int main()&#123; ll n,m; ll a[3000],b[3000]; //a[i]储存n有多少个i*2016&lt;=n，b[i]....m while(~scanf("%lld%lld",&amp;n,&amp;m)) &#123; ll k=n/2016; //有k个2016跨度 ll mm=n%2016; //余下的等下都要+1 for(int i=1;i&lt;=mm;i++) a[i]=k+1; for(int i=mm+1;i&lt;=2016;i++) a[i]=k; k=m/2016; mm=m%2016; for(int i=1;i&lt;=mm;i++) b[i]=k+1; for(int i=mm+1;i&lt;=2016;i++) b[i]=k; ll ans=0; for(int i=1;i&lt;=2016;i++) &#123; for(int j=1;j&lt;=2016;j++) &#123; if((i*j)%2016==0) &#123; ans+=(a[i]*b[j]); &#125; &#125; &#125; printf("%lld\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 4011--Happy-Sequence]]></title>
    <url>%2FZOJ%204011--Happy-Sequence.html</url>
    <content type="text"><![CDATA[题意： 给一个n和m，求所有组成m长且值在1-n内且满足 a[i]%a[i-1]==0 的序列方案数。 思路： dp[i] [j] 表示长度为 i 的序列的最后一位为 j ,转移方程：dp[i] [j]=0 , dp[i] [j]+=dp[i-1] [ j的因子 ] 。因子可以通过埃氏筛打表得到，dp[m] [i]累加和即为答案，预处理2000*2000以内所有答案即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std; #define N 2005#define mod 1000000007int dp[N][N];vector&lt;int&gt;y[N]; //储存因子int main()&#123; for(int i=1; i&lt;=N; i++) &#123; for(int j=i; j&lt;=N; j+=i) &#123; y[j].push_back(i); &#125; &#125; for(int i=1; i&lt;=N; i++) dp[1][i]=1; for(int i=2; i&lt;=N; i++) &#123; for(int j=1; j&lt;=N; j++) &#123; for(int k=0; k&lt;y[j].size(); k++) &#123; dp[i][j]=(dp[i][j]+dp[i-1][y[j][k]])%mod; &#125; &#125; &#125; int t; scanf("%d",&amp;t); while(t--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); int ans=0; for(int i=1; i&lt;=n; i++) ans=(ans+dp[m][i])%mod; printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 2594--Driving-Straight]]></title>
    <url>%2FZOJ%202594--Driving-Straight.html</url>
    <content type="text"><![CDATA[题意： 给出一个(2*m-1)*(2*n-1)的图，要求输出从左下角走到右上角最短距离走法的路径，只能在 ‘-’ 或 ‘|’ 上移动，答案保证有解，有多解输出任一，n,m&lt;=400。 思路： 因为题目要求输出路径，而bfs中如果每个状态都记录到当前状态的路径，可能会TLE或者MLE。 所以考虑先从终点开始bfs出每个点到终点的最短距离，然后再从起点出发bfs一直找 当前点的最短距离-1==下一步的最短距离 的位置就可以回到终点，注意方向的变换。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;using namespace std;char mp[1005][1005];int dis[1005][1005];int m,n;int dx[10]=&#123;-1,0,1,0&#125;; //反向由北到西顺时针 依次为0123int dy[10]=&#123;0,1,0,-1&#125;;int dd[10][10] = &#123;&#123;0, 1, 2, 3&#125;, // F&#123;3, 0, 1, 2&#125;, // L&#123;1, 2, 3, 0&#125; // R&#125;;char dir[10]=&#123;'F','L','R'&#125;; struct node&#123; int x,y; node()&#123;&#125; node(int x,int y):x(x),y(y)&#123;&#125;&#125;; void bfs()&#123; queue&lt;node&gt;q; memset(dis,-1,sizeof(dis)); dis[1][2*n-1]=0; q.push(node(1,2*n-1)); node now; int x,y,px,py; while(!q.empty()) &#123; now=q.front(); q.pop(); px=now.x,py=now.y; //printf("%d %d\n",px,py); for(int i=0;i&lt;4;i++) &#123; x=px+dx[i]; y=py+dy[i]; if(mp[x][y]=='-' || mp[x][y]=='|') &#123; x+=dx[i]; y+=dy[i]; if(dis[x][y]==-1) &#123; dis[x][y]=dis[px][py]+1; q.push(node(x,y)); &#125; &#125; &#125; &#125;&#125; void print()&#123; int statu,x,y,px,py; if(mp[2*m-1][2]=='-' &amp;&amp; dis[2*m-1][1]-1==dis[2*m-1][3]) &#123; puts("E"); px=2*m-1,py=3; statu=1; &#125; else if(mp[2*m-2][1]=='|' &amp;&amp; dis[2*m-1][1]-1==dis[2*m-3][1]) &#123; puts("N"); px=2*m-3,py=1; statu=0; &#125; while(1) &#123; if(dis[px][py]==0) &#123; puts(""); break; &#125; for(int i=0;i&lt;3;i++) &#123; x=px+dx[dd[i][statu]]; y=py+dy[dd[i][statu]]; if(mp[x][y]=='-' || mp[x][y]=='|') &#123; x+=dx[dd[i][statu]]; y+=dy[dd[i][statu]]; if(dis[x][y]==dis[px][py]-1) &#123; printf("%c",dir[i]); statu=dd[i][statu]; px=x,py=y; break; &#125; &#125; &#125; &#125;&#125; int main()&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;m,&amp;n); memset(mp,' ',sizeof(mp)); getchar(); for(int i=1; i&lt;=2*m-1; i++) &#123; gets(mp[i]+1); &#125; bfs(); /*for(int i=1;i&lt;=2*m-1;i+=2) &#123; for(int j=1;j&lt;=2*n-1;j+=2) &#123; printf("%3d",dis[i][j]); &#125;puts(""); &#125;*/ print(); if(T) puts(""); &#125;&#125; /*24 4+-+-+-+|+-+-+-+ |+-+-+-+|+-+-+-+NRFFLLFFRRFF4 4+-+ +-+| | |+ +-+-+| | |+-+-+-+| |+-+-+-+EFFLFF*/]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 110D--Lucky Probability]]></title>
    <url>%2FCodeforces%20110D--Lucky%20Probability.html</url>
    <content type="text"><![CDATA[题意： 出个两个（P,V）范围在1e9的正整数区间，分别从其中随机选出一个数，选出的两个数作为一个新区间的左右端点。要求新区间内的幸运数刚好为k个的概率（幸运数指一个数的数位只有4或7）。 思路： 首先可以dfs找出所有在数据范围内的幸运数，记为L数组，因为数目不多，便可成k段遍历 L数组，每次分别计算【 L[i-1]+1，L[i]】与【Pl，Pr】的线段交集，和【 L[i+k-1]，L[i+k]-1】与【Vl，Vr】的线段交集，将两个结果相乘即是符合[i,i+k-1]区间幸运数的可能情况，同样的还要对P,V两个区间交换后在计算一遍，概率=所有可能情况/(Pr-Pl+1)/(Vr-Vl+1);然后还要注意k==1的情况会重复计算，需特判。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll L[1050];int num=0;void dfs(int len,int p,int v)&#123; if(p==len) &#123; L[++num]=v; return; &#125; dfs(len,p+1,v*10+4); dfs(len,p+1,v*10+7);&#125; ll contain(ll x1,ll y1,ll x2,ll y2)&#123; ll l=max(x1,x2); ll r=min(y1,y2); return r-l+1&gt;0?r-l+1:0;&#125; int main()&#123; for(int len=1;len&lt;=9;len++) dfs(len,0,0); L[0]=0; L[++num]=1000000000; //for(int i=1;i&lt;=num;i++) printf("%d %lld\n",i,L[i]); ll Pl,Pr,Vl,Vr; int k; scanf("%lld%lld%lld%lld%d",&amp;Pl,&amp;Pr,&amp;Vl,&amp;Vr,&amp;k); ll sum=0; for(int i=1;i&lt;=1022-k+1;i++) &#123; int j=i+k-1; sum+=contain(L[i-1]+1,L[i],Pl,Pr)*contain(L[j],L[j+1]-1,Vl,Vr); if(L[i]&gt;Pr) break; &#125; for(int i=1;i&lt;=1022-k+1;i++) &#123; int j=i+k-1; sum+=contain(L[i-1]+1,L[i],Vl,Vr)*contain(L[j],L[j+1]-1,Pl,Pr); if(L[i]&gt;Vr) break; &#125; if(k==1) &#123; for(int i=1;i&lt;=1022;i++) &#123; if(contain(L[i],L[i],Pl,Pr)&amp;&amp;contain(L[i],L[i],Vl,Vr)) sum--; &#125; &#125; printf("%.10f\n",sum*1.0/(Vr-Vl+1)/(Pr-Pl+1));&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2774--Long Long Message]]></title>
    <url>%2FPOJ%202774--Long%20Long%20Message.html</url>
    <content type="text"><![CDATA[题意：给出两个最长长为1e5的字符串，求他们的最长公共子串长度。 思路： 分别将两个字符串预处理出hash值，二分【1-min（lens，lent）】的长度，check函数中每次将长度为mid的hash值记录并检查是否符合条件，是则下边界右移，否则上边界左移。复杂度O(nlogn) 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int N =100000+5; char s[N],t[N];int lens,lent;ull base=233;ull p[N],hs[N],ht[N];ull geths(int l,int r)&#123; return hs[r]-p[r-l+1]*hs[l-1];&#125;ull getht(int l,int r)&#123; return ht[r]-p[r-l+1]*ht[l-1];&#125; int check(int len)&#123; vector&lt;ull&gt;mp; for(int i=1; i&lt;=lens-len+1; i++) &#123; ull tmp=geths(i,i+len-1); mp.push_back(tmp); &#125; sort(mp.begin(),mp.end()); for(int i=1; i&lt;=lent-len+1; i++) &#123; ull tmp=getht(i,i+len-1); if(binary_search(mp.begin(),mp.end(),tmp)) return 1; &#125; return 0;&#125; int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); p[0]=1; for(int i=1; i&lt;N; i++) p[i]=p[i-1]*base; while(~scanf("%s%s",s+1,t+1)) &#123; lens=strlen(s+1); lent=strlen(t+1); for(int i=1; i&lt;=lens; i++) &#123; hs[i]=hs[i-1]*base+s[i]-'a'; &#125; for(int i=1; i&lt;=lent; i++) &#123; ht[i]=ht[i-1]*base+t[i]-'a'; &#125; int l=1,r=min(lens,lent),mid; while(l&lt;=r) &#123; mid=(l+r)/2; if(check(mid)) l=mid+1; else r=mid-1; &#125; printf("%d\n",r); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>字符串hash</tag>
      </tags>
  </entry>
</search>
